###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               08/Feb/2022  22:10:07
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Components\stack\bdb\bdb.c
#    Command line       =  
#        -f C:\usertemp\AppData\Local\Temp\EW667E.tmp ("I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Components\stack\bdb\bdb.c" -D SECURE=1 -D TC_LINKKEY_JOIN -D
#        NV_INIT -D NV_RESTORE -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D
#        xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_GROUPS -D ZCL_REPORT_DESTINATION_DEVICE -D ZCL_REPORT -D
#        HAL_LED=TRUE -D HAL_KEY=TRUE -D ISR_KEYINTERRUPT -D HAL_UART=TRUE -D
#        INT_HEAP_LEN=2300 -D HAL_LCD=TRUE -D xHAL_LCD_OLED12864 -D
#        HAL_ADC=TRUE -D HAL_UART=TRUE -D INT_HEAP_LEN=2048 -lC
#        "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List"
#        -lA "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\" -I
#        "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\Common\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\SPI\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\Font\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_LCD_SPI\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_OLED\"
#        -I "I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_TFT\"
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List\bdb.lst
#    Object file        =  
#        I:\ZigBee3.0\Zigbee3.0
#        20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack
#        3.0.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\Obj\bdb.r51
#
###############################################################################

I:\ZigBee3.0\Zigbee3.0 20211214\1.协议栈工作流程和无线收发控制LED\Z-Stack 3.0.1\Components\stack\bdb\bdb.c
      1          /**************************************************************************************************
      2            Filename:       bdb.c
      3            Revised:        $Date: 2016-02-25 11:51:49 -0700 (Thu, 25 Feb 2016) $
      4            Revision:       $Revision: - $
      5          
      6            Description:    This file contains the Base Device Behavior functions and attributes.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "bdb.h"
     45          #include "ZDApp.h"
     46          #include "OSAL.h"
     47          #include "ZDConfig.h"
     48          #include "hal_led.h"
     49          #include "ZDObject.h"
     50          #include "OSAL_Nv.h"
     51          #include "AddrMgr.h"
     52          #include "ZDSecMgr.h"
     53          #include "nwk.h"
     54          #include "nwk_util.h"
     55          #include "ssp_hash.h"
     56          #ifdef BDB_REPORTING
     57          #include "bdb_Reporting.h"
     58          #endif 
     59          
     60          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
     61          #include "gp_interface.h"
     62          #include "gp_common.h"
     63          #include "dgp_stub.h"
     64          #endif
     65          
     66          #include "bdb_interface.h"
     67          
     68          #if defined ( INTER_PAN ) 
     69          #if defined ( BDB_TL_INITIATOR )  
     70          #include "bdb_touchlink_initiator.h"
     71          #endif
     72          #if defined ( BDB_TL_TARGET )  
     73          #include "bdb_touchlink_target.h"
     74          #endif
     75          #endif
     76             
     77          #if defined ( INTER_PAN ) && ( defined ( BDB_TL_INITIATOR ) || defined ( BDB_TL_TARGET ) )
     78            #include "bdb_touchlink.h"
     79          #endif
     80           
     81          #ifdef MT_APP_CNF_FUNC
     82          #include "MT_APP_CONFIG.h"
     83          #endif
     84             
     85           /*********************************************************************
     86           * MACROS
     87           */
     88          //This is actually the channels used
     89          #define vScanChannels  zgDefaultChannelList
     90             
     91           /*********************************************************************
     92           * CONSTANTS
     93           */
     94          
     95          #define NUMBER_OF_CHANNELS     16
     96          
     97          #define CHANNEL_11_MASK_POS    11
     98          #define CHANNEL_26_MASK_POS    26
     99             

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    100          uint8 bdb_FB_InitiatorCurrentCyclesNumber = 0; //last cycle is #1 (i.e. cycles-left = (bdb_FB_InitiatorCurrentCyclesNumber - 1))
   \                     bdb_FB_InitiatorCurrentCyclesNumber:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    101          
    102          /*********************************************************************
    103           * TYPEDEFS
    104           */
    105           
    106           
    107           /*********************************************************************
    108           * GLOBAL VARIABLES
    109           */
    110          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          byte bdb_TaskID;
   \                     bdb_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    112          bdbAttributes_t bdbAttributes = BDB_ATTRIBUTES_DEFAULT_CONFIG;
   \                     bdbAttributes:
   \   000000                DS 18
   \   000012                REQUIRE `?<Initializer for bdbAttributes>`
   \   000012                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          epList_t *bdb_HeadEpDescriptorList = NULL;
   \                     bdb_HeadEpDescriptorList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    114          epList_t *bdb_CurrEpDescriptorList = NULL;
   \                     bdb_CurrEpDescriptorList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    115          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    116          bdbFindingBindingRespondent_t *pRespondentHead = NULL;
   \                     pRespondentHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    117          bdbFindingBindingRespondent_t *pRespondentCurr = NULL;
   \                     pRespondentCurr:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    118          bdbFindingBindingRespondent_t *pRespondentNext = NULL;
   \                     pRespondentNext:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    119          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    120          bdbCommissioningProcedureState_t bdbCommissioningProcedureState; 
   \                     bdbCommissioningProcedureState:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    121          bool bdb_initialization = FALSE;  //Variable to tell if the initialization process has been started
   \                     bdb_initialization:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    122          
    123          //Nwk formation and nwk steering for nodes not in nwk

   \                                 In  segment XDATA_I, align 1, keep-with-next
    124          bool vDoPrimaryScan = TRUE;
   \                     vDoPrimaryScan:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for vDoPrimaryScan>`
   \   000001                REQUIRE __INIT_XDATA_I
    125          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    126          uint8 zgBdbInstallCodeCRC[INSTALL_CODE_LEN + INSTALL_CODE_CRC_LEN] = {0x83,0xFE,0xD3,0x40,0x7A,0x93,0x97,0x23,0xA5,0xC6,0x39,0xB2,0x69,0x16,0xD5,0x05,0xC3,0xB5};
   \                     zgBdbInstallCodeCRC:
   \   000000                DS 18
   \   000012                REQUIRE `?<Initializer for zgBdbInstallCodeCRC>`
   \   000012                REQUIRE __INIT_XDATA_I
    127          
    128          //Pointer of the nwk being tried in association process
    129          #if (ZG_BUILD_JOINING_TYPE)
    130          static networkDesc_t *pBDBListNwk = NULL;
    131          #endif
    132          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    133          uint8 bdb_ZclTransactionSequenceNumber=0x00;
   \                     bdb_ZclTransactionSequenceNumber:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    134          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          bool touchLinkTargetEnabled = FALSE;
   \                     touchLinkTargetEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    136          
    137           /*********************************************************************
    138           * EXTERNAL VARIABLES
    139           */
    140          
    141          extern devStartModes_t devStartMode;
    142          extern bool  requestNewTrustCenterLinkKey;
    143          extern uint32 requestLinkKeyTimeout;
    144          extern uint32 ZDApp_SavedPollRate;
    145          
    146          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)
    147          extern bdbGCB_IdentifyTimeChange_t pfnIdentifyTimeChangeCB;
    148          extern uint8 bdbIndentifyActiveEndpoint;
    149          #endif
    150          
    151          extern bdbFindingBindingRespondent_t *pRespondentNext;
    152          
    153          #ifndef DISABLE_GREENPOWER_BASIC_PROXY
    154          extern ZDO_DeviceAnnce_t aliasConflictAnnce;
    155          #endif
    156          
    157          /*********************************************************************
    158           * EXTERNAL FUNCTIONS
    159           */
    160          
    161          extern void ZDApp_ResetTimerStart( uint16 delay );
    162          extern void ZDApp_NodeProfileSync( uint8 stackProfile );
    163          extern uint8 ZDApp_RestoreNwkKey( uint8 incrFrmCnt );
    164          extern uint8 ZDApp_ReadNetworkRestoreState( void );
    165          
    166          extern bdbFindingBindingRespondent_t* bdb_getRespondentRetry(bdbFindingBindingRespondent_t* pRespondentHead);
    167          extern void bdb_ProcessSimpleDesc( zdoIncomingMsg_t *msgPtr );
    168          extern void bdb_ProcessIEEEAddrRsp(zdoIncomingMsg_t *pMsg);
    169          
    170          /*********************************************************************
    171           * LOCAL VARIABLES
    172           */
    173          #if (ZG_BUILD_JOINING_TYPE)
    174            static uint8 bdb_nwkAssocRetriesCount = 0;
    175          #endif
    176          #if (ZG_BUILD_COORDINATOR_TYPE)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    177            static bdb_joiningDeviceList_t *bdb_joiningDeviceList = NULL;
   \                     bdb_joiningDeviceList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    178          #endif
    179            
    180          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1) 
    181          //Latch to save the status success of any attempt in the periodic F&B process  

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    182          static uint8 bdb_FBStateSuccessLatch = FALSE;
   \                     bdb_FBStateSuccessLatch:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    183          #endif
    184           /*********************************************************************
    185           * LOCAL FUNCTIONS
    186           */
    187          static void bdb_ProcessOSALMsg(bdbInMsg_t *msgPtr);
    188          void bdb_NotifyCommissioningModeStart(uint8 commissioningMode);
    189          static void bdb_processZDOMgs(zdoIncomingMsg_t *pMsg);
    190          
    191          #if (ZG_BUILD_JOINING_TYPE)
    192          static void bdb_requestTCStackVersion(void);
    193          static void bdb_requestTCLinkKey(void);
    194          static void bdb_requestVerifyTCLinkKey(void);
    195          static void bdb_tryNwkAssoc(void);
    196          #endif
    197          
    198          
    199          static void bdb_processTimeout(void);
    200          static void bdb_startResumeCommissioningProcess(void);
    201          static void bdb_nwkSteeringDeviceOnNwk(void);
    202          static void bdb_nwkJoiningFormation(bool isJoining);
    203          
    204          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
    205          static uint8 gp_ChangeChannelReq(void);
    206          static void gp_CBInit(void);
    207          #endif
    208          
    209          
    210          #if (ZG_BUILD_COORDINATOR_TYPE)
    211          static void bdb_TCProcessJoiningList(void);
    212          static ZStatus_t bdb_TCJoiningDeviceFree(bdb_joiningDeviceList_t* JoiningDeviceToRemove);
    213          #endif
    214          #if (ZG_BUILD_COORDINATOR_TYPE)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    215          static bdbGCB_TCLinkKeyExchangeProcess_t  pfnTCLinkKeyExchangeProcessCB = NULL;
   \                     pfnTCLinkKeyExchangeProcessCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    216          #endif

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    217          static bdbGCB_CommissioningStatus_t       pfnCommissioningStatusCB = NULL; 
   \                     pfnCommissioningStatusCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    218          #if (ZG_BUILD_JOINING_TYPE)
    219          static bdbGCB_CBKETCLinkKeyExchange_t     pfnCBKETCLinkKeyExchange = NULL;
    220          static bdbGCB_FilterNwkDesc_t             pfnFilterNwkDesc = NULL;   
    221          #endif
    222          
    223          
    224          
    225          void bdb_calculateCCITT_CRC (uint8 *Mb, uint32 msglen, uint16 *crc);
    226          void bdb_crcInit(uint16 *crc, uint16 *crcinit_direct, uint16 *crcinit_nondirect);
    227          uint16 bdb_crcReflect (uint16 crc, uint16 bitnum);
    228          uint16 bdb_crcBitByBitFast(uint8 * p, uint32 len, uint16 crcinit_direct, uint16 crcinit_nondirect);
    229          void bdb_ProcessNodeDescRsp(zdoIncomingMsg_t *pMsg);
    230          
    231          /*********************************************************************
    232           * PUBLIC FUNCTIONS
    233           *********************************************************************/
    234          void bdb_filterNwkDisc(void);
    235          ZStatus_t bdb_joinProcess(networkDesc_t *pChosenNwk);
    236          
    237          ZStatus_t bdb_TCAddJoiningDevice(uint16 parentAddr, uint8* JoiningExtAddr);
    238          void bdb_TCjoiningDeviceComplete(uint8* JoiningExtAddr);
    239          
    240           /*********************************************************************
    241           * @fn          bdb_Init
    242           *
    243           * @brief       Initialization function for the Base Device Behavior.
    244           *
    245           * @param       task_id - bdb_TaskID Task ID
    246           *
    247           * @return      none
    248           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    249          void bdb_Init( byte task_id )
   \                     bdb_Init:
    250          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    251            bdb_TaskID = task_id;
   \   000007   90....       MOV       DPTR,#bdb_TaskID
   \   00000A   F0           MOVX      @DPTR,A
    252              
    253          #if (ZG_BUILD_COORDINATOR_TYPE)
    254            if(ZG_DEVICE_COORDINATOR_TYPE)
    255            {
    256              if(bdbAttributes.bdbJoinUsesInstallCodeKey)
   \   00000B   90....       MOV       DPTR,#bdbAttributes + 15
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   6006         JZ        ??bdb_Init_0
    257              {
    258                zgAllowInstallCodes = ZG_IC_MUST_USED;
   \   000011   90....       MOV       DPTR,#zgAllowInstallCodes
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
    259              }
    260            }
    261          #endif
    262            
    263          #if defined ( INTER_PAN ) && defined ( BDB_TL_INITIATOR )  
    264            touchLinkInitiator_InitDevice( );
    265          #endif
    266          
    267          #if (BDB_REPORTING)
    268            bdb_RepInit();
    269          #endif  
    270            
    271            //Register ZDO callbacks
    272            ZDO_RegisterForZDOMsg ( task_id, Node_Desc_rsp );
   \                     ??bdb_Init_0:
   \   000017                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000017   7A02         MOV       R2,#0x2
   \   000019   7B80         MOV       R3,#-0x80
   \   00001B   12....       LCALL     `??ZDO_RegisterForZDOMsg::?relay`; Banked call to: ZDO_RegisterForZDOMsg
    273          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)  
    274            ZDO_RegisterForZDOMsg ( task_id, IEEE_addr_rsp );
   \   00001E                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   00001E   7A01         MOV       R2,#0x1
   \   000020   7B80         MOV       R3,#-0x80
   \   000022   EE           MOV       A,R6
   \   000023   F9           MOV       R1,A
   \   000024   12....       LCALL     `??ZDO_RegisterForZDOMsg::?relay`; Banked call to: ZDO_RegisterForZDOMsg
    275            ZDO_RegisterForZDOMsg ( task_id, Simple_Desc_rsp );
   \   000027                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000027   7A04         MOV       R2,#0x4
   \   000029   7B80         MOV       R3,#-0x80
   \   00002B   EE           MOV       A,R6
   \   00002C   F9           MOV       R1,A
   \   00002D   12....       LCALL     `??ZDO_RegisterForZDOMsg::?relay`; Banked call to: ZDO_RegisterForZDOMsg
    276          #endif
    277            
    278          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
    279            gp_RegisterGPChangeChannelReqForBDBCB(gp_ChangeChannelReq);
   \   000030                ; Setup parameters for call to function gp_RegisterGPChangeChannelReqForBDBCB
   \   000030   7A..         MOV       R2,#`??gp_ChangeChannelReq::?relay` & 0xff
   \   000032   7B..         MOV       R3,#(`??gp_ChangeChannelReq::?relay` >> 8) & 0xff
   \   000034   12....       LCALL     `??gp_RegisterGPChangeChannelReqForBDBCB::?relay`; Banked call to: gp_RegisterGPChangeChannelReqForBDBCB
    280            gp_CBInit();
   \   000037   90....       MOV       DPTR,#GP_DataCnfGCB
   \   00003A   74..         MOV       A,#`??GP_DataCnf::?relay` & 0xff
   \   00003C   F0           MOVX      @DPTR,A
   \   00003D   A3           INC       DPTR
   \   00003E   74..         MOV       A,#(`??GP_DataCnf::?relay` >> 8) & 0xff
   \   000040   F0           MOVX      @DPTR,A
   \   000041   90....       MOV       DPTR,#GP_endpointInitGCB
   \   000044   74..         MOV       A,#`??gp_endpointInit::?relay` & 0xff
   \   000046   F0           MOVX      @DPTR,A
   \   000047   A3           INC       DPTR
   \   000048   74..         MOV       A,#(`??gp_endpointInit::?relay` >> 8) & 0xff
   \   00004A   F0           MOVX      @DPTR,A
   \   00004B   90....       MOV       DPTR,#GP_expireDuplicateFilteringGCB
   \   00004E   74..         MOV       A,#`??gp_expireDuplicateFiltering::?relay` & 0xff
   \   000050   F0           MOVX      @DPTR,A
   \   000051   A3           INC       DPTR
   \   000052   74..         MOV       A,#(`??gp_expireDuplicateFiltering::?relay` >> 8) & 0xff
   \   000054   F0           MOVX      @DPTR,A
   \   000055   90....       MOV       DPTR,#GP_stopCommissioningModeGCB
   \   000058   74..         MOV       A,#`??gp_stopCommissioningMode::?relay` & 0xff
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   A3           INC       DPTR
   \   00005C   74..         MOV       A,#(`??gp_stopCommissioningMode::?relay` >> 8) & 0xff
   \   00005E   F0           MOVX      @DPTR,A
   \   00005F   90....       MOV       DPTR,#GP_returnOperationalChannelGCB
   \   000062   74..         MOV       A,#`??gp_returnOperationalChannel::?relay` & 0xff
   \   000064   F0           MOVX      @DPTR,A
   \   000065   A3           INC       DPTR
   \   000066   74..         MOV       A,#(`??gp_returnOperationalChannel::?relay` >> 8) & 0xff
   \   000068   F0           MOVX      @DPTR,A
   \   000069   90....       MOV       DPTR,#GP_DataIndGCB
   \   00006C   74..         MOV       A,#`??GP_DataInd::?relay` & 0xff
   \   00006E   F0           MOVX      @DPTR,A
   \   00006F   A3           INC       DPTR
   \   000070   74..         MOV       A,#(`??GP_DataInd::?relay` >> 8) & 0xff
   \   000072   F0           MOVX      @DPTR,A
   \   000073   90....       MOV       DPTR,#GP_SecReqGCB
   \   000076   74..         MOV       A,#`??GP_SecReq::?relay` & 0xff
   \   000078   F0           MOVX      @DPTR,A
   \   000079   A3           INC       DPTR
   \   00007A   74..         MOV       A,#(`??GP_SecReq::?relay` >> 8) & 0xff
   \   00007C   F0           MOVX      @DPTR,A
   \   00007D   90....       MOV       DPTR,#GP_CheckAnnouncedDeviceGCB
   \   000080   74..         MOV       A,#`??gp_CheckAnnouncedDevice::?relay` & 0xff
   \   000082   F0           MOVX      @DPTR,A
   \   000083   A3           INC       DPTR
   \   000084   74..         MOV       A,#(`??gp_CheckAnnouncedDevice::?relay` >> 8) & 0xff
   \   000086   F0           MOVX      @DPTR,A
   \   000087   90....       MOV       DPTR,#GP_aliasConflictAnnce
   \   00008A   74..         MOV       A,#aliasConflictAnnce & 0xff
   \   00008C   F0           MOVX      @DPTR,A
   \   00008D   A3           INC       DPTR
   \   00008E   74..         MOV       A,#(aliasConflictAnnce >> 8) & 0xff
   \   000090   F0           MOVX      @DPTR,A
   \   000091                ; Setup parameters for call to function gp_endpointInit
   \   000091   12....       LCALL     `??gp_endpointInit::?relay`; Banked call to: gp_endpointInit
    281          #endif
    282          }
   \   000094   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    283          
    284          /*********************************************************************
    285           * @fn      bdb_RegisterSimpleDescriptor
    286           *
    287           * @brief   Register the Simple descriptor. This function also registers 
    288           *          the profile's cluster conversion table.
    289           *
    290           * @param   simpleDesc - a pointer to a valid SimpleDescriptionFormat_t, must not be NULL.
    291           *
    292           * @return  none
    293           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    294          void bdb_RegisterSimpleDescriptor( SimpleDescriptionFormat_t *simpleDesc )
   \                     bdb_RegisterSimpleDescriptor:
    295          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    296            endPointDesc_t *epDesc;
    297          
    298            // Register the application's endpoint descriptor
    299            //  - This memory is allocated and never freed.
    300            epDesc = osal_mem_alloc( sizeof ( endPointDesc_t ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A07         MOV       R2,#0x7
   \   00000B   7B00         MOV       R3,#0x0
   \   00000D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
    301            if ( epDesc )
   \   000010   EA           MOV       A,R2
   \   000011   4B           ORL       A,R3
   \   000012   6023         JZ        ??bdb_RegisterSimpleDescriptor_0
    302            {
    303              // Fill out the endpoint description.
    304              epDesc->endPoint = simpleDesc->EndPoint;
   \   000014   8E82         MOV       DPL,R6
   \   000016   8F83         MOV       DPH,R7
   \   000018   E0           MOVX      A,@DPTR
   \   000019   8A82         MOV       DPL,R2
   \   00001B   8B83         MOV       DPH,R3
   \   00001D   F0           MOVX      @DPTR,A
    305              epDesc->task_id = &zcl_TaskID;   // all messages get sent to ZCL first
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   74..         MOV       A,#zcl_TaskID & 0xff
   \   000022   F0           MOVX      @DPTR,A
   \   000023   A3           INC       DPTR
   \   000024   74..         MOV       A,#(zcl_TaskID >> 8) & 0xff
   \   000026   12....       LCALL     ?Subroutine14 & 0xFFFF
    306              epDesc->simpleDesc = simpleDesc;
   \                     ??CrossCallReturnLabel_4:
   \   000029   EE           MOV       A,R6
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   EF           MOV       A,R7
   \   00002D   12....       LCALL     ?Subroutine14 & 0xFFFF
    307              epDesc->latencyReq = noLatencyReqs;
   \                     ??CrossCallReturnLabel_5:
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E4           CLR       A
   \   000033   F0           MOVX      @DPTR,A
    308          
    309              // Register the endpoint description with the AF
    310              afRegister( epDesc );
   \   000034                ; Setup parameters for call to function afRegister
   \   000034   12....       LCALL     `??afRegister::?relay`; Banked call to: afRegister
    311            }
    312          }
   \                     ??bdb_RegisterSimpleDescriptor_0:
   \   000037   80..         SJMP      ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine45_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    313          
    314          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)  
    315          /*********************************************************************
    316           * @fn      bdb_ZclIdentifyCmdInd
    317           *
    318           * @brief   Callback from the ZCL General Cluster Library when
    319           *          it received an Identity Command for this application.
    320           *
    321           * @param   identifyTime - the number of seconds to identify yourself
    322           * @param   endpoint - destination endpoint
    323           *
    324           * @return  none
    325           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    326          void bdb_ZclIdentifyCmdInd( uint16 identifyTime, uint8 endpoint )
   \                     bdb_ZclIdentifyCmdInd:
    327          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   E9           MOV       A,R1
   \   00000F   FE           MOV       R6,A
    328            zclAttrRec_t identifyAttrRec;
    329            
    330            if ( zclFindAttrRec( endpoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    331                                ATTRID_IDENTIFY_TIME, &identifyAttrRec ) )
   \   000010                ; Setup parameters for call to function zclFindAttrRec
   \   000010   A8..         MOV       R0,?XSP + 0
   \   000012   A9..         MOV       R1,?XSP + 1
   \   000014   88..         MOV       ?V2,R0
   \   000016   89..         MOV       ?V3,R1
   \   000018   78..         MOV       R0,#?V2
   \   00001A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001D   7C00         MOV       R4,#0x0
   \   00001F   7D00         MOV       R5,#0x0
   \   000021   7A03         MOV       R2,#0x3
   \   000023   7B00         MOV       R3,#0x0
   \   000025   EE           MOV       A,R6
   \   000026   F9           MOV       R1,A
   \   000027   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   00002A   7402         MOV       A,#0x2
   \   00002C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002F   E9           MOV       A,R1
   \   000030   6050         JZ        ??bdb_ZclIdentifyCmdInd_0
    332            {
    333              //If we are processing an actual change
    334              if(*(uint16*)identifyAttrRec.attr.dataPtr != identifyTime)
   \   000032   7406         MOV       A,#0x6
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   65..         XRL       A,?V0
   \   00003D   7004         JNZ       ??bdb_ZclIdentifyCmdInd_1
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   65..         XRL       A,?V1
   \                     ??bdb_ZclIdentifyCmdInd_1:
   \   000043   603D         JZ        ??bdb_ZclIdentifyCmdInd_0
    335              {
    336                if ( identifyTime > 0 )
   \   000045   E5..         MOV       A,?V0
   \   000047   45..         ORL       A,?V1
   \   000049   8882         MOV       DPL,R0
   \   00004B   8983         MOV       DPH,R1
   \   00004D   6019         JZ        ??bdb_ZclIdentifyCmdInd_2
    337                {
    338                  *((uint16*)identifyAttrRec.attr.dataPtr) = identifyTime;
   \   00004F   E5..         MOV       A,?V0
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   E5..         MOV       A,?V1
   \   000055   F0           MOVX      @DPTR,A
    339                  osal_start_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT, 1000 );
   \   000056                ; Setup parameters for call to function osal_start_timerEx
   \   000056   90....       MOV       DPTR,#__Constant_3e8
   \   000059   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00005C   7A00         MOV       R2,#0x0
   \   00005E   7B20         MOV       R3,#0x20
   \   000060   12....       LCALL     ??Subroutine61_0 & 0xFFFF
    340                }
   \                     ??CrossCallReturnLabel_117:
   \   000063   12....       LCALL     ?DEALLOC_XSTACK8
   \   000066   800A         SJMP      ??CrossCallReturnLabel_127
    341                else if ( identifyTime <= 0 )
    342                {
    343                  *((uint16*)identifyAttrRec.attr.dataPtr) = 0;
   \                     ??bdb_ZclIdentifyCmdInd_2:
   \   000068   E4           CLR       A
   \   000069   F0           MOVX      @DPTR,A
   \   00006A   A3           INC       DPTR
   \   00006B   F0           MOVX      @DPTR,A
    344                  osal_stop_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT );
   \   00006C                ; Setup parameters for call to function osal_stop_timerEx
   \   00006C   FA           MOV       R2,A
   \   00006D   7B20         MOV       R3,#0x20
   \   00006F   12....       LCALL     ??Subroutine63_0 & 0xFFFF
    345                }
    346                
    347                if(pfnIdentifyTimeChangeCB != NULL)
   \                     ??CrossCallReturnLabel_127:
   \   000072   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB
   \   000075   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000078   6008         JZ        ??bdb_ZclIdentifyCmdInd_0
    348                {
    349                  pfnIdentifyTimeChangeCB(endpoint);
   \   00007A                ; Setup parameters for indirect call
   \   00007A   EE           MOV       A,R6
   \   00007B   F9           MOV       R1,A
   \   00007C   12....       LCALL     ??Subroutine59_0 & 0xFFFF
    350                }
    351              }
    352            }
   \                     ??CrossCallReturnLabel_103:
   \   00007F   12....       LCALL     ?CALL_IND
    353          }
   \                     ??bdb_ZclIdentifyCmdInd_0:
   \   000082   7408         MOV       A,#0x8
   \   000084   02....       LJMP      ??Subroutine56_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine56_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine57_0
   \   000003                ; // Fall through to label ??Subroutine57_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine57_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   8882         MOV       DPL,R0
   \   000007   F583         MOV       DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine58_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   E8           MOV       A,R0
   \   000006   49           ORL       A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine59_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F583         MOV       DPH,A
   \   000003   8882         MOV       DPL,R0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine61_0:
   \   000000   90....       MOV       DPTR,#bdb_TaskID
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000008   7404         MOV       A,#0x4
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine63_0:
   \   000000   90....       MOV       DPTR,#bdb_TaskID
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
   \   000008   22           RET
    354          #endif
    355          
    356          
    357          #if (ZG_BUILD_JOINING_TYPE) 
    358           /*********************************************************************
    359           * @fn          bdb_setActiveCentralizedLinkKey
    360           *
    361           * @brief       Set the active centralized key to be used, Global or IC derived.
    362           *
    363           * @param       useGlobal - If TRUE, then use default TC link key, if FALSE use 
    364           *                          pBuf as source for IC key derived input
    365           * @param       pBuf - The expected format and length of the IC is defined by 
    366           *                     BDB_INSTALL_CODE_USE
    367           *
    368           * @return      ZStatus_t - ZFailure when no valid BDB_INSTALL_CODE_USE is used
    369           *                          ZInvalidParameter when IC buffer is null
    370           */
    371          ZStatus_t bdb_setActiveCentralizedLinkKey(bool useGlobal, uint8* pBuf)
    372          {
    373            ZStatus_t Status = ZSuccess;
    374            uint8 extAddr[Z_EXTADDR_LEN];
    375            
    376            if(useGlobal)
    377            {
    378              //Set the default key to be used in centralized networks as defaultTCLinkKey
    379              APSME_SetDefaultKey();
    380            } 
    381            else
    382            {
    383              if(pBuf != NULL)
    384              {
    385            #if (BDB_INSTALL_CODE_USE==BDB_INSTALL_CODE_USE_IC_CRC)
    386                
    387                osal_memset(extAddr,0x00,Z_EXTADDR_LEN);
    388                
    389                //Set the install code as default key
    390                Status = bdb_addInstallCode(pBuf,extAddr);
    391              
    392            #elif (BDB_INSTALL_CODE_USE==BDB_INSTALL_CODE_USE_KEY)
    393          
    394                //Set the key as global default
    395                APSME_AddTCLinkKey(pBuf,extAddr);
    396            #else
    397              
    398                //BDB_INSTALL_CODE_USE not supported
    399                Status = ZFailure;
    400            #endif
    401              }
    402              else
    403              {
    404                Status = ZInvalidParameter;
    405              }
    406            }
    407            return Status;
    408          }
    409          #endif
    410          
    411          
    412              
    413            
    414          /******************************************************************************
    415           * @fn          bdb_addInstallCode
    416           *
    417           * @brief       Interface to add an install codes and adds a APS TC Link key.
    418           *
    419           * @param       pInstallCode - [in] Install Code with CRC (buffer size of 18 bytes).
    420           *              pExt - [in] Extended address of the node.
    421           *
    422           * @return      ZStatus_t
    423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    424          ZStatus_t bdb_addInstallCode(uint8* pInstallCode, uint8* pExt)
   \                     bdb_addInstallCode:
    425          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV       A,#-0x10
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V2,R4
   \   000010   8D..         MOV       ?V3,R5
    426            uint8  hashOutput[16];
    427            uint16 CRC;
    428            
    429          #if (ZG_BUILD_COORDINATOR_TYPE)
    430            if(ZG_DEVICE_COORDINATOR_TYPE)
    431            {
    432              if(zgAllowInstallCodes == ZG_IC_NOT_SUPPORTED)
   \   000012   90....       MOV       DPTR,#zgAllowInstallCodes
   \   000015   E0           MOVX      A,@DPTR
   \   000016   7004         JNZ       ??bdb_addInstallCode_0
    433              {
    434                return ZFailure;
   \   000018   7901         MOV       R1,#0x1
   \   00001A   805C         SJMP      ??bdb_addInstallCode_1
    435              }
    436            }
    437          #endif
    438                 
    439            if((pInstallCode == NULL) || (pExt == NULL))
   \                     ??bdb_addInstallCode_0:
   \   00001C   EA           MOV       A,R2
   \   00001D   4F           ORL       A,R7
   \   00001E   601F         JZ        ??bdb_addInstallCode_2
   \   000020   EC           MOV       A,R4
   \   000021   4D           ORL       A,R5
   \   000022   601B         JZ        ??bdb_addInstallCode_2
    440            {
    441              return ZInvalidParameter;
    442            }
    443            
    444            CRC = bdb_GenerateInstallCodeCRC(pInstallCode);
   \   000024                ; Setup parameters for call to function bdb_GenerateInstallCodeCRC
   \   000024   12....       LCALL     `??bdb_GenerateInstallCodeCRC::?relay`; Banked call to: bdb_GenerateInstallCodeCRC
   \   000027   8A..         MOV       ?V0,R2
   \   000029   8B..         MOV       ?V1,R3
    445            //Validate CRC
    446            if(CRC != osal_build_uint16(&pInstallCode[INSTALL_CODE_LEN]))
   \   00002B                ; Setup parameters for call to function osal_build_uint16
   \   00002B   EE           MOV       A,R6
   \   00002C   2410         ADD       A,#0x10
   \   00002E   FA           MOV       R2,A
   \   00002F   E4           CLR       A
   \   000030   3F           ADDC      A,R7
   \   000031   FB           MOV       R3,A
   \   000032   12....       LCALL     `??osal_build_uint16::?relay`; Banked call to: osal_build_uint16
   \   000035   EA           MOV       A,R2
   \   000036   65..         XRL       A,?V0
   \   000038   7003         JNZ       ??bdb_addInstallCode_3
   \   00003A   EB           MOV       A,R3
   \   00003B   65..         XRL       A,?V1
   \                     ??bdb_addInstallCode_3:
   \   00003D   6004         JZ        ??bdb_addInstallCode_4
    447            {
    448              return ZInvalidParameter;
   \                     ??bdb_addInstallCode_2:
   \   00003F   7902         MOV       R1,#0x2
   \   000041   8035         SJMP      ??bdb_addInstallCode_1
    449            }
    450          
    451            sspMMOHash (NULL, 0, pInstallCode,(INSTALL_CODE_LEN + INSTALL_CODE_CRC_LEN) * BITS_PER_BYTE, hashOutput);
   \                     ??bdb_addInstallCode_4:
   \   000043                ; Setup parameters for call to function sspMMOHash
   \   000043   A8..         MOV       R0,?XSP + 0
   \   000045   A9..         MOV       R1,?XSP + 1
   \   000047   88..         MOV       ?V0,R0
   \   000049   89..         MOV       ?V1,R1
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000050   75..90       MOV       ?V0,#-0x70
   \   000053   75..00       MOV       ?V1,#0x0
   \   000056   78..         MOV       R0,#?V0
   \   000058   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005B   EE           MOV       A,R6
   \   00005C   FC           MOV       R4,A
   \   00005D   EF           MOV       A,R7
   \   00005E   FD           MOV       R5,A
   \   00005F   7900         MOV       R1,#0x0
   \   000061   7A00         MOV       R2,#0x0
   \   000063   7B00         MOV       R3,#0x0
   \   000065   12....       LCALL     `??sspMMOHash::?relay`; Banked call to: sspMMOHash
   \   000068   7404         MOV       A,#0x4
   \   00006A   12....       LCALL     ?DEALLOC_XSTACK8
    452          
    453            return APSME_AddTCLinkKey(hashOutput,pExt);
   \   00006D                ; Setup parameters for call to function APSME_AddTCLinkKey
   \   00006D   AC..         MOV       R4,?V2
   \   00006F   AD..         MOV       R5,?V3
   \   000071   AA..         MOV       R2,?XSP + 0
   \   000073   AB..         MOV       R3,?XSP + 1
   \   000075   12....       LCALL     `??APSME_AddTCLinkKey::?relay`; Banked call to: APSME_AddTCLinkKey
   \                     ??bdb_addInstallCode_1:
   \   000078   7410         MOV       A,#0x10
   \   00007A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007D                REQUIRE ?Subroutine3
   \   00007D                ; // Fall through to label ?Subroutine3
    454          }    

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    455              
    456          
    457          #if (ZG_BUILD_COORDINATOR_TYPE)
    458           /*********************************************************************
    459           * @fn      bdb_RegisterTCLinkKeyExchangeProcessCB
    460           *
    461           * @brief   Register a callback to receive notifications on the joining devices 
    462           *          and its status on TC link key exchange
    463           *
    464           * @param   bdbGCB_TCLinkKeyExchangeProcess - application callback 
    465           *          (extended address of device, status: 0 = Joining, 1 = TC link key exchange success, 2 = TC link key exchange failed)
    466           *
    467           * @return  none
    468           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    469          void bdb_RegisterTCLinkKeyExchangeProcessCB(bdbGCB_TCLinkKeyExchangeProcess_t bdbGCB_TCLinkKeyExchangeProcess)
   \                     bdb_RegisterTCLinkKeyExchangeProcessCB:
    470          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    471            if(bdbGCB_TCLinkKeyExchangeProcess != NULL)
   \   000004   EA           MOV       A,R2
   \   000005   4B           ORL       A,R3
   \   000006   6006         JZ        ??CrossCallReturnLabel_143
    472            {
    473              pfnTCLinkKeyExchangeProcessCB = bdbGCB_TCLinkKeyExchangeProcess;
   \   000008   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
   \   00000B   12....       LCALL     ??Subroutine67_0 & 0xFFFF
    474            }
    475          }
   \                     ??CrossCallReturnLabel_143:
   \   00000E   02....       LJMP      ??Subroutine53_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine53_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine67_0:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET
    476          
    477          
    478          
    479           /*********************************************************************
    480           * @fn          bdb_setTCRequireKeyExchange
    481           *
    482           * @brief       Set the bdb_setTCRequireKeyExchange attribute
    483           *
    484           * @param       isKeyExchangeRequired - True if TC will remove devices that do 
    485           *              not perform key exchange after bdbTrustCenterNodeJoinTimeout, 
    486           *              False to not remove devices.
    487           *
    488           * @return      none
    489           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    490          void bdb_setTCRequireKeyExchange(bool isKeyExchangeRequired)
   \                     bdb_setTCRequireKeyExchange:
    491          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    492            bdbAttributes.bdbTrustCenterRequireKeyExchange = isKeyExchangeRequired;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#bdbAttributes + 17
   \   000008   02....       LJMP      ??Subroutine52_0 & 0xFFFF
    493          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine52_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                REQUIRE ??Subroutine53_0
   \   000001                ; // Fall through to label ??Subroutine53_0
    494          
    495          
    496          
    497           /*********************************************************************
    498           * @fn          bdb_TCAddJoiningDevice
    499           *
    500           * @brief       Add a joining device to the list of devices that must request a 
    501           *              key before bdbTrustCenterNodeJoinTimeout.
    502           *
    503           * @param       parentAddr - Address of the parent device
    504           * @param       JoiningExtAddr - IEEE address of the joining device
    505           *
    506           * @return      ZStatus_t - ZFailure No memory to allocate the device in the list
    507           *                          ZInvalidParameter
    508           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    509          ZStatus_t bdb_TCAddJoiningDevice(uint16 parentAddr, uint8* JoiningExtAddr)
   \                     bdb_TCAddJoiningDevice:
    510          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV       A,#-0xb
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine12 & 0xFFFF
    511            bdb_joiningDeviceList_t* tempJoiningDescNode;
    512            
    513            if((parentAddr == INVALID_NODE_ADDR) || (JoiningExtAddr == NULL))
   \                     ??CrossCallReturnLabel_147:
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   E0           MOVX      A,@DPTR
   \   000014   64FE         XRL       A,#0xfe
   \   000016   7003         JNZ       ??bdb_TCAddJoiningDevice_0
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F4           CPL       A
   \                     ??bdb_TCAddJoiningDevice_0:
   \   00001B   6004         JZ        ??bdb_TCAddJoiningDevice_1
   \   00001D   EC           MOV       A,R4
   \   00001E   4D           ORL       A,R5
   \   00001F   7005         JNZ       ??bdb_TCAddJoiningDevice_2
    514            {
    515              return ZInvalidParameter;
   \                     ??bdb_TCAddJoiningDevice_1:
   \   000021   7902         MOV       R1,#0x2
   \   000023   02....       LJMP      ??bdb_TCAddJoiningDevice_3 & 0xFFFF
    516            }
    517            
    518            //If the list was empty and element was allocated, then start the timer
    519            if(bdb_joiningDeviceList == NULL)
   \                     ??bdb_TCAddJoiningDevice_2:
   \   000026   8C..         MOV       ?V0,R4
   \   000028   8D..         MOV       ?V1,R5
   \   00002A   75..00       MOV       ?V2,#0x0
   \   00002D   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000030   7035         JNZ       ??bdb_TCAddJoiningDevice_4
    520            {
    521              bdb_joiningDeviceList = osal_mem_alloc(sizeof(bdb_joiningDeviceList_t));
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A0D         MOV       R2,#0xd
   \   000034   7B00         MOV       R3,#0x0
   \   000036   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000039   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   00003C   12....       LCALL     ??Subroutine67_0 & 0xFFFF
    522              if(bdb_joiningDeviceList == NULL)
   \                     ??CrossCallReturnLabel_144:
   \   00003F   F9           MOV       R1,A
   \   000040   EA           MOV       A,R2
   \   000041   49           ORL       A,R1
   \   000042   7003         JNZ       $+5
   \   000044   02....       LJMP      ??bdb_TCAddJoiningDevice_5 & 0xFFFF
    523              {
    524                return ZFailure;
    525              }
    526             
    527              osal_start_reload_timer(bdb_TaskID,BDB_TC_JOIN_TIMEOUT,1000);
   \   000047                ; Setup parameters for call to function osal_start_reload_timer
   \   000047   90....       MOV       DPTR,#__Constant_3e8
   \   00004A   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00004D   7A00         MOV       R2,#0x0
   \   00004F   7B08         MOV       R3,#0x8
   \   000051   90....       MOV       DPTR,#bdb_TaskID
   \   000054   E0           MOVX      A,@DPTR
   \   000055   F9           MOV       R1,A
   \   000056   12....       LCALL     `??osal_start_reload_timer::?relay`; Banked call to: osal_start_reload_timer
   \   000059   7404         MOV       A,#0x4
   \   00005B   12....       LCALL     ?DEALLOC_XSTACK8
    528              tempJoiningDescNode = bdb_joiningDeviceList;
   \   00005E   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000061   E0           MOVX      A,@DPTR
   \   000062   FE           MOV       R6,A
   \   000063   A3           INC       DPTR
   \   000064   E0           MOVX      A,@DPTR
   \   000065   8070         SJMP      ??bdb_TCAddJoiningDevice_6
    529            }
    530            //if the list was not empty then add the entry at the end of the list
    531            else
    532            {
    533              tempJoiningDescNode = bdb_joiningDeviceList;
   \                     ??bdb_TCAddJoiningDevice_4:
   \   000067   12....       LCALL     ?Subroutine40 & 0xFFFF
    534              
    535              //Validate that this is not already in the list... somehow
    536              if(osal_memcmp(JoiningExtAddr,tempJoiningDescNode->bdbJoiningNodeEui64,Z_EXTADDR_LEN))
   \                     ??CrossCallReturnLabel_136:
   \   00006A                ; Setup parameters for call to function osal_memcmp
   \   00006A   8882         MOV       DPL,R0
   \   00006C   F583         MOV       DPH,A
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A982         MOV       R1,DPL
   \   000072   AA83         MOV       R2,DPH
   \   000074   89..         MOV       ?V4,R1
   \   000076   8A..         MOV       ?V5,R2
   \   000078   75..00       MOV       ?V6,#0x0
   \   00007B   78..         MOV       R0,#?V4
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000080   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000083   12....       LCALL     ?DEALLOC_XSTACK8
   \   000086   E9           MOV       A,R1
   \   000087   7030         JNZ       ??bdb_TCAddJoiningDevice_7
    537              {
    538                //The device added is already in the list, refresh its time and do nothing else
    539                tempJoiningDescNode->NodeJoinTimeout = bdbAttributes.bdbTrustCenterNodeJoinTimeout;
    540                return ZSuccess;
    541              }
    542              
    543              while(tempJoiningDescNode->nextDev != NULL)
   \                     ??bdb_TCAddJoiningDevice_8:
   \   000089   EE           MOV       A,R6
   \   00008A   240B         ADD       A,#0xb
   \   00008C   FE           MOV       R6,A
   \   00008D   5001         JNC       ??bdb_TCAddJoiningDevice_9
   \   00008F   0F           INC       R7
   \                     ??bdb_TCAddJoiningDevice_9:
   \   000090   F582         MOV       DPL,A
   \   000092   8F83         MOV       DPH,R7
   \   000094   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000097   6027         JZ        ??bdb_TCAddJoiningDevice_10
    544              {
    545                tempJoiningDescNode = tempJoiningDescNode->nextDev;
   \   000099   E8           MOV       A,R0
   \   00009A   FE           MOV       R6,A
   \   00009B   E9           MOV       A,R1
   \   00009C   FF           MOV       R7,A
    546                
    547                //Validate that this is not already in the list... somehow
    548                if(osal_memcmp(JoiningExtAddr,tempJoiningDescNode->bdbJoiningNodeEui64,Z_EXTADDR_LEN))
   \   00009D                ; Setup parameters for call to function osal_memcmp
   \   00009D   8882         MOV       DPL,R0
   \   00009F   F583         MOV       DPH,A
   \   0000A1   A3           INC       DPTR
   \   0000A2   A3           INC       DPTR
   \   0000A3   A982         MOV       R1,DPL
   \   0000A5   AA83         MOV       R2,DPH
   \   0000A7   89..         MOV       ?V4,R1
   \   0000A9   8A..         MOV       ?V5,R2
   \   0000AB   78..         MOV       R0,#?V4
   \   0000AD   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000B0   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   0000B3   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B6   E9           MOV       A,R1
   \   0000B7   60D0         JZ        ??bdb_TCAddJoiningDevice_8
    549                {
    550                  //The device added is already in the list, refresh its time and do nothing else
    551                  tempJoiningDescNode->NodeJoinTimeout = bdbAttributes.bdbTrustCenterNodeJoinTimeout;
   \                     ??bdb_TCAddJoiningDevice_7:
   \   0000B9   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000BC   F0           MOVX      @DPTR,A
    552                  return ZSuccess;
   \   0000BD   02....       LJMP      ??bdb_TCAddJoiningDevice_11 & 0xFFFF
    553                }
    554              }
    555              
    556              tempJoiningDescNode->nextDev = osal_mem_alloc(sizeof(bdb_joiningDeviceList_t));
   \                     ??bdb_TCAddJoiningDevice_10:
   \   0000C0                ; Setup parameters for call to function osal_mem_alloc
   \   0000C0   7A0D         MOV       R2,#0xd
   \   0000C2   7B00         MOV       R3,#0x0
   \   0000C4   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000C7   8B..         MOV       ?V5,R3
   \   0000C9   A9..         MOV       R1,?V5
   \   0000CB   12....       LCALL     ??Subroutine64_0 & 0xFFFF
    557              if(tempJoiningDescNode->nextDev == NULL)
   \                     ??CrossCallReturnLabel_133:
   \   0000CE   7004         JNZ       ??bdb_TCAddJoiningDevice_12
    558              {
    559                return ZFailure;
   \                     ??bdb_TCAddJoiningDevice_5:
   \   0000D0   7901         MOV       R1,#0x1
   \   0000D2   807A         SJMP      ??bdb_TCAddJoiningDevice_3
    560              }
    561              
    562              tempJoiningDescNode = tempJoiningDescNode->nextDev;
   \                     ??bdb_TCAddJoiningDevice_12:
   \   0000D4   EA           MOV       A,R2
   \   0000D5   FE           MOV       R6,A
   \   0000D6   EB           MOV       A,R3
   \                     ??bdb_TCAddJoiningDevice_6:
   \   0000D7   FF           MOV       R7,A
   \   0000D8   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
    563            }
   \   0000DB   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   0000DE   6046         JZ        ??bdb_TCAddJoiningDevice_13
    564            
    565            if(pfnTCLinkKeyExchangeProcessCB)
    566            {
    567              bdb_TCLinkKeyExchProcess_t bdb_TCLinkKeyExchProcess;
    568              osal_memcpy(bdb_TCLinkKeyExchProcess.extAddr,tempJoiningDescNode->bdbJoiningNodeEui64, Z_EXTADDR_LEN);
   \   0000E0                ; Setup parameters for call to function osal_memcpy
   \   0000E0   8E82         MOV       DPL,R6
   \   0000E2   8F83         MOV       DPH,R7
   \   0000E4   A3           INC       DPTR
   \   0000E5   A3           INC       DPTR
   \   0000E6   A982         MOV       R1,DPL
   \   0000E8   AA83         MOV       R2,DPH
   \   0000EA   89..         MOV       ?V4,R1
   \   0000EC   8A..         MOV       ?V5,R2
   \   0000EE   75..00       MOV       ?V6,#0x0
   \   0000F1   78..         MOV       R0,#?V4
   \   0000F3   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000F6   7C08         MOV       R4,#0x8
   \   0000F8   7D00         MOV       R5,#0x0
   \   0000FA   7406         MOV       A,#0x6
   \   0000FC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000FF   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000102   12....       LCALL     ?DEALLOC_XSTACK8
    569              bdb_TCLinkKeyExchProcess.status = BDB_TC_LK_EXCH_PROCESS_JOINING;
   \   000105   7402         MOV       A,#0x2
   \   000107   12....       LCALL     ?XSTACK_DISP0_8
   \   00010A   E4           CLR       A
   \   00010B   F0           MOVX      @DPTR,A
    570              
    571              bdb_SendMsg(bdb_TaskID, BDB_TC_LINK_KEY_EXCHANGE_PROCESS, BDB_MSG_EVENT_SUCCESS,sizeof(bdb_TCLinkKeyExchProcess_t),(uint8*)&bdb_TCLinkKeyExchProcess);
   \   00010C                ; Setup parameters for call to function bdb_SendMsg
   \   00010C   7402         MOV       A,#0x2
   \   00010E   12....       LCALL     ?XSTACK_DISP100_8
   \   000111   88..         MOV       ?V4,R0
   \   000113   89..         MOV       ?V5,R1
   \   000115   78..         MOV       R0,#?V4
   \   000117   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00011A   7C09         MOV       R4,#0x9
   \   00011C   7B00         MOV       R3,#0x0
   \   00011E   7A09         MOV       R2,#0x9
   \   000120   12....       LCALL     ??Subroutine50_0 & 0xFFFF
    572            }
   \                     ??CrossCallReturnLabel_73:
   \   000123   12....       LCALL     ?DEALLOC_XSTACK8
    573            
    574            tempJoiningDescNode->nextDev = NULL;
   \                     ??bdb_TCAddJoiningDevice_13:
   \   000126   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000129   E4           CLR       A
   \   00012A   F0           MOVX      @DPTR,A
   \   00012B   A3           INC       DPTR
   \   00012C   F0           MOVX      @DPTR,A
    575            tempJoiningDescNode->NodeJoinTimeout = bdbAttributes.bdbTrustCenterNodeJoinTimeout;
   \   00012D   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000130   12....       LCALL     ??Subroutine51_0 & 0xFFFF
    576            tempJoiningDescNode->parentAddr = parentAddr;
   \                     ??CrossCallReturnLabel_78:
   \   000133   12....       LCALL     ?Subroutine25 & 0xFFFF
    577            osal_memcpy(tempJoiningDescNode->bdbJoiningNodeEui64, JoiningExtAddr, Z_EXTADDR_LEN);
   \                     ??CrossCallReturnLabel_16:
   \   000136                ; Setup parameters for call to function osal_memcpy
   \   000136   78..         MOV       R0,#?V0
   \   000138   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00013B   7C08         MOV       R4,#0x8
   \   00013D   7D00         MOV       R5,#0x0
   \   00013F   EE           MOV       A,R6
   \   000140   2402         ADD       A,#0x2
   \   000142   FA           MOV       R2,A
   \   000143   E4           CLR       A
   \   000144   3F           ADDC      A,R7
   \   000145   FB           MOV       R3,A
   \   000146   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000149   12....       LCALL     ?DEALLOC_XSTACK8
    578            
    579            return ZSuccess;
   \                     ??bdb_TCAddJoiningDevice_11:
   \   00014C   7900         MOV       R1,#0x0
   \                     ??bdb_TCAddJoiningDevice_3:
   \   00014E                REQUIRE ?Subroutine5
   \   00014E                ; // Fall through to label ?Subroutine5
    580          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   740B         MOV       A,#0xb
   \   000002   12....       LCALL     ?DEALLOC_XSTACK8
   \   000005   7F07         MOV       R7,#0x7
   \   000007   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   90....       MOV       DPTR,#bdbAttributes + 16
   \   000003   E0           MOVX      A,@DPTR
   \   000004   8E82         MOV       DPL,R6
   \   000006   8F83         MOV       DPH,R7
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   AA82         MOV       R2,DPL
   \   000002   AB83         MOV       R3,DPH
   \   000004                REQUIRE ??Subroutine46_0
   \   000004                ; // Fall through to label ??Subroutine46_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine46_0:
   \   000000   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000003   7403         MOV       A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   7C08         MOV       R4,#0x8
   \   000002   7D00         MOV       R5,#0x0
   \   000004   A9..         MOV       R1,?V0
   \   000006   AA..         MOV       R2,?V1
   \   000008                REQUIRE ??Subroutine47_0
   \   000008                ; // Fall through to label ??Subroutine47_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine47_0:
   \   000000   AB..         MOV       R3,?V2
   \   000002                REQUIRE ??Subroutine48_0
   \   000002                ; // Fall through to label ??Subroutine48_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine48_0:
   \   000000   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   000003   7403         MOV       A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   EE           MOV       A,R6
   \   000001   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000004   3F           ADDC      A,R7
   \   000005   F583         MOV       DPH,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   240B         ADD       A,#0xb
   \   000002   F582         MOV       DPL,A
   \   000004   E4           CLR       A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   8E82         MOV       DPL,R6
   \   000007   8F83         MOV       DPH,R7
   \   000009   E8           MOV       A,R0
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   A3           INC       DPTR
   \   00000C   E9           MOV       A,R1
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine50_0:
   \   000000   90....       MOV       DPTR,#bdb_TaskID
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   12....       LCALL     `??bdb_SendMsg::?relay`; Banked call to: bdb_SendMsg
   \   000008   7402         MOV       A,#0x2
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine51_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?XSP + 0
   \   000004   85..83       MOV       DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000003                REQUIRE ??Subroutine58_0
   \   000003                ; // Fall through to label ??Subroutine58_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine64_0:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004   EA           MOV       A,R2
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   EB           MOV       A,R3
   \   000008   F0           MOVX      @DPTR,A
   \   000009   EA           MOV       A,R2
   \   00000A   49           ORL       A,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000003                REQUIRE ??Subroutine65_0
   \   000003                ; // Fall through to label ??Subroutine65_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine65_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FE           MOV       R6,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FF           MOV       R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine67_0
   \   000006                ; // Fall through to label ??Subroutine67_0
    581          
    582          /****************************************************************************
    583           * @fn          bdb_TCProcessJoiningList
    584           *
    585           * @brief       Process the timer to handle the joining devices if the TC link 
    586           *              key is mandatory for all devices
    587           *
    588           * @param       none
    589           *
    590           * @return      none
    591           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    592          void bdb_TCProcessJoiningList(void)
   \                     bdb_TCProcessJoiningList:
    593          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 42
   \   000005   74D6         MOV       A,#-0x2a
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    594            bdb_joiningDeviceList_t* tempJoiningDescNode;
    595            
    596            if(bdb_joiningDeviceList)
   \   00000A   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00000D   7003         JNZ       $+5
   \   00000F   02....       LJMP      ??bdb_TCProcessJoiningList_0 & 0xFFFF
    597            {
    598              tempJoiningDescNode = bdb_joiningDeviceList;
   \   000012   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000015   E0           MOVX      A,@DPTR
   \   000016   F5..         MOV       ?V6,A
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F5..         MOV       ?V7,A
    599            
    600              while(tempJoiningDescNode)
    601              {
    602                if(tempJoiningDescNode->NodeJoinTimeout)
   \                     ??bdb_TCProcessJoiningList_1:
   \   00001C   E5..         MOV       A,?V6
   \   00001E   240A         ADD       A,#0xa
   \   000020   F582         MOV       DPL,A
   \   000022   E4           CLR       A
   \   000023   35..         ADDC      A,?V7
   \   000025   F583         MOV       DPH,A
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6007         JZ        ??bdb_TCProcessJoiningList_2
    603                {
    604                  tempJoiningDescNode->NodeJoinTimeout--;
   \   00002A   14           DEC       A
   \   00002B   F0           MOVX      @DPTR,A
    605                }
    606                
    607                if(tempJoiningDescNode->NodeJoinTimeout == 0)
   \   00002C   6003         JZ        $+5
   \   00002E   02....       LJMP      ??bdb_TCProcessJoiningList_3 & 0xFFFF
    608                {
    609                  //Check if the key exchange is required 
    610                  if(bdb_doTrustCenterRequireKeyExchange())
   \                     ??bdb_TCProcessJoiningList_2:
   \   000031   E5..         MOV       A,?V6
   \   000033   2402         ADD       A,#0x2
   \   000035   FE           MOV       R6,A
   \   000036   E4           CLR       A
   \   000037   35..         ADDC      A,?V7
   \   000039   FF           MOV       R7,A
   \   00003A   8E..         MOV       ?V0,R6
   \   00003C   F5..         MOV       ?V1,A
   \   00003E   75..00       MOV       ?V2,#0x0
   \   000041   90....       MOV       DPTR,#bdbAttributes + 17
   \   000044   E0           MOVX      A,@DPTR
   \   000045   6048         JZ        ??bdb_TCProcessJoiningList_4
    611                  {
    612                      AddrMgrEntry_t entry;
    613                      
    614                      entry.user = ADDRMGR_USER_DEFAULT;
   \   000047   740A         MOV       A,#0xa
   \   000049   12....       LCALL     ?XSTACK_DISP0_8
   \   00004C   E4           CLR       A
   \   00004D   F0           MOVX      @DPTR,A
    615                      osal_memcpy(entry.extAddr,tempJoiningDescNode->bdbJoiningNodeEui64, Z_EXTADDR_LEN);
   \   00004E                ; Setup parameters for call to function osal_memcpy
   \   00004E   78..         MOV       R0,#?V0
   \   000050   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000053   7C08         MOV       R4,#0x8
   \   000055   7D00         MOV       R5,#0x0
   \   000057   7410         MOV       A,#0x10
   \   000059   12....       LCALL     ?XSTACK_DISP0_8
   \   00005C   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   00005F   12....       LCALL     ?DEALLOC_XSTACK8
    616                      
    617                      if(AddrMgrEntryLookupExt(&entry))
   \   000062                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000062   740A         MOV       A,#0xa
   \   000064   12....       LCALL     ?XSTACK_DISP101_8
   \   000067   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00006A   E9           MOV       A,R1
   \   00006B   6022         JZ        ??bdb_TCProcessJoiningList_4
    618                      {
    619                        ZDSecMgrAPSRemove(entry.nwkAddr,entry.extAddr,tempJoiningDescNode->parentAddr);
   \   00006D                ; Setup parameters for call to function ZDSecMgrAPSRemove
   \   00006D   85..82       MOV       DPL,?V6
   \   000070   85..83       MOV       DPH,?V7
   \   000073   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000076   740F         MOV       A,#0xf
   \   000078   12....       LCALL     ?XSTACK_DISP0_8
   \   00007B   AC82         MOV       R4,DPL
   \   00007D   AD83         MOV       R5,DPH
   \   00007F   740D         MOV       A,#0xd
   \   000081   12....       LCALL     ?XSTACK_DISP0_8
   \   000084   12....       LCALL     ?Subroutine30 & 0xFFFF
    620                      }
    621                  }
   \                     ??CrossCallReturnLabel_23:
   \   000087   12....       LCALL     `??ZDSecMgrAPSRemove::?relay`; Banked call to: ZDSecMgrAPSRemove
   \   00008A   7402         MOV       A,#0x2
   \   00008C   12....       LCALL     ?DEALLOC_XSTACK8
    622                  
    623                  //Expired device either is legacy device not using the TCLK entry or got 
    624                  //removed from the network because of timeout, eitherway it is not using
    625                  //TCLK entry neither the Security user in the address manager, so free the entry
    626                  //in both tables.
    627                  
    628                  uint16 keyNvIndex;
    629                  uint16 index;        
    630                  APSME_TCLKDevEntry_t TCLKDevEntry;
    631                  uint8 found;
    632                  
    633                  //Remove the entry in address manager
    634                  ZDSecMgrAddrClear(tempJoiningDescNode->bdbJoiningNodeEui64);
   \                     ??bdb_TCProcessJoiningList_4:
   \   00008F                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   00008F   EE           MOV       A,R6
   \   000090   FA           MOV       R2,A
   \   000091   EF           MOV       A,R7
   \   000092   FB           MOV       R3,A
   \   000093   12....       LCALL     `??ZDSecMgrAddrClear::?relay`; Banked call to: ZDSecMgrAddrClear
    635                  
    636                  //search for the entry in the TCLK table
    637                  keyNvIndex = APSME_SearchTCLinkKeyEntry(tempJoiningDescNode->bdbJoiningNodeEui64,&found, NULL);
   \   000096                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   000096   E4           CLR       A
   \   000097   F5..         MOV       ?V4,A
   \   000099   F5..         MOV       ?V5,A
   \   00009B   78..         MOV       R0,#?V4
   \   00009D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A0   7402         MOV       A,#0x2
   \   0000A2   12....       LCALL     ?XSTACK_DISP102_8
   \   0000A5   EE           MOV       A,R6
   \   0000A6   FA           MOV       R2,A
   \   0000A7   EF           MOV       A,R7
   \   0000A8   FB           MOV       R3,A
   \   0000A9   12....       LCALL     `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   0000AC   7402         MOV       A,#0x2
   \   0000AE   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B1   8A..         MOV       ?V4,R2
   \   0000B3   8B..         MOV       ?V5,R3
   \   0000B5   AE..         MOV       R6,?V4
   \   0000B7   AF..         MOV       R7,?V5
    638                  
    639                  //If found, erase it.
    640                  if(found == TRUE)
   \   0000B9   85..82       MOV       DPL,?XSP + 0
   \   0000BC   85..83       MOV       DPH,?XSP + 1
   \   0000BF   E0           MOVX      A,@DPTR
   \   0000C0   6401         XRL       A,#0x1
   \   0000C2   706E         JNZ       ??bdb_TCProcessJoiningList_5
    641                  {
    642                    osal_memset(&TCLKDevEntry,0,sizeof(APSME_TCLKDevEntry_t));
   \   0000C4                ; Setup parameters for call to function osal_memset
   \   0000C4   7C13         MOV       R4,#0x13
   \   0000C6   7D00         MOV       R5,#0x0
   \   0000C8   7900         MOV       R1,#0x0
   \   0000CA   7417         MOV       A,#0x17
   \   0000CC   12....       LCALL     ?XSTACK_DISP101_8
   \   0000CF   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    643                    TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   0000D2   7427         MOV       A,#0x27
   \   0000D4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D7   74FF         MOV       A,#-0x1
   \   0000D9   F0           MOVX      @DPTR,A
    644                    
    645                    //Increase the shift by one. Validate the maximum shift of the seed which is 15
    646                    index = keyNvIndex - ZCD_NV_TCLK_TABLE_START;
   \   0000DA   EE           MOV       A,R6
   \   0000DB   24EF         ADD       A,#-0x11
   \   0000DD   F8           MOV       R0,A
   \   0000DE   EF           MOV       A,R7
   \   0000DF   34FE         ADDC      A,#-0x2
   \   0000E1   F9           MOV       R1,A
    647                    
    648                    TCLinkKeyFrmCntr[index].rxFrmCntr = 0;
   \   0000E2   E8           MOV       A,R0
   \   0000E3   75F009       MOV       B,#0x9
   \   0000E6   A4           MUL       AB
   \   0000E7   F8           MOV       R0,A
   \   0000E8   AAF0         MOV       R2,B
   \   0000EA   75F009       MOV       B,#0x9
   \   0000ED   E9           MOV       A,R1
   \   0000EE   A4           MUL       AB
   \   0000EF   2A           ADD       A,R2
   \   0000F0   F9           MOV       R1,A
   \   0000F1   74..         MOV       A,#TCLinkKeyFrmCntr & 0xff
   \   0000F3   28           ADD       A,R0
   \   0000F4   F8           MOV       R0,A
   \   0000F5   74..         MOV       A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   0000F7   39           ADDC      A,R1
   \   0000F8   F9           MOV       R1,A
   \   0000F9   8882         MOV       DPL,R0
   \   0000FB   F583         MOV       DPH,A
   \   0000FD   A3           INC       DPTR
   \   0000FE   A3           INC       DPTR
   \   0000FF   A3           INC       DPTR
   \   000100   A3           INC       DPTR
   \   000101   12....       LCALL     ?Subroutine10 & 0xFFFF
    649                    TCLinkKeyFrmCntr[index].txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_67:
   \   000104   8882         MOV       DPL,R0
   \   000106   8983         MOV       DPH,R1
   \   000108   12....       LCALL     ??Subroutine49_0 & 0xFFFF
    650                    
    651                    //Update the entry
    652                    osal_nv_write(keyNvIndex,0,sizeof(APSME_TCLKDevEntry_t), &TCLKDevEntry );
   \                     ??CrossCallReturnLabel_65:
   \   00010B                ; Setup parameters for call to function osal_nv_write
   \   00010B   7417         MOV       A,#0x17
   \   00010D   12....       LCALL     ?XSTACK_DISP100_8
   \   000110   88..         MOV       ?V4,R0
   \   000112   89..         MOV       ?V5,R1
   \   000114   78..         MOV       R0,#?V4
   \   000116   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000119   75..13       MOV       ?V4,#0x13
   \   00011C   75..00       MOV       ?V5,#0x0
   \   00011F   78..         MOV       R0,#?V4
   \   000121   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000124   7C00         MOV       R4,#0x0
   \   000126   7D00         MOV       R5,#0x0
   \   000128   EE           MOV       A,R6
   \   000129   FA           MOV       R2,A
   \   00012A   EF           MOV       A,R7
   \   00012B   FB           MOV       R3,A
   \   00012C   12....       LCALL     ??Subroutine62_0 & 0xFFFF
    653                  }
   \                     ??CrossCallReturnLabel_122:
   \   00012F   12....       LCALL     ?DEALLOC_XSTACK8
    654                  
    655                  if(pfnTCLinkKeyExchangeProcessCB)
   \                     ??bdb_TCProcessJoiningList_5:
   \   000132   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
   \   000135   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000138   6035         JZ        ??bdb_TCProcessJoiningList_6
    656                  {
    657                    bdb_TCLinkKeyExchProcess_t bdb_TCLinkKeyExchProcess;
    658                    osal_memcpy(bdb_TCLinkKeyExchProcess.extAddr,tempJoiningDescNode->bdbJoiningNodeEui64, Z_EXTADDR_LEN);
   \   00013A                ; Setup parameters for call to function osal_memcpy
   \   00013A   78..         MOV       R0,#?V0
   \   00013C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00013F   7C08         MOV       R4,#0x8
   \   000141   7D00         MOV       R5,#0x0
   \   000143   7405         MOV       A,#0x5
   \   000145   12....       LCALL     ?XSTACK_DISP0_8
   \   000148   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00014B   12....       LCALL     ?DEALLOC_XSTACK8
    659                    bdb_TCLinkKeyExchProcess.status = BDB_TC_LK_EXCH_PROCESS_EXCH_FAIL;
   \   00014E   7401         MOV       A,#0x1
   \   000150   12....       LCALL     ?XSTACK_DISP0_8
   \   000153   7402         MOV       A,#0x2
   \   000155   F0           MOVX      @DPTR,A
    660                    
    661                    bdb_SendMsg(bdb_TaskID, BDB_TC_LINK_KEY_EXCHANGE_PROCESS, BDB_MSG_EVENT_SUCCESS,sizeof(bdb_TCLinkKeyExchProcess_t),(uint8*)&bdb_TCLinkKeyExchProcess);
   \   000156                ; Setup parameters for call to function bdb_SendMsg
   \   000156   14           DEC       A
   \   000157   12....       LCALL     ?XSTACK_DISP100_8
   \   00015A   88..         MOV       ?V0,R0
   \   00015C   89..         MOV       ?V1,R1
   \   00015E   78..         MOV       R0,#?V0
   \   000160   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000163   7C09         MOV       R4,#0x9
   \   000165   7B00         MOV       R3,#0x0
   \   000167   7A09         MOV       R2,#0x9
   \   000169   12....       LCALL     ??Subroutine50_0 & 0xFFFF
    662                  }
   \                     ??CrossCallReturnLabel_74:
   \   00016C   12....       LCALL     ?DEALLOC_XSTACK8
    663                 
    664                  //Free the device from the list
    665                  bdb_TCJoiningDeviceFree(tempJoiningDescNode);
   \                     ??bdb_TCProcessJoiningList_6:
   \   00016F                ; Setup parameters for call to function bdb_TCJoiningDeviceFree
   \   00016F   AA..         MOV       R2,?V6
   \   000171   AB..         MOV       R3,?V7
   \   000173   12....       LCALL     `??bdb_TCJoiningDeviceFree::?relay`; Banked call to: bdb_TCJoiningDeviceFree
    666                }
    667                tempJoiningDescNode = tempJoiningDescNode->nextDev;
   \                     ??bdb_TCProcessJoiningList_3:
   \   000176   E5..         MOV       A,?V6
   \   000178   12....       LCALL     ?Subroutine42 & 0xFFFF
    668              }
   \                     ??CrossCallReturnLabel_47:
   \   00017B   35..         ADDC      A,?V7
   \   00017D   F583         MOV       DPH,A
   \   00017F   E0           MOVX      A,@DPTR
   \   000180   F5..         MOV       ?V6,A
   \   000182   A3           INC       DPTR
   \   000183   E0           MOVX      A,@DPTR
   \   000184   F5..         MOV       ?V7,A
   \   000186   E5..         MOV       A,?V6
   \   000188   45..         ORL       A,?V7
   \   00018A   6003         JZ        $+5
   \   00018C   02....       LJMP      ??bdb_TCProcessJoiningList_1 & 0xFFFF
    669            }
    670          
    671            //we are done with the list
    672            if(bdb_joiningDeviceList == NULL)
   \   00018F   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000192   7003         JNZ       ??CrossCallReturnLabel_125
    673            {
    674              osal_stop_timerEx(bdb_TaskID,BDB_TC_JOIN_TIMEOUT);
   \                     ??bdb_TCProcessJoiningList_0:
   \   000194                ; Setup parameters for call to function osal_stop_timerEx
   \   000194   12....       LCALL     ?Subroutine26 & 0xFFFF
    675            }
    676          }
   \                     ??CrossCallReturnLabel_125:
   \   000197   742A         MOV       A,#0x2a
   \   000199   02....       LJMP      ?Subroutine6 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E4           CLR       A
   \   000001                REQUIRE ??Subroutine49_0
   \   000001                ; // Fall through to label ??Subroutine49_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine49_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   F0           MOVX      @DPTR,A
   \   000003   A3           INC       DPTR
   \   000004   F0           MOVX      @DPTR,A
   \   000005   A3           INC       DPTR
   \   000006   F0           MOVX      @DPTR,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine62_0:
   \   000000   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000003   7404         MOV       A,#0x4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   7A00         MOV       R2,#0x0
   \   000002   7B08         MOV       R3,#0x8
   \   000004                REQUIRE ??Subroutine63_0
   \   000004                ; // Fall through to label ??Subroutine63_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F08         MOV       R7,#0x8
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA
    677          
    678          
    679          
    680          /****************************************************************************
    681           * @fn          bdb_TCjoiningDeviceComplete
    682           *
    683           * @brief       This function frees a joining device from the list that has 
    684           *              finished TC link key exchange process
    685           *
    686           * @param       JoiningExtAddr - Extended address of the device
    687           *
    688           * @return      none
    689           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    690          void bdb_TCjoiningDeviceComplete(uint8* JoiningExtAddr)
   \                     bdb_TCjoiningDeviceComplete:
    691          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV       A,#-0xb
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine12 & 0xFFFF
    692            bdb_joiningDeviceList_t* tempJoiningDescNode;
    693            
    694            if((bdb_joiningDeviceList != NULL) && (JoiningExtAddr != NULL))
   \                     ??CrossCallReturnLabel_148:
   \   00000D   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000010   7003         JNZ       $+5
   \   000012   02....       LJMP      ??CrossCallReturnLabel_126 & 0xFFFF
   \   000015   85..82       MOV       DPL,?XSP + 0
   \   000018   85..83       MOV       DPH,?XSP + 1
   \   00001B   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   00001E   7003         JNZ       $+5
   \   000020   02....       LJMP      ??CrossCallReturnLabel_126 & 0xFFFF
    695            {
    696              tempJoiningDescNode = bdb_joiningDeviceList;
   \   000023   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000026   8E82         MOV       DPL,R6
   \   000028   8F83         MOV       DPH,R7
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A982         MOV       R1,DPL
   \   00002E   AA83         MOV       R2,DPH
   \   000030   89..         MOV       ?V0,R1
   \   000032   8A..         MOV       ?V1,R2
   \   000034   75..00       MOV       ?V2,#0x0
   \   000037                ; Setup parameters for call to function osal_memcmp
   \   000037   85..82       MOV       DPL,?XSP + 0
   \   00003A   85..83       MOV       DPH,?XSP + 1
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   F5..         MOV       ?V4,A
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   F5..         MOV       ?V5,A
   \   000044   75..00       MOV       ?V6,#0x0
   \   000047   78..         MOV       R0,#?V4
   \   000049   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00004C   7C08         MOV       R4,#0x8
   \   00004E   7D00         MOV       R5,#0x0
   \   000050   12....       LCALL     ??Subroutine47_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000053   12....       LCALL     ?DEALLOC_XSTACK8
   \   000056   E9           MOV       A,R1
   \   000057   6046         JZ        ??bdb_TCjoiningDeviceComplete_0
    697              
    698              while(tempJoiningDescNode != NULL)
    699              {
    700                if(osal_memcmp(tempJoiningDescNode->bdbJoiningNodeEui64,JoiningExtAddr,Z_EXTADDR_LEN))
    701                {
    702                  if(pfnTCLinkKeyExchangeProcessCB)
   \   000059   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
   \   00005C   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00005F   6035         JZ        ??bdb_TCjoiningDeviceComplete_1
    703                  {
    704                    bdb_TCLinkKeyExchProcess_t bdb_TCLinkKeyExchProcess;
    705                    osal_memcpy(bdb_TCLinkKeyExchProcess.extAddr,tempJoiningDescNode->bdbJoiningNodeEui64, Z_EXTADDR_LEN);
   \   000061                ; Setup parameters for call to function osal_memcpy
   \   000061   78..         MOV       R0,#?V0
   \   000063   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000066   7C08         MOV       R4,#0x8
   \   000068   7D00         MOV       R5,#0x0
   \   00006A   7406         MOV       A,#0x6
   \   00006C   12....       LCALL     ?XSTACK_DISP0_8
   \   00006F   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000072   12....       LCALL     ?DEALLOC_XSTACK8
    706                    bdb_TCLinkKeyExchProcess.status = BDB_TC_LK_EXCH_PROCESS_EXCH_SUCCESS;
   \   000075   7402         MOV       A,#0x2
   \   000077   12....       LCALL     ?XSTACK_DISP0_8
   \   00007A   7401         MOV       A,#0x1
   \   00007C   F0           MOVX      @DPTR,A
    707                    
    708                    bdb_SendMsg(bdb_TaskID, BDB_TC_LINK_KEY_EXCHANGE_PROCESS, BDB_MSG_EVENT_SUCCESS,sizeof(bdb_TCLinkKeyExchProcess_t),(uint8*)&bdb_TCLinkKeyExchProcess);
   \   00007D                ; Setup parameters for call to function bdb_SendMsg
   \   00007D   04           INC       A
   \   00007E   12....       LCALL     ?XSTACK_DISP100_8
   \   000081   88..         MOV       ?V0,R0
   \   000083   89..         MOV       ?V1,R1
   \   000085   78..         MOV       R0,#?V0
   \   000087   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008A   7C09         MOV       R4,#0x9
   \   00008C   7B00         MOV       R3,#0x0
   \   00008E   7A09         MOV       R2,#0x9
   \   000090   12....       LCALL     ??Subroutine50_0 & 0xFFFF
    709                  }        
   \                     ??CrossCallReturnLabel_75:
   \   000093   12....       LCALL     ?DEALLOC_XSTACK8
    710                  
    711                  bdb_TCJoiningDeviceFree(tempJoiningDescNode);
   \                     ??bdb_TCjoiningDeviceComplete_1:
   \   000096                ; Setup parameters for call to function bdb_TCJoiningDeviceFree
   \   000096   EE           MOV       A,R6
   \   000097   FA           MOV       R2,A
   \   000098   EF           MOV       A,R7
   \   000099   FB           MOV       R3,A
   \   00009A   12....       LCALL     `??bdb_TCJoiningDeviceFree::?relay`; Banked call to: bdb_TCJoiningDeviceFree
    712                  break;
   \   00009D   800D         SJMP      ??bdb_TCjoiningDeviceComplete_2
    713                }
    714                tempJoiningDescNode = tempJoiningDescNode->nextDev;
   \                     ??bdb_TCjoiningDeviceComplete_0:
   \   00009F   12....       LCALL     ?Subroutine37 & 0xFFFF
    715              }
   \                     ??CrossCallReturnLabel_42:
   \   0000A2   12....       LCALL     ??Subroutine65_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000A5   EE           MOV       A,R6
   \   0000A6   4F           ORL       A,R7
   \   0000A7   6003         JZ        $+5
   \   0000A9   02....       LJMP      ??CrossCallReturnLabel_137 & 0xFFFF
    716             
    717              if(bdb_joiningDeviceList == NULL)
   \                     ??bdb_TCjoiningDeviceComplete_2:
   \   0000AC   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   0000AF   7003         JNZ       ??CrossCallReturnLabel_126
    718              {
    719                osal_stop_timerEx(bdb_TaskID,BDB_TC_JOIN_TIMEOUT);
   \   0000B1                ; Setup parameters for call to function osal_stop_timerEx
   \   0000B1   12....       LCALL     ?Subroutine26 & 0xFFFF
    720              }
    721            }
    722          }
   \                     ??CrossCallReturnLabel_126:
   \   0000B4   02....       LJMP      ?Subroutine5 & 0xFFFF
    723          
    724          
    725          
    726          /****************************************************************************
    727           * @fn          bdb_TCJoiningDeviceFree
    728           *
    729           * @brief       This function frees a joining device from the list.
    730           *
    731           * @param       ZSuccess - If the device was found and erased
    732           * @param       ZInvalidParameter - Not found
    733           *
    734           * @return      none
    735           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    736          ZStatus_t bdb_TCJoiningDeviceFree(bdb_joiningDeviceList_t* JoiningDeviceToRemove)
   \                     bdb_TCJoiningDeviceFree:
    737          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V4,R2
   \   000007   8B..         MOV       ?V5,R3
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A982         MOV       R1,DPL
   \   000011   AA83         MOV       R2,DPH
   \   000013   89..         MOV       ?V0,R1
   \   000015   8A..         MOV       ?V1,R2
   \   000017   75..00       MOV       ?V2,#0x0
   \   00001A                ; Setup parameters for call to function osal_memcmp
   \   00001A   78..         MOV       R0,#?V0
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00001F   7C08         MOV       R4,#0x8
   \   000021   7D00         MOV       R5,#0x0
   \   000023   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000026   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000029   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002C   E9           MOV       A,R1
   \   00002D   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000030   601B         JZ        ??bdb_TCJoiningDeviceFree_0
    738            bdb_joiningDeviceList_t* descCurrent;
    739            bdb_joiningDeviceList_t* descPrev;
    740            
    741            //validate empty list?
    742            
    743            //Is it the first?
    744            if(osal_memcmp(bdb_joiningDeviceList->bdbJoiningNodeEui64, JoiningDeviceToRemove->bdbJoiningNodeEui64, Z_EXTADDR_LEN))
    745            {
    746              descCurrent = bdb_joiningDeviceList;
   \   000032   12....       LCALL     ?Subroutine30 & 0xFFFF
    747              bdb_joiningDeviceList = bdb_joiningDeviceList->nextDev;
   \                     ??CrossCallReturnLabel_24:
   \   000035   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000038   E0           MOVX      A,@DPTR
   \   000039   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   00003C   3B           ADDC      A,R3
   \   00003D   F583         MOV       DPH,A
   \   00003F   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000042   F9           MOV       R1,A
   \   000043   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000046   E8           MOV       A,R0
   \   000047   F0           MOVX      @DPTR,A
   \   000048   A3           INC       DPTR
   \   000049   E9           MOV       A,R1
   \   00004A   F0           MOVX      @DPTR,A
    748              osal_mem_free( descCurrent );
   \   00004B                ; Setup parameters for call to function osal_mem_free
   \   00004B   8037         SJMP      ??bdb_TCJoiningDeviceFree_1
    749              return ZSuccess;
    750            }
    751            
    752            descPrev = NULL;
    753            descCurrent = bdb_joiningDeviceList;
    754            
    755            while(descCurrent != NULL)
    756            {
    757              if(osal_memcmp(descCurrent->nextDev->bdbJoiningNodeEui64, JoiningDeviceToRemove->bdbJoiningNodeEui64, Z_EXTADDR_LEN))
    758              {
    759                descPrev = descCurrent;
    760                break;
    761              }
    762              descCurrent = descCurrent->nextDev;
   \                     ??bdb_TCJoiningDeviceFree_0:
   \   00004D   12....       LCALL     ??Subroutine66_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000050   6039         JZ        ??bdb_TCJoiningDeviceFree_2
   \   000052   EA           MOV       A,R2
   \   000053   240B         ADD       A,#0xb
   \   000055   FE           MOV       R6,A
   \   000056   E4           CLR       A
   \   000057   3B           ADDC      A,R3
   \   000058   FF           MOV       R7,A
   \   000059                ; Setup parameters for call to function osal_memcmp
   \   000059   78..         MOV       R0,#?V0
   \   00005B   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00005E   7C08         MOV       R4,#0x8
   \   000060   7D00         MOV       R5,#0x0
   \   000062   8E82         MOV       DPL,R6
   \   000064   8F83         MOV       DPH,R7
   \   000066   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000069   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006C   E9           MOV       A,R1
   \   00006D   8E82         MOV       DPL,R6
   \   00006F   8F83         MOV       DPH,R7
   \   000071   60DA         JZ        ??bdb_TCJoiningDeviceFree_0
    763            }
    764            if(descPrev == NULL)
    765            {
    766              //Not found
    767              return ZInvalidParameter;
    768            }
    769            
    770            descPrev->nextDev = descPrev->nextDev->nextDev;
   \   000073   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000076   C8           XCH       A,R0
   \   000077   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00007A   38           ADDC      A,R0
   \   00007B   F583         MOV       DPH,A
   \   00007D   12....       LCALL     ?Subroutine25 & 0xFFFF
    771              
    772            osal_mem_free( JoiningDeviceToRemove );
   \                     ??CrossCallReturnLabel_17:
   \   000080                ; Setup parameters for call to function osal_mem_free
   \   000080   AA..         MOV       R2,?V4
   \   000082   AB..         MOV       R3,?V5
   \                     ??bdb_TCJoiningDeviceFree_1:
   \   000084   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    773            return ZSuccess;
   \   000087   7900         MOV       R1,#0x0
   \   000089   8002         SJMP      ??bdb_TCJoiningDeviceFree_3
   \                     ??bdb_TCJoiningDeviceFree_2:
   \   00008B   7902         MOV       R1,#0x2
   \                     ??bdb_TCJoiningDeviceFree_3:
   \   00008D   02....       LJMP      ?Subroutine3 & 0xFFFF
    774          
    775          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000003   A982         MOV       R1,DPL
   \   000005   AA83         MOV       R2,DPH
   \   000007   7B00         MOV       R3,#0x0
   \   000009   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine66_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   22           RET
    776          
    777           /*********************************************************************
    778           * @fn          bdb_setJoinUsesInstallCodeKey
    779           *
    780           * @brief       Set BDB attribute bdbJoinUsesInstallCodeKey.
    781           *
    782           * @param       set - If TRUE only devices with IC register in TC can join the 
    783           *              nwk, otherwise devices may or not have a IC register
    784           *
    785           * @return      none
    786           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    787          void bdb_setJoinUsesInstallCodeKey(bool set)
   \                     bdb_setJoinUsesInstallCodeKey:
    788          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    789            bdbAttributes.bdbJoinUsesInstallCodeKey = set;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#bdbAttributes + 15
   \   000008   F0           MOVX      @DPTR,A
    790            if(set)
   \   000009   90....       MOV       DPTR,#zgAllowInstallCodes
   \   00000C   6004         JZ        ??bdb_setJoinUsesInstallCodeKey_0
    791            {
    792              zgAllowInstallCodes = ZG_IC_MUST_USED;
   \   00000E   7402         MOV       A,#0x2
   \   000010   8002         SJMP      ??bdb_setJoinUsesInstallCodeKey_1
    793            }
    794            else
    795            {
    796              zgAllowInstallCodes = ZG_IC_SUPPORTED_NOT_REQUIRED;
   \                     ??bdb_setJoinUsesInstallCodeKey_0:
   \   000012   7401         MOV       A,#0x1
    797            }
   \                     ??bdb_setJoinUsesInstallCodeKey_1:
   \   000014   02....       LJMP      ??Subroutine52_0 & 0xFFFF
    798          }
    799          #endif
    800          
    801           /*********************************************************************
    802           * @fn          bdb_StartCommissioning
    803           *
    804           * @brief       Start the commissioning process setting the commissioning mode given.
    805           *
    806           * @param       mode - refer to bdbCommissioningMode
    807           *
    808           * @return      none
    809           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    810          void bdb_StartCommissioning(uint8 mode)
   \                     bdb_StartCommissioning:
    811          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
    812            //Application cannot request to set the device in initialization mode or parent lost
    813            mode &= ~(BDB_COMMISSIONING_MODE_INITIALIZATION | BDB_COMMISSIONING_MODE_PARENT_LOST);
    814              
    815          #ifdef BDB_TL_INITIATOR
    816            if ( touchlinkFNReset == TRUE )
    817            {
    818              return;
    819            }
    820          #else
    821            //Commissioning mode used only for initiator
    822            mode &= ~BDB_COMMISSIONING_MODE_INITIATOR_TL;
   \   00000C   53..CE       ANL       ?V0,#0xce
    823          #endif
    824            
    825          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==0)    
    826            //Commissioning mode used only for devices with F&B
    827            mode &= ~BDB_COMMISSIONING_MODE_FINDING_BINDING;
    828          #endif
    829           
    830            //If we have running process or the machine state is triggered, then just append and it will be excecuted
    831            if((bdbAttributes.bdbCommissioningMode) || (osal_get_timeoutEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE)))
   \   00000F   90....       MOV       DPTR,#bdbAttributes + 11
   \   000012   E0           MOVX      A,@DPTR
   \   000013   7009         JNZ       ??bdb_StartCommissioning_0
   \   000015                ; Setup parameters for call to function osal_get_timeoutEx
   \   000015   7A04         MOV       R2,#0x4
   \   000017   7B00         MOV       R3,#0x0
   \   000019   12....       LCALL     ??Subroutine54_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00001C   6020         JZ        ??bdb_StartCommissioning_1
    832            {
    833          #if ZG_BUILD_ENDDEVICE_TYPE
    834              if(ZG_DEVICE_ENDDEVICE_TYPE)
    835              {
    836                //Devices with parent lost are not allowed to perform actions
    837                if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_PARENT_LOST)
    838                {
    839                  return;
    840                }
    841              }
    842          #endif
    843              
    844              //If we are on the network and got requested to do nwk steering, we do not need to wait other process, 
    845              // just send permit joining and report the application
    846              if((bdbAttributes.bdbNodeIsOnANetwork) && (mode & BDB_COMMISSIONING_MODE_NWK_STEERING))
   \                     ??bdb_StartCommissioning_0:
   \   00001E   90....       MOV       DPTR,#bdbAttributes + 14
   \   000021   E0           MOVX      A,@DPTR
   \   000022   600C         JZ        ??bdb_StartCommissioning_2
   \   000024   E5..         MOV       A,?V0
   \   000026   A2E1         MOV       C,0xE0 /* A   */.1
   \   000028   5006         JNC       ??bdb_StartCommissioning_2
    847              {
    848                bdb_nwkSteeringDeviceOnNwk();
   \   00002A                ; Setup parameters for call to function bdb_nwkSteeringDeviceOnNwk
   \   00002A   12....       LCALL     ?Subroutine34 & 0xFFFF
    849                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_STEERING_ON_NWK, TRUE);
    850                
    851                //Clean nwk steering
    852                mode ^= BDB_COMMISSIONING_MODE_NWK_STEERING; 
   \                     ??CrossCallReturnLabel_38:
   \   00002D   63..02       XRL       ?V0,#0x2
    853              }
    854              
    855              //add the remaining valid commissioning modes requested, those will be process when bdb finish its current process
    856              bdbAttributes.bdbCommissioningMode |= mode & BDB_COMMISSIONING_MODES;
   \                     ??bdb_StartCommissioning_2:
   \   000030   743F         MOV       A,#0x3f
   \   000032   55..         ANL       A,?V0
   \   000034   F8           MOV       R0,A
   \   000035   90....       MOV       DPTR,#bdbAttributes + 11
   \   000038   E0           MOVX      A,@DPTR
   \   000039   48           ORL       A,R0
   \   00003A   F0           MOVX      @DPTR,A
    857              return;      
   \   00003B   02....       LJMP      ??bdb_StartCommissioning_3 & 0xFFFF
    858            }
    859          
    860            //Save the commissioning modes valid requested
    861            bdbAttributes.bdbCommissioningMode |= mode & BDB_COMMISSIONING_MODES;
   \                     ??bdb_StartCommissioning_1:
   \   00003E   743F         MOV       A,#0x3f
   \   000040   55..         ANL       A,?V0
   \   000042   FE           MOV       R6,A
   \   000043   90....       MOV       DPTR,#bdbAttributes + 11
   \   000046   E0           MOVX      A,@DPTR
   \   000047   4E           ORL       A,R6
   \   000048   F0           MOVX      @DPTR,A
    862            
    863            
    864            //Start processing the initialization, once per power cycle.
    865            if(!bdb_initialization)
   \   000049   90....       MOV       DPTR,#bdb_initialization
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   6003         JZ        $+5
   \   00004F   02....       LJMP      ??bdb_StartCommissioning_4 & 0xFFFF
    866            {
    867              bdb_initialization = TRUE;
   \   000052   7401         MOV       A,#0x1
   \   000054   12....       LCALL     ?Subroutine15 & 0xFFFF
    868              
    869          #ifdef BDB_REPORTING
    870              //Delete NV data if startup was with factory reset
    871              if(ZDO_INITDEV_NEW_NETWORK_STATE == ZDApp_ReadNetworkRestoreState())
    872              {
    873                //Factory reset bdb reporting NV data
    874                uint16 attrRepNvLen = osal_nv_item_len( ZCD_NV_BDBREPORTINGCONFIG );
    875                if ( attrRepNvLen > 0 )
    876                {
    877                  osal_nv_delete( ZCD_NV_BDBREPORTINGCONFIG, attrRepNvLen );
    878                }
    879              }
    880          
    881              //Construct the Endpoint-cluster array
    882              bdb_RepConstructReportingData();
    883          #endif //BDB_REPORTING
    884              
    885              osal_nv_read(ZCD_NV_BDBNODEISONANETWORK,0,sizeof(bdbAttributes.bdbNodeIsOnANetwork),&bdbAttributes.bdbNodeIsOnANetwork);
   \                     ??CrossCallReturnLabel_6:
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005A   75..01       MOV       ?V2,#0x1
   \   00005D   75..00       MOV       ?V3,#0x0
   \   000060   78..         MOV       R0,#?V2
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000065   7C00         MOV       R4,#0x0
   \   000067   7D00         MOV       R5,#0x0
   \   000069   7A55         MOV       R2,#0x55
   \   00006B   7B00         MOV       R3,#0x0
   \   00006D   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000070   7404         MOV       A,#0x4
   \   000072   12....       LCALL     ?DEALLOC_XSTACK8
    886              
    887              //Are we on a network
    888              if(bdbAttributes.bdbNodeIsOnANetwork == TRUE)
   \   000075   90....       MOV       DPTR,#bdbAttributes + 14
   \   000078   E0           MOVX      A,@DPTR
   \   000079   6401         XRL       A,#0x1
   \   00007B   6003         JZ        $+5
   \   00007D   02....       LJMP      ??bdb_StartCommissioning_4 & 0xFFFF
    889              {
    890          #ifdef ZG_BUILD_JOINING_TYPE
    891                //Only for joining devices validate the joining procedure
    892                if(ZG_DEVICE_JOINING_TYPE)
   \   000080   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000083   E0           MOVX      A,@DPTR
   \   000084   6401         XRL       A,#0x1
   \   000086   6008         JZ        ??bdb_StartCommissioning_5
   \   000088   E0           MOVX      A,@DPTR
   \   000089   6402         XRL       A,#0x2
   \   00008B   6003         JZ        $+5
   \   00008D   02....       LJMP      ??bdb_StartCommissioning_6 & 0xFFFF
    893                {
    894                  //If we got into a network
    895                  if(!osal_isbufset( AIB_apsTrustCenterAddress, 0x00, Z_EXTADDR_LEN ))
   \                     ??bdb_StartCommissioning_5:
   \   000090                ; Setup parameters for call to function osal_isbufset
   \   000090   7C08         MOV       R4,#0x8
   \   000092   7900         MOV       R1,#0x0
   \   000094   90....       MOV       DPTR,#AIB_apsTrustCenterAddress
   \   000097   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   00009A   12....       LCALL     `??osal_isbufset::?relay`; Banked call to: osal_isbufset
   \   00009D   E9           MOV       A,R1
   \   00009E   6003         JZ        $+5
   \   0000A0   02....       LJMP      ??bdb_StartCommissioning_6 & 0xFFFF
    896                  {
    897                    //Which is not distributed
    898                    if(!APSME_IsDistributedSecurity())
   \   0000A3                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   0000A3   12....       LCALL     `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   0000A6   E9           MOV       A,R1
   \   0000A7   6003         JZ        $+5
   \   0000A9   02....       LJMP      ??bdb_StartCommissioning_6 & 0xFFFF
    899                    {
    900                      uint8 keyAttributes;
    901                      osal_nv_read(ZCD_NV_TCLK_TABLE_START, osal_offsetof(APSME_TCLKDevEntry_t,keyAttributes), sizeof(uint8), &keyAttributes);
   \   0000AC                ; Setup parameters for call to function osal_nv_read
   \   0000AC   A8..         MOV       R0,?XSP + 0
   \   0000AE   A9..         MOV       R1,?XSP + 1
   \   0000B0   88..         MOV       ?V2,R0
   \   0000B2   89..         MOV       ?V3,R1
   \   0000B4   78..         MOV       R0,#?V2
   \   0000B6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B9   75..01       MOV       ?V2,#0x1
   \   0000BC   75..00       MOV       ?V3,#0x0
   \   0000BF   78..         MOV       R0,#?V2
   \   0000C1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C4   7C10         MOV       R4,#0x10
   \   0000C6   7D00         MOV       R5,#0x0
   \   0000C8   7A11         MOV       R2,#0x11
   \   0000CA   7B01         MOV       R3,#0x1
   \   0000CC   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000CF   7404         MOV       A,#0x4
   \   0000D1   12....       LCALL     ?DEALLOC_XSTACK8
    902                      //If we must perform the TCLK exchange and we didn't complete it, then reset to FN
    903                      if(requestNewTrustCenterLinkKey && (keyAttributes != ZG_NON_R21_NWK_JOINED) && (keyAttributes != ZG_VERIFIED_KEY))
   \   0000D4   90....       MOV       DPTR,#requestNewTrustCenterLinkKey
   \   0000D7   E0           MOVX      A,@DPTR
   \   0000D8   607A         JZ        ??bdb_StartCommissioning_6
   \   0000DA   85..82       MOV       DPL,?XSP + 0
   \   0000DD   85..83       MOV       DPH,?XSP + 1
   \   0000E0   E0           MOVX      A,@DPTR
   \   0000E1   64FD         XRL       A,#0xfd
   \   0000E3   606F         JZ        ??bdb_StartCommissioning_6
   \   0000E5   E0           MOVX      A,@DPTR
   \   0000E6   6402         XRL       A,#0x2
   \   0000E8   606A         JZ        ??bdb_StartCommissioning_6
    904                      {
    905                        //Force to initialize the entry
    906                        APSME_TCLKDevEntry_t APSME_TCLKDevEntry;
    907                        
    908                        osal_memset(&APSME_TCLKDevEntry,0,sizeof(APSME_TCLKDevEntry_t));
   \   0000EA                ; Setup parameters for call to function osal_memset
   \   0000EA   7C13         MOV       R4,#0x13
   \   0000EC   7D00         MOV       R5,#0x0
   \   0000EE   7900         MOV       R1,#0x0
   \   0000F0   7401         MOV       A,#0x1
   \   0000F2   12....       LCALL     ?XSTACK_DISP101_8
   \   0000F5   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    909                        APSME_TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   0000F8   7411         MOV       A,#0x11
   \   0000FA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000FD   74FF         MOV       A,#-0x1
   \   0000FF   F0           MOVX      @DPTR,A
    910                        osal_nv_write(ZCD_NV_TCLK_TABLE_START, 0, sizeof(APSME_TCLKDevEntry_t), &APSME_TCLKDevEntry);
   \   000100                ; Setup parameters for call to function osal_nv_write
   \   000100   7401         MOV       A,#0x1
   \   000102   12....       LCALL     ?XSTACK_DISP100_8
   \   000105   88..         MOV       ?V2,R0
   \   000107   89..         MOV       ?V3,R1
   \   000109   78..         MOV       R0,#?V2
   \   00010B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00010E   75..13       MOV       ?V2,#0x13
   \   000111   75..00       MOV       ?V3,#0x0
   \   000114   78..         MOV       R0,#?V2
   \   000116   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000119   7C00         MOV       R4,#0x0
   \   00011B   7D00         MOV       R5,#0x0
   \   00011D   7A11         MOV       R2,#0x11
   \   00011F   7B01         MOV       R3,#0x1
   \   000121   12....       LCALL     ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000124   12....       LCALL     ?DEALLOC_XSTACK8
    911                        TCLinkKeyFrmCntr[0].txFrmCntr = 0;
   \   000127   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   00012A   12....       LCALL     ?Subroutine10 & 0xFFFF
    912                        TCLinkKeyFrmCntr[0].rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_68:
   \   00012D   A3           INC       DPTR
   \   00012E   12....       LCALL     ??Subroutine49_0 & 0xFFFF
    913                        
    914                        
    915                        //reset the device parameters to FN
    916                        bdbAttributes.bdbNodeIsOnANetwork = FALSE;
   \                     ??CrossCallReturnLabel_66:
   \   000131   90....       MOV       DPTR,#bdbAttributes + 14
   \   000134   12....       LCALL     ?Subroutine15 & 0xFFFF
    917                        osal_nv_write(ZCD_NV_BDBNODEISONANETWORK,0,sizeof(bdbAttributes.bdbNodeIsOnANetwork),&bdbAttributes.bdbNodeIsOnANetwork);
   \                     ??CrossCallReturnLabel_7:
   \   000137   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00013A   75..01       MOV       ?V2,#0x1
   \   00013D   75..00       MOV       ?V3,#0x0
   \   000140   78..         MOV       R0,#?V2
   \   000142   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000145   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000148   12....       LCALL     ?DEALLOC_XSTACK8
    918                        zgWriteStartupOptions(ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_CONFIG_STATE | ZCD_STARTOPT_DEFAULT_NETWORK_STATE);
   \   00014B                ; Setup parameters for call to function zgWriteStartupOptions
   \   00014B   7A03         MOV       R2,#0x3
   \   00014D   79FF         MOV       R1,#-0x1
   \   00014F   12....       LCALL     `??zgWriteStartupOptions::?relay`; Banked call to: zgWriteStartupOptions
    919                        
    920                        //Then start the commissioning process requested
    921                        bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   000152   803B         SJMP      ??bdb_StartCommissioning_7
    922                        osal_set_event( bdb_TaskID, BDB_CHANGE_COMMISSIONING_STATE );
    923                        return;
    924                      }
    925                    }
    926                  }
    927                }
    928          #endif //ZG_BUILD_JOINING_TYPE
    929                
    930                //Set the initialization
    931                bdbAttributes.bdbCommissioningMode |= BDB_COMMISSIONING_MODE_INITIALIZATION;
    932                bdbCommissioningProcedureState.bdbCommissioningState = BDB_INITIALIZATION;
   \                     ??bdb_StartCommissioning_6:
   \   000154   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000157   7407         MOV       A,#0x7
   \   000159   F0           MOVX      @DPTR,A
    933                bdbAttributes.bdbCommissioningMode |= mode & BDB_COMMISSIONING_MODES;
   \   00015A   7410         MOV       A,#0x10
   \   00015C   4E           ORL       A,R6
   \   00015D   F8           MOV       R0,A
   \   00015E   90....       MOV       DPTR,#bdbAttributes + 11
   \   000161   E0           MOVX      A,@DPTR
   \   000162   48           ORL       A,R0
   \   000163   F0           MOVX      @DPTR,A
    934                
    935                if(ZDOInitDevice(0) == ZDO_INITDEV_RESTORED_NETWORK_STATE)
   \   000164                ; Setup parameters for call to function ZDOInitDeviceEx
   \   000164   7900         MOV       R1,#0x0
   \   000166   7A00         MOV       R2,#0x0
   \   000168   7B00         MOV       R3,#0x0
   \   00016A   12....       LCALL     `??ZDOInitDeviceEx::?relay`; Banked call to: ZDOInitDeviceEx
   \   00016D   E9           MOV       A,R1
   \   00016E   602F         JZ        ??bdb_StartCommissioning_3
    936                {
    937          #ifdef BDB_REPORTING
    938                  //Mark the clusterEndpoint entries that have binding, starts reporting if at least one entry was marked
    939                  bdb_RepUpdateMarkBindings();
    940          #endif
    941                  return;
    942                }
    943                bdb_setNodeIsOnANetwork(FALSE);  
   \   000170                ; Setup parameters for call to function bdb_setNodeIsOnANetwork
   \   000170   7900         MOV       R1,#0x0
   \   000172   12....       LCALL     `??bdb_setNodeIsOnANetwork::?relay`; Banked call to: bdb_setNodeIsOnANetwork
    944                //Not in the network
    945                bdb_reportCommissioningState(BDB_INITIALIZATION,FALSE);
   \   000175                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000175   7A00         MOV       R2,#0x0
   \   000177   7907         MOV       R1,#0x7
   \   000179   800F         SJMP      ??bdb_StartCommissioning_8
    946                return;
    947              }
    948            }
    949          
    950            //Got requested only to initialize, if so, report that it failed
    951            if(bdbAttributes.bdbCommissioningMode == 0)
   \                     ??bdb_StartCommissioning_4:
   \   00017B   90....       MOV       DPTR,#bdbAttributes + 11
   \   00017E   E0           MOVX      A,@DPTR
   \   00017F   700E         JNZ       ??bdb_StartCommissioning_7
    952            {
    953              //Set the initialization state and report it to fail
    954              bdbCommissioningProcedureState.bdbCommissioningState = BDB_INITIALIZATION;
   \   000181   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000184   7407         MOV       A,#0x7
   \   000186   F0           MOVX      @DPTR,A
    955              bdb_reportCommissioningState(BDB_INITIALIZATION,FALSE);
   \   000187                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000187   7A00         MOV       R2,#0x0
   \   000189   F9           MOV       R1,A
   \                     ??bdb_StartCommissioning_8:
   \   00018A   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
    956              return;
   \   00018D   8010         SJMP      ??bdb_StartCommissioning_3
    957            }
    958          
    959            
    960            //Start the commissioning process
    961            bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \                     ??bdb_StartCommissioning_7:
   \   00018F   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000192   E4           CLR       A
   \   000193   F0           MOVX      @DPTR,A
    962            osal_set_event( bdb_TaskID, BDB_CHANGE_COMMISSIONING_STATE );
   \   000194                ; Setup parameters for call to function osal_set_event
   \   000194   7A04         MOV       R2,#0x4
   \   000196   FB           MOV       R3,A
   \   000197   90....       MOV       DPTR,#bdb_TaskID
   \   00019A   E0           MOVX      A,@DPTR
   \   00019B   F9           MOV       R1,A
   \   00019C   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    963          }
   \                     ??bdb_StartCommissioning_3:
   \   00019F   7414         MOV       A,#0x14
   \   0001A1   02....       LJMP      ??Subroutine56_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function osal_nv_read
   \   000001                ; Setup parameters for call to function osal_nv_write
   \   000001   75....       MOV       ?V2,#(bdbAttributes + 14) & 0xff
   \   000004   75....       MOV       ?V3,#((bdbAttributes + 14) >> 8) & 0xff
   \   000007   78..         MOV       R0,#?V2
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine54_0:
   \   000000   90....       MOV       DPTR,#bdb_TaskID
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   12....       LCALL     `??osal_get_timeoutEx::?relay`; Banked call to: osal_get_timeoutEx
   \   000008   EA           MOV       A,R2
   \   000009   4B           ORL       A,R3
   \   00000A   4C           ORL       A,R4
   \   00000B   4D           ORL       A,R5
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL     `??bdb_nwkSteeringDeviceOnNwk::?relay`; Banked call to: bdb_nwkSteeringDeviceOnNwk
   \   000003                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000003                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000003                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000003   7A01         MOV       R2,#0x1
   \   000005   7904         MOV       R1,#0x4
   \   000007   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004   7A55         MOV       R2,#0x55
   \   000006   7B00         MOV       R3,#0x0
   \   000008                REQUIRE ??Subroutine62_0
   \   000008                ; // Fall through to label ??Subroutine62_0
    964          
    965          
    966           /*********************************************************************
    967           * @fn          bdb_NotifyCommissioningModeStart
    968           *
    969           * @brief       Notify the user about a commissioning method just started
    970           *
    971           * @param       commissioningMode
    972           *
    973           * @return      none
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine45_0
   \   000003                ; // Fall through to label ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          void bdb_NotifyCommissioningModeStart(uint8 commissioningMode)
   \                     bdb_NotifyCommissioningModeStart:
    976          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    977            bdbCommissioningModeMsg_t bdbCommissioningModeMsg;
    978          
    979            bdbCommissioningModeMsg.bdbCommissioningMode = commissioningMode;
   \   00000A   7401         MOV       A,#0x1
   \   00000C   12....       LCALL     ?XSTACK_DISP0_8
   \   00000F   E9           MOV       A,R1
   \   000010   12....       LCALL     ??Subroutine51_0 & 0xFFFF
    980            bdbCommissioningModeMsg.bdbCommissioningStatus = BDB_COMMISSIONING_IN_PROGRESS;
   \                     ??CrossCallReturnLabel_79:
   \   000013   7401         MOV       A,#0x1
   \   000015   12....       LCALL     ?Subroutine9 & 0xFFFF
    981            //Remaining commissioning modes are set just before the call to the application to avoid race conditions
    982          
    983            bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   \                     ??CrossCallReturnLabel_0:
   \   000018   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001B   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00001E   12....       LCALL     ?DEALLOC_XSTACK8
    984          }
   \   000021   7403         MOV       A,#0x3
   \   000023   02....       LJMP      ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   7C03         MOV       R4,#0x3
   \   000002   7B00         MOV       R3,#0x0
   \   000004   7A0A         MOV       R2,#0xa
   \   000006                REQUIRE ??Subroutine50_0
   \   000006                ; // Fall through to label ??Subroutine50_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function bdb_SendMsg
   \   000001                ; Setup parameters for call to function bdb_SendMsg
   \   000001                ; Setup parameters for call to function bdb_SendMsg
   \   000001                ; Setup parameters for call to function bdb_SendMsg
   \   000001   A8..         MOV       R0,?XSP + 0
   \   000003   A9..         MOV       R1,?XSP + 1
   \   000005   88..         MOV       ?V0,R0
   \   000007   89..         MOV       ?V1,R1
   \   000009   78..         MOV       R0,#?V0
   \   00000B   22           RET
    985          
    986          
    987          
    988          #if (ZG_BUILD_JOINING_TYPE)
    989           /*********************************************************************
    990           * @fn          bdb_setNodeJoinLinkKeyType
    991           *
    992           * @brief       Set the key type in use in the network joined. Global centralized key is used by default
    993           *
    994           * @param       none
    995           *
    996           * @return      none
    997           */
    998          void bdb_setNodeJoinLinkKeyType(uint8 KeyType)
    999          {
   1000            bdbAttributes.bdbNodeJoinLinkKeyType = KeyType;
   1001          }
   1002          #endif
   1003          
   1004           /*********************************************************************
   1005           * @fn          bdb_setFN
   1006           *
   1007           * @brief       Set configuration for FN. This FN configuration will be perfome 
   1008           *              upon call to ZDOInitDevice
   1009           *
   1010           * @param       none
   1011           *
   1012           * @return      none
   1013           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1014          void bdb_setFN(void)
   \                     bdb_setFN:
   1015          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1016            bdb_setNodeIsOnANetwork(FALSE);
   \   000004                ; Setup parameters for call to function bdb_setNodeIsOnANetwork
   \   000004   7900         MOV       R1,#0x0
   \   000006   12....       LCALL     `??bdb_setNodeIsOnANetwork::?relay`; Banked call to: bdb_setNodeIsOnANetwork
   1017          
   1018          #if defined ( INTER_PAN ) && defined ( BDB_TL_INITIATOR )
   1019              touchLink_InitFreeRanges( TRUE );
   1020              touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
   1021          #endif
   1022          #if defined ( INTER_PAN ) && defined ( BDB_TL_TARGET ) 
   1023              touchLink_InitFreeRanges( FALSE );
   1024              touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
   1025          #endif
   1026          
   1027            //Set the device as factory new
   1028            zgWriteStartupOptions(ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_CONFIG_STATE | ZCD_STARTOPT_DEFAULT_NETWORK_STATE);
   \   000009                ; Setup parameters for call to function zgWriteStartupOptions
   \   000009   7A03         MOV       R2,#0x3
   \   00000B   79FF         MOV       R1,#-0x1
   \   00000D   12....       LCALL     `??zgWriteStartupOptions::?relay`; Banked call to: zgWriteStartupOptions
   1029          }
   \   000010   80..         SJMP      ??Subroutine53_0
   1030          
   1031           /*********************************************************************
   1032           * @fn          bdb_resetLocalAction
   1033           *
   1034           * @brief       Application interface to perform BDB Reset to FN.
   1035           *
   1036           * @param       none
   1037           *
   1038           * @return      none
   1039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1040          void bdb_resetLocalAction(void)
   \                     bdb_resetLocalAction:
   1041          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1042            //Process reset as nwk leave if the device is on the network and is able to process it
   1043            if((ZG_BUILD_JOINING_TYPE) && (bdbAttributes.bdbNodeIsOnANetwork) && (!(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_PARENT_LOST)))
   1044            {
   1045              NLME_LeaveReq_t leaveReq;
   1046              // Set every field to 0
   1047              osal_memset( &leaveReq, 0, sizeof( NLME_LeaveReq_t ) );
   1048              
   1049              bdb_setFN();
   1050                
   1051              NLME_LeaveReq( &leaveReq );
   1052              
   1053              return;
   1054            }
   1055            else
   1056            {
   1057              bdb_setFN();
   \   000004                ; Setup parameters for call to function bdb_setFN
   \   000004   12....       LCALL     `??bdb_setFN::?relay`; Banked call to: bdb_setFN
   1058              
   1059              ZDApp_ResetTimerStart( 500 );
   \   000007                ; Setup parameters for call to function ZDApp_ResetTimerStart
   \   000007   7AF4         MOV       R2,#-0xc
   \   000009   7B01         MOV       R3,#0x1
   \   00000B   12....       LCALL     `??ZDApp_ResetTimerStart::?relay`; Banked call to: ZDApp_ResetTimerStart
   1060            }
   1061          }
   \   00000E   80..         SJMP      ??Subroutine53_0
   1062          
   1063          
   1064           /*********************************************************************
   1065           * @fn          bdb_parentLost
   1066           *
   1067           * @brief       Notify bdb that connection with parent is lost
   1068           *
   1069           * @return      none
   1070           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1071          void bdb_parentLost(void)
   \                     bdb_parentLost:
   1072          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1073          #if ZG_BUILD_ENDDEVICE_TYPE
   1074            if(ZG_DEVICE_ENDDEVICE_TYPE)
   1075            {
   1076              while(pBDBListNwk)
   1077              {
   1078                bdb_nwkDescFree(pBDBListNwk);
   1079              }
   1080              
   1081              nwk_desc_list_free();  
   1082              if(bdbCommissioningProcedureState.bdbCommissioningState != BDB_PARENT_LOST)
   1083              {
   1084                //If parent lost during TCLK exchange, then report TCLK exchange fail
   1085                if(bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE)
   1086                {
   1087                  bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE, FALSE);
   1088                  return;
   1089                }
   1090                bdbCommissioningProcedureState.bdb_ParentLostSavedState = bdbCommissioningProcedureState.bdbCommissioningState;
   1091                
   1092              }
   1093              bdbCommissioningProcedureState.bdbCommissioningState = BDB_PARENT_LOST;
   1094              NLME_OrphanStateSet();
   1095              ZDApp_ChangeState( DEV_NWK_ORPHAN );
   1096              bdb_reportCommissioningState(BDB_PARENT_LOST,FALSE);
   1097            }
   1098          #endif
   1099          }
   \   000000   02....       LJMP      ?BRET
   1100          
   1101          
   1102          
   1103          
   1104          
   1105           /*********************************************************************
   1106           * @fn          bdb_NetworkRestoredResumeState
   1107           *
   1108           * @brief       Restore the state of child device after parent lost
   1109           *
   1110           * @return      none
   1111           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1112          void bdb_NetworkRestoredResumeState(void)
   \                     bdb_NetworkRestoredResumeState:
   1113          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1114          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)   
   1115          #if ZG_BUILD_ENDDEVICE_TYPE
   1116            if(ZG_DEVICE_ENDDEVICE_TYPE)
   1117            {
   1118              uint8 restoreSimpleDesc = FALSE;
   1119              //If restored when F&B still enabled, then restore the simple descriptors attempts
   1120              if(bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_FINDING_BINDING)
   1121              {
   1122                bdbFindingBindingRespondent_t  *pRespondentTemp = NULL;
   1123                
   1124                pRespondentTemp = pRespondentHead;
   1125                
   1126                while(pRespondentTemp != NULL)
   1127                {
   1128                  if(pRespondentTemp->attempts & FINDING_AND_BINDING_PARENT_LOST)
   1129                  {
   1130                    pRespondentTemp->attempts &= ~FINDING_AND_BINDING_PARENT_LOST;
   1131                    restoreSimpleDesc = TRUE;
   1132                  }
   1133                  pRespondentTemp = pRespondentTemp->pNext;
   1134                }
   1135              }
   1136              if(restoreSimpleDesc)
   1137              {
   1138                //Restore the simple Descriptor sending after 1 second of restoring the network
   1139                osal_start_timerEx(bdb_TaskID,BDB_RESPONDENT_PROCESS_TIMEOUT, 1000);
   1140              }
   1141            }
   1142          #endif
   1143          #endif
   1144          }
   \   000000   02....       LJMP      ?BRET
   1145          
   1146          #if ZG_BUILD_ENDDEVICE_TYPE
   1147           /*********************************************************************
   1148           * @fn          bdb_ZedAttemptRecoverNwk
   1149           *
   1150           * @brief       Instruct the ZED to try to rejoin its previews network
   1151           *
   1152           * @return      success if the attempt is being excecuted
   1153           *              False if device do not have nwk parameters to perform this action
   1154           */
   1155          uint8 bdb_ZedAttemptRecoverNwk(void)
   1156          {
   1157            if(ZG_DEVICE_ENDDEVICE_TYPE)
   1158            {
   1159              if(bdbAttributes.bdbNodeIsOnANetwork)
   1160              {
   1161                if(bdbCommissioningProcedureState.bdbCommissioningState == BDB_PARENT_LOST)
   1162                {
   1163                  if(ZDOInitDevice(0) == ZDO_INITDEV_RESTORED_NETWORK_STATE)
   1164                  {
   1165                    return ZSuccess;
   1166                  }
   1167                }
   1168              }
   1169            }
   1170            return ZFailure;
   1171          }
   1172          
   1173          #endif
   1174          
   1175           /*********************************************************************
   1176           * @fn          bdb_reportCommissioningState
   1177           *
   1178           * @brief       Process the result of a BDB main state attempt.
   1179           *
   1180           * @param       bdbCommissioningState - MainState that is issuing fail
   1181           * @param       didSuccess - TRUE if the main state were success, FALSE otherwise
   1182           *
   1183           * @return      none
   1184           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1185          void bdb_reportCommissioningState(uint8 bdbCommissioningState,bool didSuccess)
   \                     bdb_reportCommissioningState:
   1186          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EA           MOV       A,R2
   \   00000D   FF           MOV       R7,A
   1187            bdbCommissioningModeMsg_t bdbCommissioningModeMsg;
   1188            //Process only if we are in that state, or if we are on parent lost and processing F&B
   1189            if((bdbCommissioningProcedureState.bdbCommissioningState == bdbCommissioningState)
   1190               || ((bdbCommissioningProcedureState.bdbCommissioningState == BDB_PARENT_LOST) && (bdbCommissioningProcedureState.bdb_ParentLostSavedState == BDB_COMMISSIONING_STATE_FINDING_BINDING)))
   \   00000E   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000011   E0           MOVX      A,@DPTR
   \   000012   6E           XRL       A,R6
   \   000013   6013         JZ        ??bdb_reportCommissioningState_0
   \   000015   E0           MOVX      A,@DPTR
   \   000016   6408         XRL       A,#0x8
   \   000018   6003         JZ        $+5
   \   00001A   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   \   00001D   90....       MOV       DPTR,#bdbCommissioningProcedureState + 3
   \   000020   E0           MOVX      A,@DPTR
   \   000021   6406         XRL       A,#0x6
   \   000023   6003         JZ        $+5
   \   000025   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   1191            {
   1192              switch(bdbCommissioningState)
   \                     ??bdb_reportCommissioningState_0:
   \   000028   E9           MOV       A,R1
   \   000029   24FE         ADD       A,#-0x2
   \   00002B   7003         JNZ       $+5
   \   00002D   02....       LJMP      ??bdb_reportCommissioningState_2 & 0xFFFF
   \   000030   24FE         ADD       A,#-0x2
   \   000032   6012         JZ        ??bdb_reportCommissioningState_3
   \   000034   14           DEC       A
   \   000035   604B         JZ        ??bdb_reportCommissioningState_4
   \   000037   14           DEC       A
   \   000038   7003         JNZ       $+5
   \   00003A   02....       LJMP      ??bdb_reportCommissioningState_5 & 0xFFFF
   \   00003D   14           DEC       A
   \   00003E   7003         JNZ       $+5
   \   000040   02....       LJMP      ??bdb_reportCommissioningState_6 & 0xFFFF
   \   000043   02....       LJMP      ??bdb_reportCommissioningState_7 & 0xFFFF
   1193              {
   1194          #if (ZG_BUILD_JOINING_TYPE)
   1195                case BDB_COMMISSIONING_STATE_JOINING:
   1196                  if(ZG_DEVICE_JOINING_TYPE)
   1197                  {
   1198                    //Prepare for the next state or commissioning mode to be excecuted
   1199                    osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50);
   1200          
   1201                    if(didSuccess)
   1202                    {
   1203                      //Next state is TC link key exchange
   1204                      bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE;
   1205                      //Free the list of nwk discovered
   1206                      while(pBDBListNwk)
   1207                      {
   1208                        bdb_nwkDescFree(pBDBListNwk);
   1209                      }
   1210                      
   1211                      //Set the poll rate of the ZED joining device to 1 second to allow TCLK 
   1212                      //exchange be perfomed successfully in cases in which application has a 
   1213                      //slow pollrate
   1214                      NLME_SetPollRate(TCLK_POLL_RATE);
   1215                      
   1216                      //No notification in this step
   1217                      return;
   1218                    } 
   1219                    else
   1220                    {
   1221                      uint8 temp = FALSE;
   1222                      //If fail, then restore poll rate
   1223                      NLME_SetPollRate(POLL_RATE);
   1224                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
   1225                      bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_NWK_STEERING;
   1226                      bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   1227                      bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_NWK_STEERING;
   1228                      
   1229                      //Turn off the radio
   1230                      ZMacSetReq(ZMacRxOnIdle, &temp);
   1231                      //Set the device to FN, to start as new for subsequent attempts
   1232                      bdb_setFN();
   1233                      NLME_ResetRequest();
   1234                      ZDApp_ChangeState( DEV_HOLD );
   1235                      
   1236                      //Free the list of nwk discovered
   1237                      while(pBDBListNwk)
   1238                      {
   1239                        bdb_nwkDescFree(pBDBListNwk);
   1240                      }
   1241                    }
   1242                  }
   1243                break;
   1244          
   1245                case BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE:
   1246                  if(ZG_DEVICE_JOINING_TYPE)
   1247                  {
   1248                    if(didSuccess)
   1249                    {
   1250                      //Clear any setting that would set the device as FN
   1251                      zgWriteStartupOptions(ZG_STARTUP_CLEAR, ZCD_STARTOPT_DEFAULT_CONFIG_STATE | ZCD_STARTOPT_DEFAULT_NETWORK_STATE);            
   1252                      
   1253                      //Next state is nwk steering on the nwk (permit joining)
   1254                      bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_STEERING_ON_NWK;
   1255                      osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE, 50);
   1256                      
   1257                      //Set the poll rate to the application default after TCLK success
   1258                      NLME_SetPollRate(POLL_RATE);
   1259          
   1260                      osal_stop_timerEx( bdb_TaskID, BDB_PROCESS_TIMEOUT );
   1261                      //No notification to the user is needed
   1262                      return;
   1263                    }
   1264                    else
   1265                    {
   1266                      bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_NWK_STEERING;
   1267                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TCLK_EX_FAILURE;
   1268                      
   1269                      osal_stop_timerEx( bdb_TaskID, BDB_PROCESS_TIMEOUT);
   1270                     
   1271                      //No process shall be attempted after this fail
   1272                      bdbAttributes.bdbCommissioningMode = 0;
   1273                      
   1274                      //Fill the context for the user notification
   1275                      osal_start_timerEx(bdb_TaskID,BDB_TC_LINK_KEY_EXCHANGE_FAIL,BDB_TC_LINK_KEY_EXCHANGE_FAIL_LEAVE_TIMEOUT);
   1276                    }
   1277                  }
   1278                break;
   1279          #endif
   1280                
   1281                case BDB_COMMISSIONING_STATE_STEERING_ON_NWK:
   1282                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_NWK_STEERING;
   \                     ??bdb_reportCommissioningState_3:
   \   000046   7401         MOV       A,#0x1
   \   000048   12....       LCALL     ?XSTACK_DISP0_8
   \   00004B   7401         MOV       A,#0x1
   \   00004D   F0           MOVX      @DPTR,A
   1283                  if(didSuccess)
   \   00004E   EA           MOV       A,R2
   \   00004F   90....       MOV       DPTR,#bdbAttributes + 10
   \   000052   6011         JZ        ??bdb_reportCommissioningState_8
   1284                  {
   1285                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \   000054   E4           CLR       A
   \   000055   F0           MOVX      @DPTR,A
   1286                    
   1287          #if (ZG_BUILD_RTR_TYPE)          
   1288                    //Update ZDApp state
   1289                    if(ZG_DEVICE_RTRONLY_TYPE)
   \   000056   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   6401         XRL       A,#0x1
   \   00005C   700A         JNZ       ??bdb_reportCommissioningState_9
   1290                    {          
   1291                      ZDApp_ChangeState( DEV_ROUTER );
   \   00005E                ; Setup parameters for call to function ZDApp_ChangeState
   \   00005E   7907         MOV       R1,#0x7
   \   000060   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   \   000063   8003         SJMP      ??bdb_reportCommissioningState_9
   1292                    }
   1293          #endif
   1294          #if (ZG_BUILD_ENDDEVICE_TYPE)
   1295                    if(ZG_DEVICE_ENDDEVICE_TYPE)
   1296                    {
   1297                      ZDApp_ChangeState( DEV_END_DEVICE );
   1298                    }
   1299          #endif
   1300                  }
   1301          #if (ZG_BUILD_COORDINATOR_TYPE)
   1302                  else
   1303                  {
   1304                    if(ZG_DEVICE_COORDINATOR_TYPE)
   1305                    {
   1306                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
   \                     ??bdb_reportCommissioningState_8:
   \   000065   7402         MOV       A,#0x2
   \   000067   F0           MOVX      @DPTR,A
   1307                    }
   1308                  }
   1309          #endif
   1310                  
   1311                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \                     ??bdb_reportCommissioningState_9:
   \   000068   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   00006B   E4           CLR       A
   \   00006C   F0           MOVX      @DPTR,A
   1312                  osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50);
   \   00006D                ; Setup parameters for call to function osal_start_timerEx
   \   00006D   90....       MOV       DPTR,#__Constant_32
   \   000070   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000073   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000076   12....       LCALL     ?DEALLOC_XSTACK8
   1313                  bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_NWK_STEERING;
   \   000079   90....       MOV       DPTR,#bdbAttributes + 11
   \   00007C   E0           MOVX      A,@DPTR
   \   00007D   C2E1         CLR       0xE0 /* A   */.1
   \   00007F   02....       LJMP      ??bdb_reportCommissioningState_10 & 0xFFFF
   1314                break;
   1315                
   1316                case BDB_COMMISSIONING_STATE_FORMATION:
   1317                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_FORMATION;
   \                     ??bdb_reportCommissioningState_4:
   \   000082   7401         MOV       A,#0x1
   \   000084   12....       LCALL     ?XSTACK_DISP0_8
   \   000087   7402         MOV       A,#0x2
   \   000089   F0           MOVX      @DPTR,A
   1318          
   1319                  if(didSuccess)
   \   00008A   EA           MOV       A,R2
   \   00008B   90....       MOV       DPTR,#bdbAttributes + 10
   \   00008E   6019         JZ        ??bdb_reportCommissioningState_11
   1320                  {
   1321                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \   000090   E4           CLR       A
   \   000091   F0           MOVX      @DPTR,A
   1322          
   1323                    //Clear any setting that would set the device as FN
   1324                    zgWriteStartupOptions(ZG_STARTUP_CLEAR, ZCD_STARTOPT_DEFAULT_CONFIG_STATE | ZCD_STARTOPT_DEFAULT_NETWORK_STATE);          
   \   000092                ; Setup parameters for call to function zgWriteStartupOptions
   \   000092   7A03         MOV       R2,#0x3
   \   000094   F9           MOV       R1,A
   \   000095   12....       LCALL     `??zgWriteStartupOptions::?relay`; Banked call to: zgWriteStartupOptions
   1325                    
   1326                     //Update ZDApp State
   1327          #if (ZG_BUILD_RTR_TYPE)
   1328                    if(ZG_DEVICE_RTRONLY_TYPE)
   \   000098   90....       MOV       DPTR,#zgDeviceLogicalType
   \   00009B   E0           MOVX      A,@DPTR
   \   00009C   6401         XRL       A,#0x1
   \   00009E   7005         JNZ       ??bdb_reportCommissioningState_12
   1329                    {          
   1330                      ZDApp_ChangeState( DEV_ROUTER );
   \   0000A0                ; Setup parameters for call to function ZDApp_ChangeState
   \   0000A0   7907         MOV       R1,#0x7
   \   0000A2   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1331                    }
   1332          #endif    
   1333          #if (ZG_BUILD_COORDINATOR_TYPE)
   1334                    if(ZG_DEVICE_COORDINATOR_TYPE)
   1335                    {          
   1336                      ZDApp_ChangeState( DEV_ZB_COORD );
   \                     ??bdb_reportCommissioningState_12:
   \   0000A5                ; Setup parameters for call to function ZDApp_ChangeState
   \   0000A5   7909         MOV       R1,#0x9
   \   0000A7   802C         SJMP      ??bdb_reportCommissioningState_13
   1337                    }     
   1338          #endif
   1339                  }
   1340                  else
   1341                  {
   1342                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_FORMATION_FAILURE;
   \                     ??bdb_reportCommissioningState_11:
   \   0000A9   7408         MOV       A,#0x8
   \   0000AB   F0           MOVX      @DPTR,A
   1343                    //If not on the nwk, then restart the nwk parameters
   1344          #if (ZG_BUILD_RTR_TYPE)
   1345                    if(ZG_DEVICE_RTR_TYPE)
   \   0000AC   90....       MOV       DPTR,#zgDeviceLogicalType
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   6004         JZ        ??bdb_reportCommissioningState_14
   \   0000B2   6401         XRL       A,#0x1
   \   0000B4   7022         JNZ       ??bdb_reportCommissioningState_15
   1346                    {           
   1347                      if(!bdbAttributes.bdbNodeIsOnANetwork)
   \                     ??bdb_reportCommissioningState_14:
   \   0000B6   90....       MOV       DPTR,#bdbAttributes + 14
   \   0000B9   E0           MOVX      A,@DPTR
   \   0000BA   701C         JNZ       ??bdb_reportCommissioningState_15
   1348                      {
   1349                        uint8 temp = FALSE;
   \   0000BC   7403         MOV       A,#0x3
   \   0000BE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C1   E4           CLR       A
   \   0000C2   F0           MOVX      @DPTR,A
   1350                        //Turn off the radio
   1351                        ZMacSetReq(ZMacRxOnIdle, &temp);
   \   0000C3                ; Setup parameters for call to function ZMacSetReq
   \   0000C3   7403         MOV       A,#0x3
   \   0000C5   12....       LCALL     ?XSTACK_DISP101_8
   \   0000C8   7952         MOV       R1,#0x52
   \   0000CA   12....       LCALL     `??ZMacSetReq::?relay`; Banked call to: ZMacSetReq
   1352                        //Set the device to FN, to start as new for subsequent attempts
   1353                        bdb_setFN();
   \   0000CD                ; Setup parameters for call to function bdb_setFN
   \   0000CD   12....       LCALL     `??bdb_setFN::?relay`; Banked call to: bdb_setFN
   1354                        NLME_ResetRequest();
   \   0000D0                ; Setup parameters for call to function NLME_ResetRequest
   \   0000D0   12....       LCALL     `??NLME_ResetRequest::?relay`; Banked call to: NLME_ResetRequest
   1355                        ZDApp_ChangeState( DEV_HOLD );
   \   0000D3                ; Setup parameters for call to function ZDApp_ChangeState
   \   0000D3   7900         MOV       R1,#0x0
   \                     ??bdb_reportCommissioningState_13:
   \   0000D5   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1356                      }
   1357                    }
   1358          #endif
   1359                  }
   1360                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \                     ??bdb_reportCommissioningState_15:
   \   0000D8   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0000DB   E4           CLR       A
   \   0000DC   F0           MOVX      @DPTR,A
   1361                  osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50);
   \   0000DD                ; Setup parameters for call to function osal_start_timerEx
   \   0000DD   90....       MOV       DPTR,#__Constant_32
   \   0000E0   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0000E3   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   0000E6   12....       LCALL     ?DEALLOC_XSTACK8
   1362                  bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_NWK_FORMATION;
   \   0000E9   90....       MOV       DPTR,#bdbAttributes + 11
   \   0000EC   E0           MOVX      A,@DPTR
   \   0000ED   C2E2         CLR       0xE0 /* A   */.2
   \   0000EF   02....       LJMP      ??bdb_reportCommissioningState_10 & 0xFFFF
   1363                break;  
   1364                
   1365          
   1366                case BDB_COMMISSIONING_STATE_FINDING_BINDING:
   1367          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1) 
   1368                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_FINDING_BINDING;
   \                     ??bdb_reportCommissioningState_5:
   \   0000F2   7401         MOV       A,#0x1
   \   0000F4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F7   7403         MOV       A,#0x3
   \   0000F9   F0           MOVX      @DPTR,A
   1369          
   1370                  //Do not notify the status if we have another identify to send
   1371                  if(bdbAttributes.bdbCommissioningStatus == BDB_COMMISSIONING_SUCCESS)
   \   0000FA   90....       MOV       DPTR,#bdbAttributes + 10
   \   0000FD   E0           MOVX      A,@DPTR
   \   0000FE   7006         JNZ       ??bdb_reportCommissioningState_16
   1372                  {
   1373                    //Success at least once during F&B as initiator, mark it
   1374                    bdb_FBStateSuccessLatch = TRUE;
   \   000100   90....       MOV       DPTR,#bdb_FBStateSuccessLatch
   \   000103   7401         MOV       A,#0x1
   \   000105   F0           MOVX      @DPTR,A
   1375                  }        
   1376                  
   1377                  //Will we process another indentify?
   1378                  if(((FINDING_AND_BINDING_PERIODIC_ENABLE == FALSE) || (bdb_FB_InitiatorCurrentCyclesNumber == 0)) && (bdb_getRespondentRetry(pRespondentHead) == NULL) && (osal_get_timeoutEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT) == 0))
   \                     ??bdb_reportCommissioningState_16:
   \   000106   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000109   E0           MOVX      A,@DPTR
   \   00010A   6003         JZ        $+5
   \   00010C   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   \   00010F                ; Setup parameters for call to function bdb_getRespondentRetry
   \   00010F   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000112   6003         JZ        $+5
   \   000114   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   \   000117                ; Setup parameters for call to function osal_get_timeoutEx
   \   000117   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   00011A   6003         JZ        $+5
   \   00011C   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   1379                  {
   1380                    // Dealocate respondent list and clean all the F&B process
   1381                    pRespondentCurr = NULL;
   \   00011F   90....       MOV       DPTR,#pRespondentCurr
   \   000122   E4           CLR       A
   \   000123   F0           MOVX      @DPTR,A
   \   000124   A3           INC       DPTR
   \   000125   F0           MOVX      @DPTR,A
   1382                    pRespondentNext = NULL;
   \   000126   90....       MOV       DPTR,#pRespondentNext
   \   000129   F0           MOVX      @DPTR,A
   \   00012A   A3           INC       DPTR
   \   00012B   F0           MOVX      @DPTR,A
   1383                    bdb_zclRespondentListClean( &pRespondentHead );
   \   00012C                ; Setup parameters for call to function bdb_zclRespondentListClean
   \   00012C   7A..         MOV       R2,#pRespondentHead & 0xff
   \   00012E   7B..         MOV       R3,#(pRespondentHead >> 8) & 0xff
   \   000130   12....       LCALL     `??bdb_zclRespondentListClean::?relay`; Banked call to: bdb_zclRespondentListClean
   1384                    osal_stop_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT );
   \   000133                ; Setup parameters for call to function osal_stop_timerEx
   \   000133   7A00         MOV       R2,#0x0
   \   000135   7B40         MOV       R3,#0x40
   \   000137   12....       LCALL     ??Subroutine63_0 & 0xFFFF
   1385                    
   1386                    //Report success if in any of the attempts we got success, regardless that we did receive no rsp on the last attempt
   1387                    if(bdb_FBStateSuccessLatch && (bdbAttributes.bdbCommissioningStatus == BDB_COMMISSIONING_FB_NO_IDENTIFY_QUERY_RESPONSE))
   \                     ??CrossCallReturnLabel_128:
   \   00013A   90....       MOV       DPTR,#bdb_FBStateSuccessLatch
   \   00013D   E0           MOVX      A,@DPTR
   \   00013E   600A         JZ        ??bdb_reportCommissioningState_17
   \   000140   90....       MOV       DPTR,#bdbAttributes + 10
   \   000143   E0           MOVX      A,@DPTR
   \   000144   640B         XRL       A,#0xb
   \   000146   7002         JNZ       ??bdb_reportCommissioningState_17
   1388                    {
   1389                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \   000148   E4           CLR       A
   \   000149   F0           MOVX      @DPTR,A
   1390                    }
   1391                    
   1392                    //Set default state
   1393                    bdb_FBStateSuccessLatch = FALSE;
   \                     ??bdb_reportCommissioningState_17:
   \   00014A   90....       MOV       DPTR,#bdb_FBStateSuccessLatch
   \   00014D   E4           CLR       A
   \   00014E   F0           MOVX      @DPTR,A
   1394                    
   1395                    //Resume BDB machine state only if we were in F&B, if we were on parent lost, only clean the commissioning mode and remove from bdb_ParentLostSavedState
   1396                    if(bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_FINDING_BINDING)
   \   00014F   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000152   E0           MOVX      A,@DPTR
   \   000153   6406         XRL       A,#0x6
   \   000155   7010         JNZ       ??bdb_reportCommissioningState_18
   1397                    {
   1398                      bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   000157   E4           CLR       A
   \   000158   F0           MOVX      @DPTR,A
   1399                      osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50); 
   \   000159                ; Setup parameters for call to function osal_start_timerEx
   \   000159   90....       MOV       DPTR,#__Constant_32
   \   00015C   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00015F   12....       LCALL     ?Subroutine17 & 0xFFFF
   1400                    }
   \                     ??CrossCallReturnLabel_111:
   \   000162   12....       LCALL     ?DEALLOC_XSTACK8
   \   000165   800A         SJMP      ??bdb_reportCommissioningState_19
   1401                    else if(bdbCommissioningProcedureState.bdb_ParentLostSavedState == BDB_COMMISSIONING_STATE_FINDING_BINDING)
   \                     ??bdb_reportCommissioningState_18:
   \   000167   90....       MOV       DPTR,#bdbCommissioningProcedureState + 3
   \   00016A   E0           MOVX      A,@DPTR
   \   00016B   6406         XRL       A,#0x6
   \   00016D   7002         JNZ       ??bdb_reportCommissioningState_19
   1402                    {
   1403                      bdbCommissioningProcedureState.bdb_ParentLostSavedState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   00016F   E4           CLR       A
   \   000170   F0           MOVX      @DPTR,A
   1404                    }
   1405                    
   1406                    bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_FINDING_BINDING;
   \                     ??bdb_reportCommissioningState_19:
   \   000171   90....       MOV       DPTR,#bdbAttributes + 11
   \   000174   E0           MOVX      A,@DPTR
   \   000175   C2E3         CLR       0xE0 /* A   */.3
   \   000177   8074         SJMP      ??bdb_reportCommissioningState_10
   1407                  }
   1408                  else
   1409                  {
   1410                    return;
   1411                  }
   1412          
   1413          #endif
   1414                break;     
   1415                case BDB_COMMISSIONING_STATE_TL:
   1416                  // Set NWK task to run
   1417                  nwk_setStateIdle( FALSE );
   \                     ??bdb_reportCommissioningState_2:
   \   000179                ; Setup parameters for call to function nwk_setStateIdle
   \   000179   7900         MOV       R1,#0x0
   \   00017B   12....       LCALL     `??nwk_setStateIdle::?relay`; Banked call to: nwk_setStateIdle
   1418                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_TOUCHLINK;
   \   00017E   7401         MOV       A,#0x1
   \   000180   12....       LCALL     ?XSTACK_DISP0_8
   \   000183   7404         MOV       A,#0x4
   \   000185   F0           MOVX      @DPTR,A
   1419                  if(didSuccess)
   \   000186   EF           MOV       A,R7
   \   000187   6014         JZ        ??bdb_reportCommissioningState_20
   1420                  {
   1421                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \   000189   90....       MOV       DPTR,#bdbAttributes + 10
   \   00018C   E4           CLR       A
   \   00018D   F0           MOVX      @DPTR,A
   1422                    bdbAttributes.bdbCommissioningMode = BDB_COMMISSIONING_MODE_IDDLE;
   \   00018E   A3           INC       DPTR
   \   00018F   F0           MOVX      @DPTR,A
   1423                    
   1424                    //Update ZDApp state
   1425          #if (ZG_BUILD_RTR_TYPE)
   1426                    if(ZG_DEVICE_RTRONLY_TYPE)
   \   000190   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000193   E0           MOVX      A,@DPTR
   \   000194   6401         XRL       A,#0x1
   \   000196   7005         JNZ       ??bdb_reportCommissioningState_20
   1427                    {          
   1428                      ZDApp_ChangeState( DEV_ROUTER );
   \   000198                ; Setup parameters for call to function ZDApp_ChangeState
   \   000198   7907         MOV       R1,#0x7
   \   00019A   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1429                    }
   1430          #endif
   1431          #if (ZG_BUILD_ENDDEVICE_TYPE)
   1432                    if(ZG_DEVICE_ENDDEVICE_TYPE)
   1433                    {
   1434                      ZDApp_ChangeState( DEV_END_DEVICE );
   1435                    }
   1436          #endif          
   1437                  }
   1438                  //The fail status is already set from the calling function to report commissioning process
   1439                  
   1440                  // The commissioning FAIL status is set before calling the bdb_reportCommissioningState
   1441                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \                     ??bdb_reportCommissioningState_20:
   \   00019D   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0001A0   E4           CLR       A
   \   0001A1   F0           MOVX      @DPTR,A
   1442                  osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50); 
   \   0001A2                ; Setup parameters for call to function osal_start_timerEx
   \   0001A2   90....       MOV       DPTR,#__Constant_32
   \   0001A5   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0001A8   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0001AB   12....       LCALL     ?DEALLOC_XSTACK8
   1443                  //Clear the event
   1444                  bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_INITIATOR_TL;
   \   0001AE   90....       MOV       DPTR,#bdbAttributes + 11
   \   0001B1   E0           MOVX      A,@DPTR
   \   0001B2   C2E0         CLR       0xE0 /* A   */.0
   \   0001B4   8037         SJMP      ??bdb_reportCommissioningState_10
   1445                  
   1446                break;
   1447                
   1448                case BDB_INITIALIZATION:
   1449                  //Notify user about successfull initialization
   1450                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_INITIALIZATION;
   \                     ??bdb_reportCommissioningState_6:
   \   0001B6   7401         MOV       A,#0x1
   \   0001B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001BB   E4           CLR       A
   \   0001BC   F0           MOVX      @DPTR,A
   1451                  if(didSuccess)
   \   0001BD   EA           MOV       A,R2
   \   0001BE   6021         JZ        ??bdb_reportCommissioningState_21
   1452                  {
   1453                    //Update ZDApp state
   1454          #if (ZG_BUILD_COORDINATOR_TYPE)
   1455                    if(ZG_DEVICE_COORDINATOR_TYPE)
   1456                    {          
   1457                      ZDApp_ChangeState( DEV_ZB_COORD );
   \   0001C0                ; Setup parameters for call to function ZDApp_ChangeState
   \   0001C0   7909         MOV       R1,#0x9
   \   0001C2   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1458                    }
   1459          #endif          
   1460          #if (ZG_BUILD_ENDDEVICE_TYPE)
   1461                    if(ZG_DEVICE_ENDDEVICE_TYPE)
   1462                    {
   1463                      uint32 pollrate = POLL_RATE;
   1464                      NLME_SetPollRate(pollrate);
   1465                      ZDApp_ChangeState( DEV_END_DEVICE );
   1466                      
   1467                    }
   1468          #endif          
   1469                    ZDApp_RestoreNwkSecMaterial();
   \   0001C5                ; Setup parameters for call to function ZDApp_RestoreNwkSecMaterial
   \   0001C5   12....       LCALL     `??ZDApp_RestoreNwkSecMaterial::?relay`; Banked call to: ZDApp_RestoreNwkSecMaterial
   1470                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NETWORK_RESTORED;
   \   0001C8   90....       MOV       DPTR,#bdbAttributes + 10
   \   0001CB   740D         MOV       A,#0xd
   \   0001CD   F0           MOVX      @DPTR,A
   1471                    bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   0001CE   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0001D1   E4           CLR       A
   \   0001D2   F0           MOVX      @DPTR,A
   1472                    osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,200);
   \   0001D3                ; Setup parameters for call to function osal_start_timerEx
   \   0001D3   90....       MOV       DPTR,#__Constant_c8
   \   0001D6   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0001D9   12....       LCALL     ?Subroutine17 & 0xFFFF
   1473                  }
   \                     ??CrossCallReturnLabel_113:
   \   0001DC   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001DF   8006         SJMP      ??bdb_reportCommissioningState_22
   1474                  else
   1475                  {
   1476          #if (ZG_BUILD_ENDDEVICE_TYPE)                   
   1477                    if(ZG_DEVICE_ENDDEVICE_TYPE)
   1478                    {
   1479                      if(bdb_isDeviceNonFactoryNew())
   1480                      {
   1481                        //Notify the user about losing parent
   1482                        bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_PARENT_LOST;
   1483                        bdbAttributes.bdbCommissioningMode |= BDB_COMMISSIONING_MODE_PARENT_LOST;
   1484                        
   1485                        //Update ZDApp state
   1486                        ZDApp_ChangeState( DEV_NWK_ORPHAN );
   1487                      }
   1488                    }
   1489          #endif
   1490                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
   \                     ??bdb_reportCommissioningState_21:
   \   0001E1   90....       MOV       DPTR,#bdbAttributes + 10
   \   0001E4   7402         MOV       A,#0x2
   \   0001E6   F0           MOVX      @DPTR,A
   1491                  }
   1492                  bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_INITIALIZATION;
   \                     ??bdb_reportCommissioningState_22:
   \   0001E7   90....       MOV       DPTR,#bdbAttributes + 11
   \   0001EA   E0           MOVX      A,@DPTR
   \   0001EB   C2E4         CLR       0xE0 /* A   */.4
   \                     ??bdb_reportCommissioningState_10:
   \   0001ED   F0           MOVX      @DPTR,A
   1493          
   1494                break;
   1495          #if (ZG_BUILD_ENDDEVICE_TYPE)     
   1496                case BDB_PARENT_LOST:
   1497                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_PARENT_LOST;
   1498                  if(ZG_DEVICE_ENDDEVICE_TYPE)
   1499                  {
   1500                    if(didSuccess)
   1501                    {
   1502                      uint32 pollrate = POLL_RATE;
   1503                      bdbCommissioningProcedureState.bdbCommissioningState = bdbCommissioningProcedureState.bdb_ParentLostSavedState;  
   1504                      bdbCommissioningProcedureState.bdb_ParentLostSavedState = 0;
   1505                      NLME_SetPollRate(pollrate);
   1506                      bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_PARENT_LOST;
   1507                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NETWORK_RESTORED;
   1508                      //Update ZDApp state
   1509                      ZDApp_ChangeState( DEV_END_DEVICE );
   1510                      
   1511                      bdb_NetworkRestoredResumeState();
   1512                    }
   1513                    else
   1514                    {
   1515                      bdbAttributes.bdbCommissioningMode |= BDB_COMMISSIONING_MODE_PARENT_LOST;
   1516                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
   1517                    }
   1518                  }
   1519                break;
   1520          #endif
   1521              }
   1522          #ifdef MT_APP_CNF_FUNC
   1523              //Notify the user about the status, the main state which has failed
   1524              bdbCommissioningModeMsg.bdbCommissioningStatus = bdbAttributes.bdbCommissioningStatus;
   1525              
   1526              bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   1527          #else
   1528              if(pfnCommissioningStatusCB)
   \                     ??bdb_reportCommissioningState_7:
   \   0001EE   90....       MOV       DPTR,#pfnCommissioningStatusCB
   \   0001F1   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   0001F4   6016         JZ        ??bdb_reportCommissioningState_1
   1529              {
   1530                //Notify the user about the status, the main state which has failed
   1531                bdbCommissioningModeMsg.bdbCommissioningStatus = bdbAttributes.bdbCommissioningStatus;
   \   0001F6   90....       MOV       DPTR,#bdbAttributes + 10
   \   0001F9   E0           MOVX      A,@DPTR
   \   0001FA   85..82       MOV       DPL,?XSP + 0
   \   0001FD   85..83       MOV       DPH,?XSP + 1
   \   000200   12....       LCALL     ?Subroutine9 & 0xFFFF
   1532                
   1533                bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   1534              }
   1535          #endif
   1536            }  
   \                     ??CrossCallReturnLabel_1:
   \   000203   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000206   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000209   12....       LCALL     ?DEALLOC_XSTACK8
   1537          }
   \                     ??bdb_reportCommissioningState_1:
   \   00020C   7404         MOV       A,#0x4
   \   00020E   02....       LJMP      ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   7A00         MOV       R2,#0x0
   \   000002   7B40         MOV       R3,#0x40
   \   000004                REQUIRE ??Subroutine54_0
   \   000004                ; // Fall through to label ??Subroutine54_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   90....       MOV       DPTR,#pRespondentHead
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FA           MOV       R2,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   FB           MOV       R3,A
   \   000008   12....       LCALL     `??bdb_getRespondentRetry::?relay`; Banked call to: bdb_getRespondentRetry
   \   00000B   EA           MOV       A,R2
   \   00000C   4B           ORL       A,R3
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   7A04         MOV       R2,#0x4
   \   000002                REQUIRE ??Subroutine60_0
   \   000002                ; // Fall through to label ??Subroutine60_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine60_0:
   \   000000   7B00         MOV       R3,#0x0
   \   000002                REQUIRE ??Subroutine61_0
   \   000002                ; // Fall through to label ??Subroutine61_0
   1538          
   1539          
   1540           /*********************************************************************
   1541           * @fn          bdb_nwkFormationAttempt
   1542           *
   1543           * @brief       Process a nwk formation attempt.
   1544           *
   1545           * @param       didSuccess - TRUE if the nwk formation was success, FALSE 
   1546           *                         otherwise and try secondary channel
   1547           *
   1548           * @return      none
   1549           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1550          void bdb_nwkFormationAttempt(bool didSuccess)
   \                     bdb_nwkFormationAttempt:
   1551          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   1552            if(didSuccess)
   \   000006   6004         JZ        ??bdb_nwkFormationAttempt_0
   1553            {
   1554              bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_FORMATION,TRUE);
   \   000008                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000008   7A01         MOV       R2,#0x1
   \   00000A   801F         SJMP      ??bdb_nwkFormationAttempt_1
   1555            }
   1556            else
   1557            {
   1558              //Can we try the secondary channel set?
   1559              if((vDoPrimaryScan) && (bdbAttributes.bdbSecondaryChannelSet))
   \                     ??bdb_nwkFormationAttempt_0:
   \   00000C   90....       MOV       DPTR,#vDoPrimaryScan
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   6017         JZ        ??bdb_nwkFormationAttempt_2
   \   000012   90....       MOV       DPTR,#bdbAttributes
   \   000015   12....       LCALL     ?XLOAD_R0123
   \   000018   E8           MOV       A,R0
   \   000019   49           ORL       A,R1
   \   00001A   4A           ORL       A,R2
   \   00001B   4B           ORL       A,R3
   \   00001C   600B         JZ        ??bdb_nwkFormationAttempt_2
   1560              {
   1561                vDoPrimaryScan = FALSE;
   \   00001E   90....       MOV       DPTR,#vDoPrimaryScan
   \   000021   E4           CLR       A
   \   000022   F0           MOVX      @DPTR,A
   1562                bdb_nwkJoiningFormation(FALSE);
   \   000023                ; Setup parameters for call to function bdb_nwkJoiningFormation
   \   000023   F9           MOV       R1,A
   \   000024   12....       LCALL     `??bdb_nwkJoiningFormation::?relay`; Banked call to: bdb_nwkJoiningFormation
   \   000027   8007         SJMP      ??bdb_nwkFormationAttempt_3
   1563              }
   1564              else
   1565              {
   1566                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_FORMATION, FALSE);
   \                     ??bdb_nwkFormationAttempt_2:
   \   000029                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000029   7A00         MOV       R2,#0x0
   \                     ??bdb_nwkFormationAttempt_1:
   \   00002B   7905         MOV       R1,#0x5
   \   00002D   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   1567              }
   1568            }
   1569          }
   \                     ??bdb_nwkFormationAttempt_3:
   \   000030   02....       LJMP      ?Subroutine0 & 0xFFFF
   1570          
   1571          
   1572          
   1573          /*********************************************************************
   1574           * @fn          bdb_isDeviceNonFactoryNew
   1575           *
   1576           * @brief       Returns the state of bdbNodeIsOnANetwork attribute
   1577           * 
   1578           * @param       none
   1579           *
   1580           * @return      bdbNodeIsOnANetwork
   1581           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1582          bool bdb_isDeviceNonFactoryNew(void)
   \                     bdb_isDeviceNonFactoryNew:
   1583          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1584            return bdbAttributes.bdbNodeIsOnANetwork;
   \   000004   90....       MOV       DPTR,#bdbAttributes + 14
   \   000007                REQUIRE ?Subroutine8
   \   000007                ; // Fall through to label ?Subroutine8
   1585          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX      A,@DPTR
   \   000001                REQUIRE ??Subroutine55_0
   \   000001                ; // Fall through to label ??Subroutine55_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine55_0:
   \   000000   F9           MOV       R1,A
   \   000001   02....       LJMP      ??Subroutine53_0 & 0xFFFF
   1586          
   1587          
   1588          /*********************************************************************
   1589           * @fn          bdb_doTrustCenterRequireKeyExchange
   1590           *
   1591           * @brief       Returns the state of bdbTrustCenterRequireKeyExchange attribute
   1592           * 
   1593           * @param       none
   1594           *
   1595           * @return      bdbTrustCenterRequireKeyExchange
   1596           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1597          bool bdb_doTrustCenterRequireKeyExchange(void)
   \                     bdb_doTrustCenterRequireKeyExchange:
   1598          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1599          #if (ZG_BUILD_COORDINATOR_TYPE) 
   1600            return bdbAttributes.bdbTrustCenterRequireKeyExchange;
   \   000004   90....       MOV       DPTR,#bdbAttributes + 17
   \   000007   80..         SJMP      ?Subroutine8
   1601          #else
   1602            return 0;
   1603          #endif
   1604          }
   1605          
   1606          /*********************************************************************
   1607           * @fn      bdb_rejoinNwk
   1608           *
   1609           * @brief   Attempt to rejoin/resume a nwk from nv parameters
   1610           *
   1611           * @param   none
   1612           *
   1613           * @return  ZStatus_t
   1614           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1615          ZStatus_t bdb_rejoinNwk(void)
   \                     bdb_rejoinNwk:
   1616          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1617            ZStatus_t rejoinStatus = ZSuccess;
   \   00000A   7E00         MOV       R6,#0x0
   1618            
   1619            // Transition state machine to correct rejoin state based on nwk key
   1620            if ( ZDApp_RestoreNwkKey( FALSE )== TRUE )
   \   00000C                ; Setup parameters for call to function ZDApp_RestoreNwkKey
   \   00000C   7900         MOV       R1,#0x0
   \   00000E   12....       LCALL     `??ZDApp_RestoreNwkKey::?relay`; Banked call to: ZDApp_RestoreNwkKey
   \   000011   E9           MOV       A,R1
   \   000012   6401         XRL       A,#0x1
   \   000014   7004         JNZ       ??bdb_rejoinNwk_0
   1621            {
   1622              ZDApp_ChangeState( DEV_NWK_SEC_REJOIN_CURR_CHANNEL );
   \   000016                ; Setup parameters for call to function ZDApp_ChangeState
   \   000016   7904         MOV       R1,#0x4
   \   000018   8002         SJMP      ??bdb_rejoinNwk_1
   1623            }
   1624            else
   1625            {
   1626              ZDApp_ChangeState( DEV_NWK_TC_REJOIN_CURR_CHANNEL );
   \                     ??bdb_rejoinNwk_0:
   \   00001A                ; Setup parameters for call to function ZDApp_ChangeState
   \   00001A   790E         MOV       R1,#0xe
   \                     ??bdb_rejoinNwk_1:
   \   00001C   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1627            }
   1628          
   1629            // Before trying to do rejoin, check if the device has a valid short address
   1630            // If not, generate a random short address for itself
   1631            if ( _NIB.nwkDevAddress == INVALID_NODE_ADDR )
   \   00001F   90....       MOV       DPTR,#_NIB + 20
   \   000022   E0           MOVX      A,@DPTR
   \   000023   64FE         XRL       A,#0xfe
   \   000025   7003         JNZ       ??bdb_rejoinNwk_2
   \   000027   A3           INC       DPTR
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F4           CPL       A
   \                     ??bdb_rejoinNwk_2:
   \   00002A   7002         JNZ       ??bdb_rejoinNwk_3
   1632            {
   1633              rejoinStatus = ZFailure;
   \   00002C   7E01         MOV       R6,#0x1
   1634            }
   1635          
   1636            // Check if the device has a valid PanID, if not, set it to the discovered Pan
   1637            if ( _NIB.nwkPanId == 0xFFFF )
   \                     ??bdb_rejoinNwk_3:
   \   00002E   90....       MOV       DPTR,#_NIB + 33
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F4           CPL       A
   \   000033   7003         JNZ       ??bdb_rejoinNwk_4
   \   000035   A3           INC       DPTR
   \   000036   E0           MOVX      A,@DPTR
   \   000037   F4           CPL       A
   \                     ??bdb_rejoinNwk_4:
   \   000038   7004         JNZ       ??bdb_rejoinNwk_5
   1638            {
   1639              rejoinStatus = ZFailure;
   \   00003A   7E01         MOV       R6,#0x1
   \   00003C   803A         SJMP      ??bdb_rejoinNwk_6
   1640            }
   1641          
   1642            if(rejoinStatus == ZSuccess)
   \                     ??bdb_rejoinNwk_5:
   \   00003E   EE           MOV       A,R6
   \   00003F   A2E0         MOV       C,0xE0 /* A   */.0
   \   000041   4035         JC        ??bdb_rejoinNwk_6
   1643            {
   1644              uint8 tmp = true;
   \   000043   85..82       MOV       DPL,?XSP + 0
   \   000046   85..83       MOV       DPH,?XSP + 1
   \   000049   7401         MOV       A,#0x1
   \   00004B   F0           MOVX      @DPTR,A
   1645              ZMacSetReq( ZMacRxOnIdle, &tmp ); // Set receiver always on during rejoin
   \   00004C                ; Setup parameters for call to function ZMacSetReq
   \   00004C   AA..         MOV       R2,?XSP + 0
   \   00004E   AB..         MOV       R3,?XSP + 1
   \   000050   7952         MOV       R1,#0x52
   \   000052   12....       LCALL     `??ZMacSetReq::?relay`; Banked call to: ZMacSetReq
   1646                  
   1647              // Perform Secure or Unsecure Rejoin depending on available configuration
   1648              if ( ZG_SECURE_ENABLED && ( ZDApp_RestoreNwkKey( TRUE ) == TRUE ) )
   \   000055                ; Setup parameters for call to function ZDApp_RestoreNwkKey
   \   000055   7901         MOV       R1,#0x1
   \   000057   12....       LCALL     `??ZDApp_RestoreNwkKey::?relay`; Banked call to: ZDApp_RestoreNwkKey
   \   00005A   E9           MOV       A,R1
   \   00005B   6401         XRL       A,#0x1
   \   00005D   90....       MOV       DPTR,#_NIB + 22
   \   000060   700B         JNZ       ??bdb_rejoinNwk_7
   1649              {
   1650                rejoinStatus = NLME_ReJoinRequest( ZDO_UseExtendedPANID, _NIB.nwkLogicalChannel);
   \   000062                ; Setup parameters for call to function NLME_ReJoinRequest
   \   000062   E0           MOVX      A,@DPTR
   \   000063   F9           MOV       R1,A
   \   000064   7A..         MOV       R2,#ZDO_UseExtendedPANID & 0xff
   \   000066   7B..         MOV       R3,#(ZDO_UseExtendedPANID >> 8) & 0xff
   \   000068   12....       LCALL     `??NLME_ReJoinRequest::?relay`; Banked call to: NLME_ReJoinRequest
   \   00006B   8009         SJMP      ??bdb_rejoinNwk_8
   1651              }
   1652              else
   1653              {
   1654                rejoinStatus = NLME_ReJoinRequestUnsecure( ZDO_UseExtendedPANID, _NIB.nwkLogicalChannel);
   \                     ??bdb_rejoinNwk_7:
   \   00006D                ; Setup parameters for call to function NLME_ReJoinRequestUnsecure
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   F9           MOV       R1,A
   \   00006F   7A..         MOV       R2,#ZDO_UseExtendedPANID & 0xff
   \   000071   7B..         MOV       R3,#(ZDO_UseExtendedPANID >> 8) & 0xff
   \   000073   12....       LCALL     `??NLME_ReJoinRequestUnsecure::?relay`; Banked call to: NLME_ReJoinRequestUnsecure
   \                     ??bdb_rejoinNwk_8:
   \   000076   E9           MOV       A,R1
   \   000077   FE           MOV       R6,A
   1655              }
   1656            }
   1657            
   1658            return rejoinStatus;
   \                     ??bdb_rejoinNwk_6:
   \   000078   EE           MOV       A,R6
   \   000079   F9           MOV       R1,A
   \   00007A   7401         MOV       A,#0x1
   \   00007C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007F                REQUIRE ?Subroutine0
   \   00007F                ; // Fall through to label ?Subroutine0
   1659          }
   1660          
   1661          #if (ZG_BUILD_JOINING_TYPE)
   1662           /*********************************************************************
   1663           * @fn          bdb_nwkDiscoveryAttempt
   1664           *
   1665           * @brief       Process a nwk discovery attempt
   1666           *
   1667           * @param       didSuccess - TRUE we found nwk in the scanned channels, FALSE if 
   1668           *                           no suitable nwks were found, try secondary channel
   1669           *
   1670           * @return      none
   1671           */
   1672          void bdb_nwkDiscoveryAttempt(bool didSuccess)
   1673          {
   1674            uint8 bdbJoinEvent = BDB_JOIN_EVENT_NWK_DISCOVERY;
   1675            
   1676            if(didSuccess)
   1677            {
   1678              bdb_SendMsg(bdb_TaskID, BDB_COMMISSIONING_STATE_JOINING, BDB_MSG_EVENT_SUCCESS,sizeof(bdbJoinEvent),(uint8*)&bdbJoinEvent);
   1679            }
   1680            else
   1681            {
   1682              //Can we try the secondary channel set?
   1683              if((vDoPrimaryScan) && (bdbAttributes.bdbSecondaryChannelSet))
   1684              {
   1685                vDoPrimaryScan = FALSE;
   1686                bdb_setChannel(bdbAttributes.bdbSecondaryChannelSet);
   1687                
   1688                ZDApp_NetworkInit( 50 );
   1689              }
   1690              else
   1691              {
   1692                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_JOINING, FALSE);
   1693              }
   1694            }
   1695          }
   1696          
   1697           /*********************************************************************
   1698           * @fn          bdb_filterNwkDisc
   1699           *
   1700           * @brief       Filter the nwks found and attempt to join the suitable nwks
   1701           *              Here the application can include nwk filters 
   1702           *
   1703           * @param       none
   1704           *
   1705           * @return      none
   1706           */
   1707          void bdb_filterNwkDisc(void)
   1708          {
   1709            networkDesc_t* pNwkDesc;
   1710            uint8 i = 0;
   1711            uint8 ResultCount = 0;
   1712            uint8 stackProfile = 0;
   1713            uint8 stackProfilePro = 0;
   1714            
   1715            pBDBListNwk  = nwk_getNwkDescList();
   1716            nwk_desc_list_release();
   1717            
   1718            pNwkDesc = pBDBListNwk;
   1719            while (pNwkDesc)
   1720            {
   1721              ResultCount++;
   1722              pNwkDesc = pNwkDesc->nextDesc;
   1723            }
   1724            
   1725            if(pBDBListNwk)
   1726            {
   1727              if(pfnFilterNwkDesc)
   1728              {
   1729                pfnFilterNwkDesc(pBDBListNwk, ResultCount);
   1730              }
   1731              
   1732              for ( stackProfile = 0; stackProfile < STACK_PROFILE_MAX; stackProfile++ )
   1733              {
   1734                pNwkDesc = pBDBListNwk;
   1735                
   1736                if(pNwkDesc)
   1737                {
   1738                  for ( i = 0; i < ResultCount; i++, pNwkDesc = pNwkDesc->nextDesc )
   1739                  {
   1740                    if ( nwk_ExtPANIDValid( ZDO_UseExtendedPANID ) == true )
   1741                    {
   1742                      // If the extended Pan ID is commissioned to a non zero value
   1743                      // Only join the Pan that has match EPID
   1744                      if ( osal_ExtAddrEqual( ZDO_UseExtendedPANID, pNwkDesc->extendedPANID) == false )
   1745                      {
   1746                        //Remove from the list
   1747                        bdb_nwkDescFree(pNwkDesc);
   1748                        ResultCount--;
   1749                        continue;
   1750                      }
   1751                    }
   1752                    else if ( zgConfigPANID != 0xFFFF )
   1753                    {
   1754                      // PAN Id is preconfigured. check if it matches
   1755                      if ( pNwkDesc->panId != zgConfigPANID )
   1756                      {
   1757                        //Remove from the list
   1758                        bdb_nwkDescFree(pNwkDesc);
   1759                        ResultCount--;
   1760                        continue;
   1761                      }
   1762                    }
   1763          
   1764                    if ( pNwkDesc->chosenRouter != _NIB.nwkCoordAddress || _NIB.nwkCoordAddress == INVALID_NODE_ADDR )
   1765                    {
   1766                      // check that network is allowing joining
   1767                      if ( ZSTACK_ROUTER_BUILD )
   1768                      {
   1769                        if ( stackProfilePro == FALSE )
   1770                        {
   1771                          if ( !pNwkDesc->routerCapacity )
   1772                          {
   1773                            //Remove from the list
   1774                            bdb_nwkDescFree(pNwkDesc);
   1775                            ResultCount--;
   1776                            continue;
   1777                          }
   1778                        }
   1779                        else
   1780                        {
   1781                          if ( !pNwkDesc->deviceCapacity )
   1782                          {
   1783                            //Remove from the list
   1784                            bdb_nwkDescFree(pNwkDesc);
   1785                            ResultCount--;
   1786                            continue;
   1787                          }
   1788                        }
   1789                      }
   1790                      else if ( ZSTACK_END_DEVICE_BUILD )
   1791                      {
   1792                        if ( !pNwkDesc->deviceCapacity )
   1793                        {
   1794                          //Remove from the list
   1795                          bdb_nwkDescFree(pNwkDesc);
   1796                          ResultCount--;
   1797                          continue;
   1798                        }
   1799                      }
   1800                    }
   1801          
   1802                    // check version of zigbee protocol
   1803                    if ( pNwkDesc->version != _NIB.nwkProtocolVersion )
   1804                      continue;
   1805          
   1806                    // check version of stack profile
   1807                    if ( pNwkDesc->stackProfile != zgStackProfile  )
   1808                    {
   1809                      if ( ((zgStackProfile == HOME_CONTROLS) && (pNwkDesc->stackProfile == ZIGBEEPRO_PROFILE))
   1810                          || ((zgStackProfile == ZIGBEEPRO_PROFILE) && (pNwkDesc->stackProfile == HOME_CONTROLS))  )
   1811                      {
   1812                        stackProfilePro = TRUE;
   1813                      }
   1814          
   1815                      if ( stackProfile == 0 )
   1816                      {
   1817                        //Remove from the list
   1818                        bdb_nwkDescFree(pNwkDesc);
   1819                        ResultCount--;
   1820                        continue;
   1821                      }
   1822                    }
   1823                  }
   1824                }
   1825              }
   1826            }
   1827          }
   1828                
   1829           /*********************************************************************
   1830           * @fn          bdb_tryNwkAssoc
   1831           *
   1832           * @brief       Try to associate to the first network in the network descriptor list
   1833           *
   1834           * @param       none
   1835           *
   1836           * @return      none
   1837           */
   1838          static void bdb_tryNwkAssoc(void)
   1839          {
   1840            if(pBDBListNwk)
   1841            {
   1842              bdbCommissioningProcedureState.bdbJoinState = BDB_JOIN_STATE_ASSOC;
   1843              
   1844              //Try the first in the list after the filtering
   1845              if(ZSuccess != bdb_joinProcess(pBDBListNwk))
   1846              {
   1847                //If fail, free the first in the list and prepare for futher processing, either next nwk or discover again
   1848                uint8 bdbJoinEvent = BDB_JOIN_EVENT_ASSOCIATION;
   1849                bdb_nwkDescFree(pBDBListNwk);
   1850                bdb_SendMsg(bdb_TaskID,BDB_COMMISSIONING_STATE_JOINING,BDB_MSG_EVENT_FAIL,sizeof(uint8),&bdbJoinEvent);
   1851              }
   1852            }
   1853            else
   1854            {
   1855              bdbCommissioningProcedureState.bdbJoinState = BDB_JOIN_STATE_NWK_DISC;
   1856              uint8 bdbJoinEvent = BDB_JOIN_EVENT_NWK_DISCOVERY;
   1857              
   1858              bdb_SendMsg(bdb_TaskID,BDB_COMMISSIONING_STATE_JOINING,BDB_MSG_EVENT_FAIL,sizeof(uint8),&bdbJoinEvent);
   1859            }
   1860          }
   1861          
   1862          
   1863          
   1864           /*********************************************************************
   1865           * @fn          bdb_nwkAssocAttemt
   1866           *
   1867           * @brief       Process the result of an attempt to associate to a network 
   1868           *
   1869           * @param       didSuccess - bool
   1870           *
   1871           * @return      none
   1872           */
   1873          void bdb_nwkAssocAttemt(bool didSuccess)
   1874          {
   1875            bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_STATE_JOINING;
   1876            uint8 bdbJoinEvent = BDB_JOIN_EVENT_ASSOCIATION;
   1877            uint8 status;
   1878            
   1879            if(didSuccess)
   1880            {
   1881              status = BDB_MSG_EVENT_SUCCESS;
   1882            }
   1883            else
   1884            {
   1885              if(bdb_nwkAssocRetriesCount < BDBC_REC_SAME_NETWORK_RETRY_ATTEMPS)
   1886              {
   1887                bdb_nwkAssocRetriesCount++;
   1888              }
   1889              else
   1890              {
   1891                //Free the first in the list and prepare for futher processing
   1892                bdb_nwkDescFree(pBDBListNwk);
   1893                bdb_nwkAssocRetriesCount = 0;
   1894              }
   1895              status = BDB_MSG_EVENT_FAIL;
   1896            }
   1897            bdb_SendMsg(bdb_TaskID,BDB_COMMISSIONING_STATE_JOINING,status,sizeof(uint8),&bdbJoinEvent);
   1898          }
   1899                                 
   1900          
   1901          /****************************************************************************
   1902           * @fn          bdb_nwkDescFree
   1903           *
   1904           * @brief       This function frees one network discovery data.
   1905           *
   1906           * @param       ZSuccess - If the device was found and erased
   1907           * @param       ZInvalidParameter - Not found
   1908           *
   1909           * @return      none
   1910           */
   1911          ZStatus_t bdb_nwkDescFree(networkDesc_t* nodeDescToRemove)
   1912          {
   1913            networkDesc_t* current_desc;
   1914            networkDesc_t* prev_desc;
   1915            
   1916            current_desc = pBDBListNwk;
   1917          
   1918            while(current_desc != NULL)
   1919            {  
   1920              if(current_desc == nodeDescToRemove)
   1921              {
   1922                if (current_desc == pBDBListNwk)
   1923                {
   1924                  pBDBListNwk = pBDBListNwk->nextDesc;
   1925                }
   1926                else
   1927                {
   1928                  prev_desc->nextDesc = current_desc->nextDesc;
   1929                }
   1930                
   1931                osal_mem_free( current_desc );
   1932                
   1933                return ZSuccess;
   1934              }
   1935          
   1936              prev_desc = current_desc;
   1937              current_desc = current_desc->nextDesc;
   1938            }
   1939            
   1940            return ZInvalidParameter;
   1941          }
   1942          
   1943          /*********************************************************************
   1944          * @fn          bdb_joinProcess
   1945          *
   1946          * @brief       Start the joining process for the selected nwk
   1947          *
   1948          * @return      ZStatus_t
   1949          */  
   1950          ZStatus_t bdb_joinProcess(networkDesc_t *pChosenNwk)
   1951          {
   1952            ZStatus_t status;
   1953           
   1954            ZDApp_ChangeState( DEV_NWK_JOINING );
   1955            ZDApp_NodeProfileSync( pChosenNwk->stackProfile);
   1956          
   1957            status =  NLME_JoinRequest( pChosenNwk->extendedPANID, pChosenNwk->panId,
   1958                                  pChosenNwk->logicalChannel,
   1959                                  ZDO_Config_Node_Descriptor.CapabilityFlags,
   1960                                  pChosenNwk->chosenRouter, pChosenNwk->chosenRouterDepth );
   1961            
   1962            if(status == ZSuccess)
   1963            {
   1964              // The receiver is on, turn network layer polling off.
   1965              if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   1966              {
   1967                // for an End Device with NO Child Table Management process or for a Router
   1968                if ( ( ZG_DEVICE_RTR_TYPE )  ||
   1969                     ( (ZG_DEVICE_ENDDEVICE_TYPE) && ( zgChildAgingEnable == FALSE ) ) )
   1970                {
   1971                  NLME_SetPollRate( 0 );
   1972                  NLME_SetQueuedPollRate( 0 );
   1973                  NLME_SetResponseRate( 0 );
   1974                }
   1975              }
   1976              else
   1977              {
   1978                if ( (ZG_SECURE_ENABLED) && (devStartMode == MODE_JOIN) )
   1979                {
   1980                  ZDApp_SavedPollRate = zgPollRate;
   1981                  NLME_SetPollRate( zgRejoinPollRate );
   1982                }
   1983              }
   1984            }
   1985            return status;
   1986          }
   1987          #endif
   1988          
   1989          
   1990           /*********************************************************************
   1991           * @fn          bdb_setChannelAttribute
   1992           *
   1993           * @brief       Set the primary or seconday channel for discovery or formation procedure
   1994           *
   1995           * @param       isPrimaryChannel - True if channel to set is primary,  
   1996           *                                 False if the channel to set is secondary
   1997           *
   1998           * @param       channel - Channel mask
   1999           *
   2000           * @return      none
   2001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2002          void bdb_setChannelAttribute(bool isPrimaryChannel, uint32 channel)
   \                     bdb_setChannelAttribute:
   2003          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   8C..         MOV       ?V2,R4
   \   00000B   8D..         MOV       ?V3,R5
   2004            if(isPrimaryChannel)
   \   00000D   E9           MOV       A,R1
   \   00000E   6005         JZ        ??bdb_setChannelAttribute_0
   2005            {
   2006              bdbAttributes.bdbPrimaryChannelSet = channel;
   \   000010   90....       MOV       DPTR,#bdbAttributes + 4
   \   000013   8003         SJMP      ??bdb_setChannelAttribute_1
   2007            }
   2008            else
   2009            {
   2010              bdbAttributes.bdbSecondaryChannelSet = channel;
   \                     ??bdb_setChannelAttribute_0:
   \   000015   90....       MOV       DPTR,#bdbAttributes
   \                     ??bdb_setChannelAttribute_1:
   \   000018   78..         MOV       R0,#?V0
   \   00001A   12....       LCALL     ?L_MOV_TO_X
   2011            }
   2012          }
   \   00001D   80..         SJMP      ??Subroutine57_0
   2013          
   2014           /*********************************************************************
   2015           * @fn          bdb_setChannel
   2016           *
   2017           * @brief       Set channel and save it in Nv for joining/formation operations
   2018           *
   2019           * @param       channel - Channel mask
   2020           *
   2021           * @return      none
   2022           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7404         MOV       A,#0x4
   \   000002                REQUIRE ??Subroutine56_0
   \   000002                ; // Fall through to label ??Subroutine56_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2023          void bdb_setChannel(uint32 channel)
   \                     bdb_setChannel:
   2024          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   8C..         MOV       ?V2,R4
   \   00000B   8D..         MOV       ?V3,R5
   2025            //Assign the channel and save it into nv
   2026            vScanChannels = channel;
   \   00000D   90....       MOV       DPTR,#zgDefaultChannelList
   \   000010   78..         MOV       R0,#?V0
   \   000012   12....       LCALL     ?L_MOV_TO_X
   2027            runtimeChannel = channel;
   \   000015   90....       MOV       DPTR,#runtimeChannel
   \   000018   78..         MOV       R0,#?V0
   \   00001A   12....       LCALL     ?L_MOV_TO_X
   2028              
   2029            osal_nv_write(ZCD_NV_CHANLIST,0,sizeof(uint32),&vScanChannels);
   \   00001D                ; Setup parameters for call to function osal_nv_write
   \   00001D   75....       MOV       ?V0,#zgDefaultChannelList & 0xff
   \   000020   75....       MOV       ?V1,#(zgDefaultChannelList >> 8) & 0xff
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000028   75..04       MOV       ?V0,#0x4
   \   00002B   75..00       MOV       ?V1,#0x0
   \   00002E   78..         MOV       R0,#?V0
   \   000030   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000033   7C00         MOV       R4,#0x0
   \   000035   7D00         MOV       R5,#0x0
   \   000037   7A84         MOV       R2,#-0x7c
   \   000039   7B00         MOV       R3,#0x0
   \   00003B   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00003E   80..         SJMP      ?Subroutine2
   2030          }
   2031          
   2032          
   2033           /*********************************************************************
   2034           * @fn          bdb_nwkJoiningFormation   
   2035           *
   2036           * @brief       Performs Joining/Formation operation on primary or secondary channel
   2037           *
   2038           * @param       isJoining - TRUE if the device is performing joining, FALSE is performing Formation
   2039           *
   2040           * @return      none
   2041           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2042          void bdb_nwkJoiningFormation(bool isJoining)
   \                     bdb_nwkJoiningFormation:
   2043          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   2044            
   2045            if((vDoPrimaryScan) && (bdbAttributes.bdbPrimaryChannelSet))
   \   000007   90....       MOV       DPTR,#vDoPrimaryScan
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   601C         JZ        ??bdb_nwkJoiningFormation_0
   \   00000D   90....       MOV       DPTR,#bdbAttributes + 4
   \   000010   78..         MOV       R0,#?V0
   \   000012   12....       LCALL     ?L_MOV_X
   \   000015   E5..         MOV       A,?V0
   \   000017   45..         ORL       A,?V1
   \   000019   45..         ORL       A,?V2
   \   00001B   45..         ORL       A,?V3
   \   00001D   600A         JZ        ??bdb_nwkJoiningFormation_0
   2046            {
   2047              bdb_setChannel(bdbAttributes.bdbPrimaryChannelSet);
   \   00001F                ; Setup parameters for call to function bdb_setChannel
   \   00001F   AA..         MOV       R2,?V0
   \   000021   AB..         MOV       R3,?V1
   \   000023   AC..         MOV       R4,?V2
   \   000025   AD..         MOV       R5,?V3
   \   000027   800B         SJMP      ??bdb_nwkJoiningFormation_1
   2048            }
   2049            else
   2050            {
   2051              vDoPrimaryScan = FALSE;
   \                     ??bdb_nwkJoiningFormation_0:
   \   000029   90....       MOV       DPTR,#vDoPrimaryScan
   \   00002C   E4           CLR       A
   \   00002D   F0           MOVX      @DPTR,A
   2052              bdb_setChannel(bdbAttributes.bdbSecondaryChannelSet);
   \   00002E                ; Setup parameters for call to function bdb_setChannel
   \   00002E   90....       MOV       DPTR,#bdbAttributes
   \   000031   12....       LCALL     ?XLOAD_R2345
   \                     ??bdb_nwkJoiningFormation_1:
   \   000034   12....       LCALL     `??bdb_setChannel::?relay`; Banked call to: bdb_setChannel
   2053            }
   2054          
   2055            if(vScanChannels)
   \   000037   90....       MOV       DPTR,#zgDefaultChannelList
   \   00003A   12....       LCALL     ?XLOAD_R0123
   \   00003D   E8           MOV       A,R0
   \   00003E   49           ORL       A,R1
   \   00003F   4A           ORL       A,R2
   \   000040   4B           ORL       A,R3
   \   000041   601A         JZ        ??bdb_nwkJoiningFormation_2
   2056            {
   2057              if(ZG_DEVICE_RTRONLY_TYPE)
   \   000043   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000046   E0           MOVX      A,@DPTR
   \   000047   6401         XRL       A,#0x1
   \   000049   7007         JNZ       ??bdb_nwkJoiningFormation_3
   2058              {
   2059                if(isJoining)
   \   00004B   EE           MOV       A,R6
   \   00004C   7004         JNZ       ??bdb_nwkJoiningFormation_3
   2060                {
   2061                  ZDOInitDeviceEx(100,0);
   2062                }
   2063                else
   2064                {
   2065                  ZDOInitDeviceEx(100,1);
   \   00004E                ; Setup parameters for call to function ZDOInitDeviceEx
   \   00004E   7901         MOV       R1,#0x1
   \   000050   8002         SJMP      ??bdb_nwkJoiningFormation_4
   2066                }
   2067              }
   2068              //ZED can only join, and ZC can only create
   2069              else
   2070              {
   2071                ZDOInitDeviceEx(100,0);
   \                     ??bdb_nwkJoiningFormation_3:
   \   000052                ; Setup parameters for call to function ZDOInitDeviceEx
   \   000052   7900         MOV       R1,#0x0
   \                     ??bdb_nwkJoiningFormation_4:
   \   000054   7A64         MOV       R2,#0x64
   \   000056   7B00         MOV       R3,#0x0
   \   000058   12....       LCALL     `??ZDOInitDeviceEx::?relay`; Banked call to: ZDOInitDeviceEx
   \   00005B   800E         SJMP      ??bdb_nwkJoiningFormation_5
   2072              }
   2073            }
   2074            else
   2075            {
   2076              if(isJoining)
   \                     ??bdb_nwkJoiningFormation_2:
   \   00005D   EE           MOV       A,R6
   \   00005E   7A00         MOV       R2,#0x0
   \   000060   6004         JZ        ??bdb_nwkJoiningFormation_6
   2077              {
   2078                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_JOINING, FALSE);
   \   000062                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000062   7903         MOV       R1,#0x3
   \   000064   8002         SJMP      ??bdb_nwkJoiningFormation_7
   2079              }
   2080              else
   2081              {
   2082                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_FORMATION, FALSE);
   \                     ??bdb_nwkJoiningFormation_6:
   \   000066                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000066   7905         MOV       R1,#0x5
   \                     ??bdb_nwkJoiningFormation_7:
   \   000068   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2083              }
   2084            }
   2085          }
   \                     ??bdb_nwkJoiningFormation_5:
   \   00006B   02....       LJMP      ??Subroutine57_0 & 0xFFFF
   2086          
   2087          #if (ZG_BUILD_JOINING_TYPE)
   2088           /*********************************************************************
   2089           * @fn          bdb_tcLinkKeyExchangeAttempt
   2090           *
   2091           * @brief       Generic send msg for TC link key exchange process attempts
   2092           *
   2093           * @param       didSuccess - FALSE if the step failed/timeout, TRUE otherwise
   2094           * @param       bdbTCExchangeState - Step in which the attemp was done
   2095           *
   2096           * @return      none
   2097           */
   2098          void bdb_tcLinkKeyExchangeAttempt(bool didSuccess, uint8 bdbTCExchangeState)
   2099          {
   2100            bool bdbEventStatus = BDB_MSG_EVENT_SUCCESS;
   2101            uint8 dummy;
   2102            bdbCommissioningProcedureState.bdbTCExchangeState = bdbTCExchangeState;
   2103            if(didSuccess)
   2104            {
   2105              //Allow try since we are performing a new step.
   2106              osal_stop_timerEx(bdb_TaskID, BDB_PROCESS_TIMEOUT);
   2107              bdbAttributes.bdbTCLinkKeyExchangeAttempts = 0;
   2108            }
   2109            else
   2110            {
   2111              bdbEventStatus = BDB_MSG_EVENT_FAIL;
   2112            }
   2113            bdb_SendMsg(bdb_TaskID,BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE,bdbEventStatus,1, &dummy);
   2114          }
   2115          
   2116          
   2117           /*********************************************************************
   2118           * @fn          bdb_requestVerifyTCLinkKey
   2119           *
   2120           * @brief       Attempt to verify the TC link key by sending Verify Key Request
   2121           *
   2122           * @param       none
   2123           *
   2124           * @return      none
   2125           */
   2126          void bdb_requestVerifyTCLinkKey(void)
   2127          {
   2128              uint8 TC_ExtAddr[Z_EXTADDR_LEN];
   2129              APSME_VerifyKeyReq_t vKey;
   2130              
   2131              APSME_GetRequest( apsTrustCenterAddress,0, TC_ExtAddr );
   2132              
   2133              vKey.tcExtAddr = TC_ExtAddr;
   2134              vKey.keyType = KEY_TYPE_TC_LINK;
   2135              
   2136              APSME_VerifyKeyReq( &vKey );
   2137              
   2138              osal_stop_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT);
   2139              osal_start_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT,BDBC_TC_LINK_KEY_EXANGE_TIMEOUT);
   2140              
   2141          }
   2142          
   2143          /*********************************************************************
   2144           * @fn          bdb_requestTCLinkKey
   2145           *
   2146           * @brief       Attempt to request a TC link key
   2147           *
   2148           * @param       none
   2149           *
   2150           * @return      none
   2151           */
   2152          void bdb_requestTCLinkKey(void)
   2153          {
   2154            zAddrType_t destAddr;
   2155            APSME_RequestKeyReq_t req;
   2156          
   2157            destAddr.addrMode = Addr16Bit;
   2158            destAddr.addr.shortAddr = 0x0000;
   2159            
   2160            req.dstAddr = destAddr.addr.shortAddr;
   2161            req.keyType = KEY_TYPE_TC_LINK;
   2162            
   2163            APSME_RequestKeyReq(&req);
   2164            
   2165            osal_stop_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT);
   2166            
   2167            osal_start_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT,(uint32)requestLinkKeyTimeout);
   2168          } 
   2169          
   2170          
   2171          /*********************************************************************
   2172           * @fn          bdb_requestTCStackVersion
   2173           *
   2174           * @brief       Attempt to request the TC stack version using ZDP Node desc if 
   2175           *              join a Centralized nwk
   2176           *
   2177           * @param       none
   2178           *
   2179           * @return      none
   2180           */
   2181          void bdb_requestTCStackVersion(void)
   2182          {
   2183            if(requestNewTrustCenterLinkKey)
   2184            {
   2185              if(!APSME_IsDistributedSecurity())
   2186              {
   2187                if(bdbAttributes.bdbTCLinkKeyExchangeMethod == BDB_TC_LINK_KEY_EXCHANGE_APS_KEY)
   2188                {
   2189                  zAddrType_t destAddr;
   2190                 
   2191                  destAddr.addrMode = Addr16Bit;
   2192                  destAddr.addr.shortAddr = 0x0000;
   2193                 
   2194                  ZDP_NodeDescReq( &destAddr, destAddr.addr.shortAddr, 0);  
   2195                  
   2196                  osal_stop_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT);
   2197                  osal_start_timerEx( bdb_TaskID, BDB_PROCESS_TIMEOUT, BDBC_TC_LINK_KEY_EXANGE_TIMEOUT );
   2198                  return;
   2199                }
   2200                else
   2201                {
   2202                  if(pfnCBKETCLinkKeyExchange)
   2203                  {
   2204                    pfnCBKETCLinkKeyExchange();
   2205                  }
   2206                  return;
   2207                }
   2208              }
   2209              else
   2210              {
   2211                bdb_setNodeJoinLinkKeyType(BDB_DISTRIBUTED_SECURITY_GLOBAL_LINK_KEY);
   2212              }
   2213            }
   2214            else
   2215            {
   2216              //Key not required, set default which is global
   2217              bdb_setNodeJoinLinkKeyType(BDB_DEFAULT_GLOBAL_TRUST_CENTER_LINK_KEY);
   2218            }
   2219            //TC link key not required or join distributed nwk
   2220            bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE,TRUE);
   2221          }
   2222          #endif
   2223          
   2224          
   2225          /*********************************************************************
   2226           * @fn          bdb_nwkSteeringDeviceOnNwk
   2227           *
   2228           * @brief       Send ZDP mgmt permit joining
   2229           *
   2230           * @param       none
   2231           *
   2232           * @return      none
   2233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2234          void bdb_nwkSteeringDeviceOnNwk(void)
   \                     bdb_nwkSteeringDeviceOnNwk:
   2235          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 9
   \   000004   74F7         MOV       A,#-0x9
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2236            zAddrType_t dstAddr;
   2237            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVZCZR;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   74FC         MOV       A,#-0x4
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   74FF         MOV       A,#-0x1
   \   000015   F0           MOVX      @DPTR,A
   2238            dstAddr.addrMode = AddrBroadcast;
   \   000016   7408         MOV       A,#0x8
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   740F         MOV       A,#0xf
   \   00001D   F0           MOVX      @DPTR,A
   2239            // Trust Center significance is always true
   2240            ZDP_MgmtPermitJoinReq( &dstAddr, BDBC_MIN_COMMISSIONING_TIME, TRUE, FALSE );
   \   00001E                ; Setup parameters for call to function ZDP_MgmtPermitJoinReq
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7C01         MOV       R4,#0x1
   \   000022   79B4         MOV       R1,#-0x4c
   \   000024   AA..         MOV       R2,?XSP + 0
   \   000026   AB..         MOV       R3,?XSP + 1
   \   000028   12....       LCALL     `??ZDP_MgmtPermitJoinReq::?relay`; Banked call to: ZDP_MgmtPermitJoinReq
   2241          }
   \   00002B   7409         MOV       A,#0x9
   \   00002D                REQUIRE ?Subroutine7
   \   00002D                ; // Fall through to label ?Subroutine7

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   02....       LJMP      ??Subroutine53_0 & 0xFFFF
   2242          
   2243          
   2244          /*********************************************************************
   2245           * @fn          bdb_startResumeCommissioningProcess
   2246           *
   2247           * @brief       Starts or resume the commissioning operations sets in the 
   2248           *              commissioningMode attribute
   2249           *
   2250           * @param       none
   2251           *
   2252           * @return      none
   2253           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   7403         MOV       A,#0x3
   \   000002                REQUIRE ??Subroutine51_0
   \   000002                ; // Fall through to label ??Subroutine51_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2254          void bdb_startResumeCommissioningProcess(void)
   \                     bdb_startResumeCommissioningProcess:
   2255          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV       A,#-0xb
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2256          
   2257          #if ( defined ( BDB_TL_INITIATOR ) && (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE) ) 
   2258            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_INITIATOR_TL)
   2259            {
   2260              uint16 nwkAddr;
   2261          
   2262              //Does the device supports this commissioning mode?
   2263              if(bdbAttributes.bdbNodeCommissioningCapability & BDB_TOUCHLINK_CAPABILITY)
   2264              {
   2265                //Clear previous state and substates
   2266                osal_memset(&bdbCommissioningProcedureState,0,sizeof(bdbCommissioningProcedureState));
   2267                bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_TL;
   2268                
   2269                // Get our short address
   2270                ZMacGetReq( ZMacShortAddress, (byte*)&nwkAddr );
   2271                if ( nwkAddr == INVALID_NODE_ADDR )
   2272                {
   2273                  initiatorSelectNwkParams();
   2274                }
   2275                
   2276                touchLinkInitiator_StartDevDisc( );  
   2277                
   2278                bdb_NotifyCommissioningModeStart(BDB_COMMISSIONING_TOUCHLINK);
   2279              }
   2280              else
   2281              {
   2282                //Process the next commissioning mode
   2283                bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
   2284              }
   2285              return;
   2286            }
   2287          #endif // BDB_TOUCHLINK_CAPABILITY_ENABLED  
   2288            
   2289          #if ZG_BUILD_ENDDEVICE_TYPE
   2290            if(ZG_DEVICE_ENDDEVICE_TYPE)
   2291            {
   2292              if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_PARENT_LOST)
   2293              {
   2294                //No commissioning process can be performed if the ZED has lost its parent
   2295                return;
   2296              }
   2297            }
   2298          #endif
   2299            
   2300            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_NWK_STEERING)
   \   00000A   90....       MOV       DPTR,#bdbAttributes + 11
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   A2E1         MOV       C,0xE0 /* A   */.1
   \   000010   5021         JNC       ??bdb_startResumeCommissioningProcess_0
   2301            {
   2302              bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_STEERING_ON_NWK;
   \   000012   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000015   7404         MOV       A,#0x4
   \   000017   F0           MOVX      @DPTR,A
   2303              
   2304              if(bdbAttributes.bdbNodeCommissioningCapability & BDB_NETWORK_STEERING_CAPABILITY)
   \   000018   90....       MOV       DPTR,#bdbAttributes + 12
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00001E   5010         JNC       ??bdb_startResumeCommissioningProcess_1
   2305              {
   2306          #if (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE)
   2307                bdb_ClearNetworkParams();
   2308          #endif
   2309                if(bdbAttributes.bdbNodeIsOnANetwork)
   \   000020   90....       MOV       DPTR,#bdbAttributes + 14
   \   000023   E0           MOVX      A,@DPTR
   \   000024   6003         JZ        ??CrossCallReturnLabel_39
   2310                {
   2311                  bdb_nwkSteeringDeviceOnNwk();
   \   000026                ; Setup parameters for call to function bdb_nwkSteeringDeviceOnNwk
   \   000026   12....       LCALL     ?Subroutine34 & 0xFFFF
   2312                  bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_STEERING_ON_NWK, TRUE);
   2313                }
   2314          #if (ZG_BUILD_JOINING_TYPE)
   2315                else
   2316                {
   2317                  if(ZG_DEVICE_JOINING_TYPE)
   2318                  {
   2319                    vDoPrimaryScan = TRUE;
   2320                    
   2321                    //Initialize the commissioning procedure state, bdbJoinState to nwk discovery and TCLinkKeyExchange to not active
   2322                    osal_memset(&bdbCommissioningProcedureState,0,sizeof(bdbCommissioningProcedureState_t));
   2323                    bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_JOINING;
   2324                    bdb_nwkJoiningFormation(TRUE);
   2325                    bdb_NotifyCommissioningModeStart(BDB_COMMISSIONING_NWK_STEERING);
   2326                  }
   2327                }
   2328          #endif
   2329          #if (ZG_BUILD_COORDINATOR_TYPE)
   2330                if(ZG_DEVICE_COORDINATOR_TYPE)
   2331                {
   2332                  bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_STEERING_ON_NWK, FALSE);
   \                     ??CrossCallReturnLabel_39:
   \   000029                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000029   7A00         MOV       R2,#0x0
   \   00002B   7904         MOV       R1,#0x4
   \   00002D   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2333                }
   2334          #endif
   2335              }
   2336              return;
   \                     ??bdb_startResumeCommissioningProcess_1:
   \   000030   02....       LJMP      ??bdb_startResumeCommissioningProcess_2 & 0xFFFF
   2337            }
   2338            
   2339            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_NWK_FORMATION)
   \                     ??bdb_startResumeCommissioningProcess_0:
   \   000033   A2E2         MOV       C,0xE0 /* A   */.2
   \   000035   5044         JNC       ??bdb_startResumeCommissioningProcess_3
   2340            {
   2341              bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_FORMATION;
   \   000037   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   00003A   7405         MOV       A,#0x5
   \   00003C   F0           MOVX      @DPTR,A
   2342              
   2343              if(bdbAttributes.bdbNodeCommissioningCapability & BDB_NETWORK_FORMATION_CAPABILITY)
   \   00003D   90....       MOV       DPTR,#bdbAttributes + 12
   \   000040   E0           MOVX      A,@DPTR
   \   000041   A2E1         MOV       C,0xE0 /* A   */.1
   \   000043   502C         JNC       ??bdb_startResumeCommissioningProcess_4
   2344              {
   2345                if(!bdbAttributes.bdbNodeIsOnANetwork)
   \   000045   90....       MOV       DPTR,#bdbAttributes + 14
   \   000048   E0           MOVX      A,@DPTR
   \   000049   7026         JNZ       ??bdb_startResumeCommissioningProcess_4
   2346                {
   2347          #if (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE)
   2348                bdb_ClearNetworkParams();
   2349          #endif
   2350                  vDoPrimaryScan = TRUE;
   \   00004B   90....       MOV       DPTR,#vDoPrimaryScan
   \   00004E   7401         MOV       A,#0x1
   \   000050   F0           MOVX      @DPTR,A
   2351                  
   2352                  osal_memset(&bdbCommissioningProcedureState,0,sizeof(bdbCommissioningProcedureState));
   \   000051                ; Setup parameters for call to function osal_memset
   \   000051   7C04         MOV       R4,#0x4
   \   000053   7D00         MOV       R5,#0x0
   \   000055   7900         MOV       R1,#0x0
   \   000057   7A..         MOV       R2,#bdbCommissioningProcedureState & 0xff
   \   000059   7B..         MOV       R3,#(bdbCommissioningProcedureState >> 8) & 0xff
   \   00005B   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2353                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_FORMATION;
   \   00005E   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000061   7405         MOV       A,#0x5
   \   000063   F0           MOVX      @DPTR,A
   2354          
   2355                  bdb_nwkJoiningFormation(FALSE);
   \   000064                ; Setup parameters for call to function bdb_nwkJoiningFormation
   \   000064   7900         MOV       R1,#0x0
   \   000066   12....       LCALL     `??bdb_nwkJoiningFormation::?relay`; Banked call to: bdb_nwkJoiningFormation
   2356                  bdb_NotifyCommissioningModeStart(BDB_COMMISSIONING_FORMATION);
   \   000069                ; Setup parameters for call to function bdb_NotifyCommissioningModeStart
   \   000069   7902         MOV       R1,#0x2
   \   00006B   12....       LCALL     `??bdb_NotifyCommissioningModeStart::?relay`; Banked call to: bdb_NotifyCommissioningModeStart
   2357                  return;
   \   00006E   02....       LJMP      ??bdb_startResumeCommissioningProcess_2 & 0xFFFF
   2358                }
   2359              }
   2360              bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_FORMATION, FALSE);
   \                     ??bdb_startResumeCommissioningProcess_4:
   \   000071                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000071   7A00         MOV       R2,#0x0
   \   000073   7905         MOV       R1,#0x5
   \   000075   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2361              return;
   \   000078   02....       LJMP      ??bdb_startResumeCommissioningProcess_2 & 0xFFFF
   2362            }
   2363          
   2364          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)    
   2365            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_FINDING_BINDING)
   \                     ??bdb_startResumeCommissioningProcess_3:
   \   00007B   A2E3         MOV       C,0xE0 /* A   */.3
   \   00007D   4003         JC        $+5
   \   00007F   02....       LJMP      ??bdb_startResumeCommissioningProcess_2 & 0xFFFF
   2366            {
   2367              bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_FINDING_BINDING;
   \   000082   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000085   7406         MOV       A,#0x6
   \   000087   F0           MOVX      @DPTR,A
   2368              
   2369              //Is the device on a network?
   2370              if(bdb_isDeviceNonFactoryNew())
   \   000088   90....       MOV       DPTR,#bdbAttributes + 14
   \   00008B   E0           MOVX      A,@DPTR
   \   00008C   7003         JNZ       $+5
   \   00008E   02....       LJMP      ??bdb_startResumeCommissioningProcess_5 & 0xFFFF
   2371              {
   2372                zclAttrRec_t attrRec;
   2373          
   2374                endPointDesc_t *bdb_CurrEpDescriptor = NULL;
   2375          
   2376                bdb_CurrEpDescriptor = bdb_setEpDescListToActiveEndpoint();
   \   000091                ; Setup parameters for call to function bdb_setEpDescListToActiveEndpoint
   \   000091   12....       LCALL     `??bdb_setEpDescListToActiveEndpoint::?relay`; Banked call to: bdb_setEpDescListToActiveEndpoint
   \   000094   8A..         MOV       ?V0,R2
   \   000096   8B..         MOV       ?V1,R3
   \   000098   AE..         MOV       R6,?V0
   \   00009A   AF..         MOV       R7,?V1
   2377                
   2378                //If not found endpoint with Identify cluster is found, then report fail
   2379                if(bdb_CurrEpDescriptor == NULL)
   \   00009C   EA           MOV       A,R2
   \   00009D   4F           ORL       A,R7
   \   00009E   7003         JNZ       $+5
   \   0000A0   02....       LJMP      ??bdb_startResumeCommissioningProcess_5 & 0xFFFF
   2380                {
   2381                  bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   \   0000A3                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   2382                  return;
   2383                }
   2384                
   2385                if( bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_TARGET)  //F&B as Target
   \   0000A3   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0000A6   A3           INC       DPTR
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   A2E1         MOV       C,0xE0 /* A   */.1
   \   0000AA   4003         JC        $+5
   \   0000AC   02....       LJMP      ??bdb_startResumeCommissioningProcess_6 & 0xFFFF
   2386                {
   2387                  if (zclFindAttrRec( bdb_CurrEpDescriptor->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2388                            ATTRID_IDENTIFY_TIME, &attrRec ) )
   \   0000AF                ; Setup parameters for call to function zclFindAttrRec
   \   0000AF   7403         MOV       A,#0x3
   \   0000B1   12....       LCALL     ?XSTACK_DISP100_8
   \   0000B4   88..         MOV       ?V0,R0
   \   0000B6   89..         MOV       ?V1,R1
   \   0000B8   78..         MOV       R0,#?V0
   \   0000BA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BD   7C00         MOV       R4,#0x0
   \   0000BF   7D00         MOV       R5,#0x0
   \   0000C1   7A03         MOV       R2,#0x3
   \   0000C3   7B00         MOV       R3,#0x0
   \   0000C5   8E82         MOV       DPL,R6
   \   0000C7   8F83         MOV       DPH,R7
   \   0000C9   E0           MOVX      A,@DPTR
   \   0000CA   F9           MOV       R1,A
   \   0000CB   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000CE   7402         MOV       A,#0x2
   \   0000D0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000D3   E9           MOV       A,R1
   \   0000D4   606C         JZ        ??bdb_startResumeCommissioningProcess_7
   2389                  {
   2390                    //Set it to at less 180 
   2391                    if ( *((uint16*)attrRec.attr.dataPtr) <= BDBC_MIN_COMMISSIONING_TIME )
   \   0000D6   7409         MOV       A,#0x9
   \   0000D8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DB   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0000DE   C3           CLR       C
   \   0000DF   E0           MOVX      A,@DPTR
   \   0000E0   94B5         SUBB      A,#-0x4b
   \   0000E2   A3           INC       DPTR
   \   0000E3   E0           MOVX      A,@DPTR
   \   0000E4   9400         SUBB      A,#0x0
   \   0000E6   5039         JNC       ??bdb_startResumeCommissioningProcess_8
   2392                    {
   2393                      *((uint16*)attrRec.attr.dataPtr) = BDBC_MIN_COMMISSIONING_TIME;
   \   0000E8   8882         MOV       DPL,R0
   \   0000EA   8983         MOV       DPH,R1
   \   0000EC   74B4         MOV       A,#-0x4c
   \   0000EE   F0           MOVX      @DPTR,A
   \   0000EF   A3           INC       DPTR
   \   0000F0   E4           CLR       A
   \   0000F1   F0           MOVX      @DPTR,A
   2394                       osal_start_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT, 1000 );
   \   0000F2                ; Setup parameters for call to function osal_start_timerEx
   \   0000F2   90....       MOV       DPTR,#__Constant_3e8
   \   0000F5   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0000F8   7A00         MOV       R2,#0x0
   \   0000FA   7B20         MOV       R3,#0x20
   \   0000FC   12....       LCALL     ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   0000FF   12....       LCALL     ?DEALLOC_XSTACK8
   2395          
   2396                      if(pfnIdentifyTimeChangeCB != NULL)
   \   000102   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB
   \   000105   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000108   6017         JZ        ??bdb_startResumeCommissioningProcess_8
   2397                      {
   2398                        if(bdbIndentifyActiveEndpoint == 0xFF)
   \   00010A   90....       MOV       DPTR,#bdbIndentifyActiveEndpoint
   \   00010D   E0           MOVX      A,@DPTR
   \   00010E   F4           CPL       A
   \   00010F   7004         JNZ       ??bdb_startResumeCommissioningProcess_9
   2399                        {
   2400                          pfnIdentifyTimeChangeCB(bdbIndentifyActiveEndpoint);  
   \   000111                ; Setup parameters for indirect call
   \   000111   79FF         MOV       R1,#-0x1
   \   000113   8006         SJMP      ??bdb_startResumeCommissioningProcess_10
   2401                        }
   2402                        else
   2403                        {
   2404                          pfnIdentifyTimeChangeCB(bdb_CurrEpDescriptor->endPoint);
   \                     ??bdb_startResumeCommissioningProcess_9:
   \   000115                ; Setup parameters for indirect call
   \   000115   8E82         MOV       DPL,R6
   \   000117   8F83         MOV       DPH,R7
   \   000119   E0           MOVX      A,@DPTR
   \   00011A   F9           MOV       R1,A
   2405                        }
   2406                      }
   2407                    }
   \                     ??bdb_startResumeCommissioningProcess_10:
   \   00011B   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   00011E   12....       LCALL     ?CALL_IND
   2408                    //Attribute found and set, report success
   2409                    if(!(bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_INITIATOR))
   \                     ??bdb_startResumeCommissioningProcess_8:
   \   000121   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000124   4004         JC        ??bdb_startResumeCommissioningProcess_11
   2410                    {
   2411                      bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FB_TARGET_IN_PROGRESS);
   \   000126                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   000126   7909         MOV       R1,#0x9
   \   000128   801F         SJMP      ??bdb_startResumeCommissioningProcess_12
   2412                    }
   2413                    else
   2414                    {
   2415                      bdbCommissioningModeMsg_t bdbCommissioningModeMsg;
   2416          
   2417                      bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_FINDING_BINDING;
   \                     ??bdb_startResumeCommissioningProcess_11:
   \   00012A   7401         MOV       A,#0x1
   \   00012C   12....       LCALL     ?XSTACK_DISP0_8
   \   00012F   12....       LCALL     ?Subroutine13 & 0xFFFF
   2418                      bdbCommissioningModeMsg.bdbCommissioningStatus = BDB_COMMISSIONING_FB_TARGET_IN_PROGRESS;
   2419          
   2420                      bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   2421                    }
   2422                  }
   \                     ??CrossCallReturnLabel_76:
   \   000132   7409         MOV       A,#0x9
   \   000134   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000137   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00013A   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   00013D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000140   800A         SJMP      ??bdb_startResumeCommissioningProcess_6
   2423                  else
   2424                  {
   2425                    //Attribute not found and no initiator process, report fail
   2426                    if(!(bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_INITIATOR))
   \                     ??bdb_startResumeCommissioningProcess_7:
   \   000142   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000145   4005         JC        ??bdb_startResumeCommissioningProcess_6
   2427                    {
   2428                      bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   \   000147                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   000147   790E         MOV       R1,#0xe
   \                     ??bdb_startResumeCommissioningProcess_12:
   \   000149   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
   2429                    }
   2430                  }
   2431                }  //F&B Target
   2432                
   2433                if( bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_INITIATOR)  //F&B as Initiator
   \                     ??bdb_startResumeCommissioningProcess_6:
   \   00014C   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   00014F   E0           MOVX      A,@DPTR
   \   000150   F8           MOV       R0,A
   \   000151   A3           INC       DPTR
   \   000152   12....       LCALL     ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000155   A3           INC       DPTR
   \   000156   A3           INC       DPTR
   \   000157   E0           MOVX      A,@DPTR
   \   000158   2401         ADD       A,#0x1
   \   00015A   F8           MOV       R0,A
   \   00015B   A3           INC       DPTR
   \   00015C   E0           MOVX      A,@DPTR
   \   00015D   3400         ADDC      A,#0x0
   \   00015F   F9           MOV       R1,A
   \   000160   8882         MOV       DPL,R0
   \   000162   F583         MOV       DPH,A
   \   000164   E0           MOVX      A,@DPTR
   \   000165   A2E0         MOV       C,0xE0 /* A   */.0
   \   000167   5053         JNC       ??bdb_startResumeCommissioningProcess_2
   2434                {
   2435                  bdbCommissioningModeMsg_t bdbCommissioningModeMsg;
   2436                  
   2437                  //If no function to add binds is available then do not process Initiator
   2438                  if(!pbindAddEntry)
   \   000169   90....       MOV       DPTR,#pbindAddEntry
   \   00016C   12....       LCALL     ??Subroutine66_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   00016F   7010         JNZ       ??bdb_startResumeCommissioningProcess_13
   2439                  {
   2440                    //If no target process, then report fail
   2441                    if(!(bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_TARGET))
   \   000171   8882         MOV       DPL,R0
   \   000173   8983         MOV       DPH,R1
   \   000175   E0           MOVX      A,@DPTR
   \   000176   A2E1         MOV       C,0xE0 /* A   */.1
   \   000178   4042         JC        ??bdb_startResumeCommissioningProcess_2
   2442                    {
   2443                      bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   2444                    }        
   2445                  }
   2446                  else
   2447                  {
   2448                    //Send identify query with the endpoint requested
   2449                    if(bdb_SendIdentifyQuery(bdb_CurrEpDescriptor->endPoint) != ZSuccess)
   2450                    {
   2451                      bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   2452                    }
   2453          
   2454                    //If periodic F&B is enabled
   2455                    if ( FINDING_AND_BINDING_PERIODIC_ENABLE == TRUE )
   2456                    {
   2457                      // total F&B time will be at least BDBC_MIN_COMMISSIONING_TIME, and at most (BDBC_MIN_COMMISSIONING_TIME + FINDING_AND_BINDING_PERIODIC_TIME - 1)
   2458                      bdb_FB_InitiatorCurrentCyclesNumber = (BDBC_MIN_COMMISSIONING_TIME + (FINDING_AND_BINDING_PERIODIC_TIME - 1)) / FINDING_AND_BINDING_PERIODIC_TIME;
   2459                      
   2460                      osal_start_timerEx(bdb_TaskID, BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT, FINDING_AND_BINDING_PERIODIC_TIME * 1000);
   2461                    }
   2462          
   2463                    bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_FINDING_BINDING;
   2464                    bdbCommissioningModeMsg.bdbCommissioningStatus = BDB_COMMISSIONING_FB_INITITATOR_IN_PROGRESS;
   2465          
   2466                    bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   2467                  }
   2468                } //F&B Initiator
   2469              }
   2470              //Not in the network
   2471              else
   2472              {
   2473                bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   \                     ??bdb_startResumeCommissioningProcess_5:
   \   00017A                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   00017A   790E         MOV       R1,#0xe
   \   00017C   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
   2474              }
   2475              
   2476              return;
   \   00017F   803B         SJMP      ??bdb_startResumeCommissioningProcess_2
   \                     ??bdb_startResumeCommissioningProcess_13:
   \   000181                ; Setup parameters for call to function bdb_SendIdentifyQuery
   \   000181   8E82         MOV       DPL,R6
   \   000183   8F83         MOV       DPH,R7
   \   000185   E0           MOVX      A,@DPTR
   \   000186   F9           MOV       R1,A
   \   000187   12....       LCALL     `??bdb_SendIdentifyQuery::?relay`; Banked call to: bdb_SendIdentifyQuery
   \   00018A   E9           MOV       A,R1
   \   00018B   6005         JZ        ??bdb_startResumeCommissioningProcess_14
   \   00018D                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   00018D   790E         MOV       R1,#0xe
   \   00018F   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
   \                     ??bdb_startResumeCommissioningProcess_14:
   \   000192   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000195   740C         MOV       A,#0xc
   \   000197   F0           MOVX      @DPTR,A
   \   000198                ; Setup parameters for call to function osal_start_timerEx
   \   000198   90....       MOV       DPTR,#__Constant_3a98
   \   00019B   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00019E   7A40         MOV       R2,#0x40
   \   0001A0   12....       LCALL     ??Subroutine60_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   0001A3   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001A6   7401         MOV       A,#0x1
   \   0001A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0001AB   12....       LCALL     ?Subroutine13 & 0xFFFF
   2477            }
   \                     ??CrossCallReturnLabel_77:
   \   0001AE   740A         MOV       A,#0xa
   \   0001B0   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0001B3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001B6   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0001B9   12....       LCALL     ?DEALLOC_XSTACK8
   2478          #endif
   2479            
   2480          }
   \                     ??bdb_startResumeCommissioningProcess_2:
   \   0001BC   740B         MOV       A,#0xb
   \   0001BE   02....       LJMP      ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   A2E0         MOV       C,0xE0 /* A   */.0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB + 1
   \   000003                REQUIRE ??Subroutine59_0
   \   000003                ; // Fall through to label ??Subroutine59_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   000003   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000006   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000009   22           RET
   2481          
   2482          /*********************************************************************
   2483           * @fn          bdb_event_loop
   2484           *
   2485           * @brief       Main event loop bdb tasks.
   2486           *
   2487           * @param       task_id - task id
   2488           * @param       events - event bitmap
   2489           *
   2490           * @return      unprocessed events
   2491           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2492          UINT16 bdb_event_loop(byte task_id, UINT16 events)
   \                     bdb_event_loop:
   2493          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2494            (void)task_id;  // Intentionally unreferenced parameter
   2495            
   2496          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)  
   2497            endPointDesc_t * bdb_CurrEpDescriptor;
   2498          #endif
   2499            
   2500            if(events & BDB_CHANGE_COMMISSIONING_STATE)
   \   00000E   EA           MOV       A,R2
   \   00000F   5404         ANL       A,#0x4
   \   000011   6035         JZ        ??bdb_event_loop_0
   2501            {
   2502              switch(bdbCommissioningProcedureState.bdbCommissioningState)
   \   000013   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000016   E0           MOVX      A,@DPTR
   \   000017   600A         JZ        ??bdb_event_loop_1
   \   000019   24FC         ADD       A,#-0x4
   \   00001B   600B         JZ        ??bdb_event_loop_2
   \   00001D   24FE         ADD       A,#-0x2
   \   00001F   600C         JZ        ??bdb_event_loop_3
   \   000021   801F         SJMP      ??bdb_event_loop_4
   2503              {
   2504                case BDB_COMMISSIONING_STATE_START_RESUME:
   2505                  bdb_startResumeCommissioningProcess();
   \                     ??bdb_event_loop_1:
   \   000023                ; Setup parameters for call to function bdb_startResumeCommissioningProcess
   \   000023   12....       LCALL     `??bdb_startResumeCommissioningProcess::?relay`; Banked call to: bdb_startResumeCommissioningProcess
   2506                break;
   \   000026   801A         SJMP      ??bdb_event_loop_4
   2507                
   2508                case BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE:
   2509                  if (ZG_BUILD_JOINING_TYPE)
   2510                  {
   2511                    bdb_tcLinkKeyExchangeAttempt(TRUE,BDB_REQ_TC_STACK_VERSION);
   2512                  }
   2513                break;
   2514                
   2515                case BDB_COMMISSIONING_STATE_STEERING_ON_NWK:
   2516                  bdb_nwkSteeringDeviceOnNwk();
   \                     ??bdb_event_loop_2:
   \   000028                ; Setup parameters for call to function bdb_nwkSteeringDeviceOnNwk
   \   000028   12....       LCALL     ?Subroutine34 & 0xFFFF
   2517                  
   2518                  bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_STEERING_ON_NWK, TRUE);
   2519                break;
   \                     ??CrossCallReturnLabel_40:
   \   00002B   8015         SJMP      ??bdb_event_loop_4
   2520                
   2521                case BDB_COMMISSIONING_STATE_FINDING_BINDING:
   2522                  bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \                     ??bdb_event_loop_3:
   \   00002D   90....       MOV       DPTR,#bdbAttributes + 10
   \   000030   E4           CLR       A
   \   000031   F0           MOVX      @DPTR,A
   2523                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   000032   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000035   F0           MOVX      @DPTR,A
   2524                  osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50);
   \   000036                ; Setup parameters for call to function osal_start_timerEx
   \   000036   90....       MOV       DPTR,#__Constant_32
   \   000039   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00003C   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   00003F   12....       LCALL     ?DEALLOC_XSTACK8
   2525                break;
   2526                
   2527              }
   2528              return (events ^ BDB_CHANGE_COMMISSIONING_STATE);
   \                     ??bdb_event_loop_4:
   \   000042   EE           MOV       A,R6
   \   000043   6404         XRL       A,#0x4
   \   000045   02....       LJMP      ??bdb_event_loop_5 & 0xFFFF
   2529            }
   2530          
   2531            if ( events & SYS_EVENT_MSG )
   \                     ??bdb_event_loop_0:
   \   000048   EB           MOV       A,R3
   \   000049   5480         ANL       A,#0x80
   \   00004B   7026         JNZ       ??bdb_event_loop_6
   2532            {
   2533              uint8 *msg_ptr;
   2534              
   2535              while ( (msg_ptr = osal_msg_receive( bdb_TaskID )) )
   2536              {
   2537                //Process the Incomming ZDO messages used by BDB commissioning methods
   2538                if(((bdbInMsg_t*)msg_ptr)->hdr.event == BDB_ZDO_CB_MSG)
   2539                {
   2540                  bdb_processZDOMgs((zdoIncomingMsg_t *)msg_ptr);
   2541                }
   2542                
   2543                //Validate the is receive on the right process
   2544                else if(((bdbInMsg_t*)msg_ptr)->hdr.event == bdbCommissioningProcedureState.bdbCommissioningState)
   2545                {
   2546                  bdb_ProcessOSALMsg( (bdbInMsg_t *)msg_ptr );
   2547                }
   2548                //Notify the user
   2549                else if(((bdbInMsg_t*)msg_ptr)->hdr.event == BDB_NOTIFY_USER)
   2550                {
   2551                  ((bdbCommissioningModeMsg_t*) ((bdbInMsg_t*)msg_ptr)->buf)->bdbRemainingCommissioningModes = bdbAttributes.bdbCommissioningMode;
   2552                  if(pfnCommissioningStatusCB)
   2553                  {
   2554                    pfnCommissioningStatusCB((bdbCommissioningModeMsg_t*) (((bdbInMsg_t*)msg_ptr)->buf));
   2555                  }
   2556          #ifdef MT_APP_CNF_FUNC
   2557                  //Notify the host processor about the event
   2558                  MT_AppCnfCommissioningNotification((bdbCommissioningModeMsg_t*) (((bdbInMsg_t*)msg_ptr)->buf));
   2559          #endif
   2560                }
   2561          #if (ZG_BUILD_COORDINATOR_TYPE)
   2562                else
   2563                {
   2564                  if(ZG_DEVICE_COORDINATOR_TYPE)
   2565                  {
   2566                    //Notify the status 
   2567                    if(((bdbInMsg_t*)msg_ptr)->hdr.event == BDB_TC_LINK_KEY_EXCHANGE_PROCESS)
   2568                    {
   2569                      pfnTCLinkKeyExchangeProcessCB( (bdb_TCLinkKeyExchProcess_t*) ((bdbInMsg_t*)msg_ptr)->buf);
   2570                    }
   2571                  }
   2572                }
   2573          #endif
   2574                // Release the memory
   2575                osal_msg_deallocate( msg_ptr );
   2576              }
   2577          
   2578              // Return unprocessed events
   2579              return (events ^ SYS_EVENT_MSG);
   2580            }
   2581            
   2582          
   2583            if(events & BDB_PROCESS_TIMEOUT)
   \   00004D   EB           MOV       A,R3
   \   00004E   5410         ANL       A,#0x10
   \   000050   7003         JNZ       $+5
   \   000052   02....       LJMP      ??bdb_event_loop_7 & 0xFFFF
   2584            {
   2585              bdb_processTimeout();
   2586              // Return unprocessed events
   2587              return (events ^ BDB_PROCESS_TIMEOUT);
   \   000055   EB           MOV       A,R3
   \   000056   6410         XRL       A,#0x10
   \   000058   02....       LJMP      ??bdb_event_loop_8 & 0xFFFF
   2588            }
   \                     ??bdb_event_loop_9:
   \   00005B   7409         MOV       A,#0x9
   \   00005D   68           XRL       A,R0
   \   00005E   700C         JNZ       ??bdb_event_loop_10
   \   000060                ; Setup parameters for indirect call
   \   000060   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
   \   000063   E0           MOVX      A,@DPTR
   \   000064   F8           MOV       R0,A
   \   000065   A3           INC       DPTR
   \                     ??bdb_event_loop_11:
   \   000066   12....       LCALL     ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000069   12....       LCALL     ?CALL_IND
   \                     ??bdb_event_loop_10:
   \   00006C                ; Setup parameters for call to function osal_msg_deallocate
   \   00006C   AA..         MOV       R2,?V0
   \   00006E   AB..         MOV       R3,?V1
   \   000070   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \                     ??bdb_event_loop_6:
   \   000073                ; Setup parameters for call to function osal_msg_receive
   \   000073   90....       MOV       DPTR,#bdb_TaskID
   \   000076   E0           MOVX      A,@DPTR
   \   000077   F9           MOV       R1,A
   \   000078   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   00007B   8A..         MOV       ?V0,R2
   \   00007D   8B..         MOV       ?V1,R3
   \   00007F   EA           MOV       A,R2
   \   000080   4B           ORL       A,R3
   \   000081   6066         JZ        ??bdb_event_loop_12
   \   000083   8A82         MOV       DPL,R2
   \   000085   8B83         MOV       DPH,R3
   \   000087   E0           MOVX      A,@DPTR
   \   000088   F8           MOV       R0,A
   \   000089   74D3         MOV       A,#-0x2d
   \   00008B   68           XRL       A,R0
   \   00008C   702D         JNZ       ??bdb_event_loop_13
   \   00008E   EA           MOV       A,R2
   \   00008F   240C         ADD       A,#0xc
   \   000091   F582         MOV       DPL,A
   \   000093   E4           CLR       A
   \   000094   35..         ADDC      A,?V1
   \   000096   F583         MOV       DPH,A
   \   000098   E0           MOVX      A,@DPTR
   \   000099   F5..         MOV       ?V2,A
   \   00009B   A3           INC       DPTR
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   F5..         MOV       ?V3,A
   \   00009F   78..         MOV       R0,#?V2
   \   0000A1   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for bdb_event_loop>_0`:
   \   0000A4   0180         DW        32769
   \   0000A6   03           DB        3
   \   0000A7   ....         DW        ??bdb_event_loop_10
   \   0000A9   ....         DW        ??bdb_event_loop_14
   \   0000AB   ....         DW        ??bdb_event_loop_10
   \   0000AD   ....         DW        ??bdb_event_loop_10
   \   0000AF   ....         DW        ??bdb_event_loop_15
   \                     ??bdb_event_loop_15:
   \   0000B1                ; Setup parameters for call to function bdb_ProcessSimpleDesc
   \   0000B1   12....       LCALL     `??bdb_ProcessSimpleDesc::?relay`; Banked call to: bdb_ProcessSimpleDesc
   \   0000B4   80B6         SJMP      ??bdb_event_loop_10
   \                     ??bdb_event_loop_14:
   \   0000B6                ; Setup parameters for call to function bdb_ProcessIEEEAddrRsp
   \   0000B6   12....       LCALL     `??bdb_ProcessIEEEAddrRsp::?relay`; Banked call to: bdb_ProcessIEEEAddrRsp
   \   0000B9   80B1         SJMP      ??bdb_event_loop_10
   \                     ??bdb_event_loop_13:
   \   0000BB   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0000BE   E0           MOVX      A,@DPTR
   \   0000BF   68           XRL       A,R0
   \   0000C0   60AA         JZ        ??bdb_event_loop_10
   \   0000C2   EA           MOV       A,R2
   \   0000C3   2402         ADD       A,#0x2
   \   0000C5   FA           MOV       R2,A
   \   0000C6   E4           CLR       A
   \   0000C7   35..         ADDC      A,?V1
   \   0000C9   FB           MOV       R3,A
   \   0000CA   740A         MOV       A,#0xa
   \   0000CC   68           XRL       A,R0
   \   0000CD   708C         JNZ       ??bdb_event_loop_9
   \   0000CF   90....       MOV       DPTR,#bdbAttributes + 11
   \   0000D2   E0           MOVX      A,@DPTR
   \   0000D3   85..82       MOV       DPL,?V0
   \   0000D6   85..83       MOV       DPH,?V1
   \   0000D9   A3           INC       DPTR
   \   0000DA   A3           INC       DPTR
   \   0000DB   A3           INC       DPTR
   \   0000DC   A3           INC       DPTR
   \   0000DD   F0           MOVX      @DPTR,A
   \   0000DE   90....       MOV       DPTR,#pfnCommissioningStatusCB
   \   0000E1   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   0000E4   6086         JZ        ??bdb_event_loop_10
   \   0000E6                ; Setup parameters for indirect call
   \   0000E6   02....       LJMP      ??bdb_event_loop_11 & 0xFFFF
   \                     ??bdb_event_loop_12:
   \   0000E9   EE           MOV       A,R6
   \   0000EA   FA           MOV       R2,A
   \   0000EB   EF           MOV       A,R7
   \   0000EC   6480         XRL       A,#0x80
   \   0000EE   02....       LJMP      ??bdb_event_loop_8 & 0xFFFF
   2589            
   2590            if(events &  BDB_REPORT_TIMEOUT){
   \                     ??bdb_event_loop_7:
   \   0000F1   EA           MOV       A,R2
   \   0000F2   5480         ANL       A,#0x80
   \   0000F4   6007         JZ        ??bdb_event_loop_16
   2591          #ifdef BDB_REPORTING    
   2592              bdb_RepProcessEvent();
   2593          #endif
   2594              // Return unprocessed events
   2595              return (events ^ BDB_REPORT_TIMEOUT);
   \   0000F6   EA           MOV       A,R2
   \   0000F7   6480         XRL       A,#0x80
   \   0000F9   FA           MOV       R2,A
   \   0000FA   02....       LJMP      ??bdb_event_loop_17 & 0xFFFF
   2596            }
   2597            
   2598          #if (ZG_BUILD_JOINING_TYPE)
   2599            if(events & BDB_TC_LINK_KEY_EXCHANGE_FAIL)
   2600            {
   2601              if(ZG_DEVICE_JOINING_TYPE)
   2602              {
   2603                NLME_LeaveReq_t leaveReq;
   2604                // Set every field to 0
   2605                osal_memset( &leaveReq, 0, sizeof( NLME_LeaveReq_t ) );
   2606                
   2607                bdb_setNodeIsOnANetwork(FALSE);
   2608          
   2609                if ( NLME_LeaveReq( &leaveReq ) != ZSuccess )
   2610                {
   2611                  osal_set_event( bdb_TaskID,BDB_TC_LINK_KEY_EXCHANGE_FAIL);
   2612                }
   2613              }
   2614              // Return unprocessed events
   2615              return (events ^ BDB_TC_LINK_KEY_EXCHANGE_FAIL);
   2616            }
   2617          #endif
   2618            
   2619            if(events & BDB_TC_JOIN_TIMEOUT)
   \                     ??bdb_event_loop_16:
   \   0000FD   EB           MOV       A,R3
   \   0000FE   5408         ANL       A,#0x8
   \   000100   600B         JZ        ??bdb_event_loop_18
   2620            {     
   2621          #if (ZG_BUILD_COORDINATOR_TYPE)
   2622              if(ZG_DEVICE_COORDINATOR_TYPE)
   2623              {
   2624                bdb_TCProcessJoiningList();
   \   000102                ; Setup parameters for call to function bdb_TCProcessJoiningList
   \   000102   12....       LCALL     `??bdb_TCProcessJoiningList::?relay`; Banked call to: bdb_TCProcessJoiningList
   2625              }
   2626          #endif    
   2627              return (events ^ BDB_TC_JOIN_TIMEOUT);
   \   000105   EE           MOV       A,R6
   \   000106   FA           MOV       R2,A
   \   000107   EF           MOV       A,R7
   \   000108   6408         XRL       A,#0x8
   \   00010A   02....       LJMP      ??bdb_event_loop_8 & 0xFFFF
   2628            }
   2629          
   2630          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)  
   2631            
   2632            if(events & BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT)
   \                     ??bdb_event_loop_18:
   \   00010D   EA           MOV       A,R2
   \   00010E   5440         ANL       A,#0x40
   \   000110   6049         JZ        ??bdb_event_loop_19
   2633            {
   2634              if ( FINDING_AND_BINDING_PERIODIC_ENABLE == TRUE )
   2635              {
   2636                bdb_CurrEpDescriptor = bdb_setEpDescListToActiveEndpoint();
   \   000112                ; Setup parameters for call to function bdb_setEpDescListToActiveEndpoint
   \   000112   12....       LCALL     `??bdb_setEpDescListToActiveEndpoint::?relay`; Banked call to: bdb_setEpDescListToActiveEndpoint
   \   000115   8A..         MOV       ?V0,R2
   \   000117   8B..         MOV       ?V1,R3
   2637                
   2638                //If we have endpoint from which to send the identify command, then proceed, otherwise finish
   2639                if(bdb_CurrEpDescriptor != NULL) //just a safty check. The fact that we got to this functuon at all means that this cannot be NULL
   \   000119   EA           MOV       A,R2
   \   00011A   4B           ORL       A,R3
   \   00011B   602B         JZ        ??bdb_event_loop_20
   2640                {
   2641                  //Substract an attempt
   2642                  bdb_FB_InitiatorCurrentCyclesNumber--;
   2643                  
   2644                  if(bdb_FB_InitiatorCurrentCyclesNumber > 0)
   \   00011D   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000120   E0           MOVX      A,@DPTR
   \   000121   14           DEC       A
   \   000122   F0           MOVX      @DPTR,A
   \   000123   6029         JZ        ??bdb_event_loop_21
   2645                  {
   2646                    //Only send Identify Query if there is no pending responses from a previous identify query
   2647                    if ((osal_get_timeoutEx(bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT) == 0) && (bdb_getRespondentRetry(pRespondentHead) == NULL))
   \   000125                ; Setup parameters for call to function osal_get_timeoutEx
   \   000125   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000128   7010         JNZ       ??bdb_event_loop_22
   \   00012A                ; Setup parameters for call to function bdb_getRespondentRetry
   \   00012A   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00012D   700B         JNZ       ??bdb_event_loop_22
   2648                    {
   2649                      //Send identify query with the endpoint requested
   2650                      bdb_SendIdentifyQuery(bdb_CurrEpDescriptor->endPoint);
   \   00012F                ; Setup parameters for call to function bdb_SendIdentifyQuery
   \   00012F   85..82       MOV       DPL,?V0
   \   000132   85..83       MOV       DPH,?V1
   \   000135   E0           MOVX      A,@DPTR
   \   000136   F9           MOV       R1,A
   \   000137   12....       LCALL     `??bdb_SendIdentifyQuery::?relay`; Banked call to: bdb_SendIdentifyQuery
   2651                    }
   2652                    osal_start_timerEx(bdb_TaskID, BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT, FINDING_AND_BINDING_PERIODIC_TIME * 1000);
   \                     ??bdb_event_loop_22:
   \   00013A                ; Setup parameters for call to function osal_start_timerEx
   \   00013A   90....       MOV       DPTR,#__Constant_3a98
   \   00013D   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000140   7A40         MOV       R2,#0x40
   \   000142   12....       LCALL     ??Subroutine60_0 & 0xFFFF
   2653                  }
   2654                }
   2655              }
   \                     ??CrossCallReturnLabel_116:
   \   000145   12....       LCALL     ?DEALLOC_XSTACK8
   2656          
   2657              if (bdb_FB_InitiatorCurrentCyclesNumber == 0)
   \                     ??bdb_event_loop_20:
   \   000148   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   00014B   E0           MOVX      A,@DPTR
   \   00014C   7005         JNZ       ??bdb_event_loop_23
   2658              {
   2659                bdb_exitFindingBindingWStatus( BDB_COMMISSIONING_FB_NO_IDENTIFY_QUERY_RESPONSE );
   \                     ??bdb_event_loop_21:
   \   00014E                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   00014E   790B         MOV       R1,#0xb
   \   000150   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
   2660              }
   2661              
   2662              return (events ^ BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT);
   \                     ??bdb_event_loop_23:
   \   000153   EE           MOV       A,R6
   \   000154   6440         XRL       A,#0x40
   \                     ??bdb_event_loop_5:
   \   000156   FA           MOV       R2,A
   \   000157   EF           MOV       A,R7
   \   000158   02....       LJMP      ??bdb_event_loop_8 & 0xFFFF
   2663            }
   2664            
   2665            if(events & BDB_IDENTIFY_TIMEOUT)
   \                     ??bdb_event_loop_19:
   \   00015B   EB           MOV       A,R3
   \   00015C   5420         ANL       A,#0x20
   \   00015E   7003         JNZ       $+5
   \   000160   02....       LJMP      ??bdb_event_loop_24 & 0xFFFF
   2666            {
   2667              zclAttrRec_t identifyAttrRec;
   2668              epList_t *bdb_CurrEpDescriptorNextInList = NULL;
   2669              bdb_CurrEpDescriptorNextInList = bdb_HeadEpDescriptorList;
   \   000163   90....       MOV       DPTR,#bdb_HeadEpDescriptorList
   \   000166   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000169   88..         MOV       ?V0,R0
   \   00016B   F5..         MOV       ?V1,A
   2670              
   2671              bool KeepIdentifyTimerRunning = FALSE;
   \   00016D   75..00       MOV       ?V2,#0x0
   \   000170   8024         SJMP      ??CrossCallReturnLabel_18
   2672              
   2673              while(bdb_CurrEpDescriptorNextInList != NULL )
   2674              {
   2675                endPointDesc_t *bdb_EpDescriptor = NULL;
   2676                bdb_EpDescriptor = bdb_CurrEpDescriptorNextInList->epDesc;
   2677              
   2678                //Do not check ZDO or Zigbee reserved endpoints
   2679                if((bdb_CurrEpDescriptorList->epDesc->endPoint == 0) || (bdb_CurrEpDescriptorList->epDesc->endPoint >= BDB_ZIGBEE_RESERVED_ENDPOINTS_START))
   2680                {
   2681                  bdb_CurrEpDescriptorNextInList = bdb_CurrEpDescriptorNextInList->nextDesc;
   2682                  continue;
   2683                }
   2684                
   2685                if ( zclFindAttrRec( bdb_EpDescriptor->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2686                                  ATTRID_IDENTIFY_TIME, &identifyAttrRec ) )
   2687                {
   2688                  if(*((uint16*)identifyAttrRec.attr.dataPtr) > 0)
   2689                  {
   2690                    (uint16)(*((uint16*)identifyAttrRec.attr.dataPtr))--;
   2691                    KeepIdentifyTimerRunning = TRUE;
   2692                  }
   2693                  else
   2694                  {
   2695                    // Use bdb success main state
   2696                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \                     ??bdb_event_loop_25:
   \   000172   90....       MOV       DPTR,#bdbAttributes + 10
   \   000175   E4           CLR       A
   \   000176   F0           MOVX      @DPTR,A
   2697                    if(pfnIdentifyTimeChangeCB != NULL)
   \   000177   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB
   \   00017A   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   00017D   600E         JZ        ??bdb_event_loop_26
   2698                    {
   2699                      pfnIdentifyTimeChangeCB(bdb_EpDescriptor->endPoint);
   \   00017F                ; Setup parameters for indirect call
   \   00017F   85..82       MOV       DPL,?V6
   \   000182   85..83       MOV       DPH,?V7
   \   000185   E0           MOVX      A,@DPTR
   \   000186   F9           MOV       R1,A
   \   000187   12....       LCALL     ?Subroutine27 & 0xFFFF
   2700                    }
   2701                  }
   \                     ??CrossCallReturnLabel_108:
   \   00018A   12....       LCALL     ?CALL_IND
   2702                }
   2703                bdb_CurrEpDescriptorNextInList = bdb_CurrEpDescriptorNextInList->nextDesc;
   \                     ??bdb_event_loop_26:
   \   00018D   85..82       MOV       DPL,?V0
   \   000190   85..83       MOV       DPH,?V1
   \   000193   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000196   E5..         MOV       A,?V0
   \   000198   45..         ORL       A,?V1
   \   00019A   6066         JZ        ??bdb_event_loop_27
   \   00019C   85..82       MOV       DPL,?V0
   \   00019F   85..83       MOV       DPH,?V1
   \   0001A2   A3           INC       DPTR
   \   0001A3   A3           INC       DPTR
   \   0001A4   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0001A7   88..         MOV       ?V6,R0
   \   0001A9   F5..         MOV       ?V7,A
   \   0001AB   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   0001AE   E0           MOVX      A,@DPTR
   \   0001AF   60DC         JZ        ??bdb_event_loop_26
   \   0001B1   C3           CLR       C
   \   0001B2   94F1         SUBB      A,#-0xf
   \   0001B4   50D7         JNC       ??bdb_event_loop_26
   \   0001B6                ; Setup parameters for call to function zclFindAttrRec
   \   0001B6   A8..         MOV       R0,?XSP + 0
   \   0001B8   A9..         MOV       R1,?XSP + 1
   \   0001BA   88..         MOV       ?V4,R0
   \   0001BC   89..         MOV       ?V5,R1
   \   0001BE   78..         MOV       R0,#?V4
   \   0001C0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001C3   7C00         MOV       R4,#0x0
   \   0001C5   7D00         MOV       R5,#0x0
   \   0001C7   7A03         MOV       R2,#0x3
   \   0001C9   7B00         MOV       R3,#0x0
   \   0001CB   85..82       MOV       DPL,?V6
   \   0001CE   85..83       MOV       DPH,?V7
   \   0001D1   E0           MOVX      A,@DPTR
   \   0001D2   F9           MOV       R1,A
   \   0001D3   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0001D6   7402         MOV       A,#0x2
   \   0001D8   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001DB   E9           MOV       A,R1
   \   0001DC   60AF         JZ        ??bdb_event_loop_26
   \   0001DE   7406         MOV       A,#0x6
   \   0001E0   12....       LCALL     ?XSTACK_DISP0_8
   \   0001E3   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0001E6   F9           MOV       R1,A
   \   0001E7   8882         MOV       DPL,R0
   \   0001E9   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   0001EC   6084         JZ        ??bdb_event_loop_25
   \   0001EE   EA           MOV       A,R2
   \   0001EF   24FF         ADD       A,#-0x1
   \   0001F1   1A           DEC       R2
   \   0001F2   EB           MOV       A,R3
   \   0001F3   34FF         ADDC      A,#-0x1
   \   0001F5   FB           MOV       R3,A
   \   0001F6   8882         MOV       DPL,R0
   \   0001F8   8983         MOV       DPH,R1
   \   0001FA   12....       LCALL     ??Subroutine67_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   0001FD   75..01       MOV       ?V2,#0x1
   \   000200   808B         SJMP      ??bdb_event_loop_26
   2704              }
   2705              
   2706              //If any endpoint has identify running, keep the timer on
   2707              if(KeepIdentifyTimerRunning)
   \                     ??bdb_event_loop_27:
   \   000202   E5..         MOV       A,?V2
   \   000204   6012         JZ        ??bdb_event_loop_28
   2708              {
   2709                osal_start_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT, 1000 );
   \   000206                ; Setup parameters for call to function osal_start_timerEx
   \   000206   90....       MOV       DPTR,#__Constant_3e8
   \   000209   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00020C   7A00         MOV       R2,#0x0
   \   00020E   7B20         MOV       R3,#0x20
   \   000210   12....       LCALL     ??Subroutine61_0 & 0xFFFF
   2710              }
   \                     ??CrossCallReturnLabel_119:
   \   000213   12....       LCALL     ?DEALLOC_XSTACK8
   \   000216   8007         SJMP      ??CrossCallReturnLabel_129
   2711              else
   2712              {
   2713                osal_stop_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT );
   \                     ??bdb_event_loop_28:
   \   000218                ; Setup parameters for call to function osal_stop_timerEx
   \   000218   7A00         MOV       R2,#0x0
   \   00021A   7B20         MOV       R3,#0x20
   \   00021C   12....       LCALL     ??Subroutine63_0 & 0xFFFF
   2714              }
   2715              
   2716              // Return unprocessed events
   2717              return (events ^ BDB_IDENTIFY_TIMEOUT);
   \                     ??CrossCallReturnLabel_129:
   \   00021F   EE           MOV       A,R6
   \   000220   FA           MOV       R2,A
   \   000221   EF           MOV       A,R7
   \   000222   6420         XRL       A,#0x20
   \   000224   800D         SJMP      ??bdb_event_loop_8
   2718            }
   2719            
   2720            if(events & BDB_RESPONDENT_PROCESS_TIMEOUT)
   \                     ??bdb_event_loop_24:
   \   000226   EB           MOV       A,R3
   \   000227   5440         ANL       A,#0x40
   \   000229   600B         JZ        ??bdb_event_loop_29
   2721            {
   2722              // Send Simple Descriptor request to a respondent node
   2723              bdb_ProcessRespondentList();
   \   00022B                ; Setup parameters for call to function bdb_ProcessRespondentList
   \   00022B   12....       LCALL     `??bdb_ProcessRespondentList::?relay`; Banked call to: bdb_ProcessRespondentList
   2724          
   2725              return (events ^ BDB_RESPONDENT_PROCESS_TIMEOUT);
   \   00022E   EE           MOV       A,R6
   \   00022F   FA           MOV       R2,A
   \   000230   EF           MOV       A,R7
   \   000231   6440         XRL       A,#0x40
   \                     ??bdb_event_loop_8:
   \   000233   FB           MOV       R3,A
   \   000234   8004         SJMP      ??bdb_event_loop_17
   2726            }
   2727          #endif
   2728            
   2729            return 0;
   \                     ??bdb_event_loop_29:
   \   000236   7A00         MOV       R2,#0x0
   \   000238   7B00         MOV       R3,#0x0
   \                     ??bdb_event_loop_17:
   \   00023A   7408         MOV       A,#0x8
   \   00023C   02....       LJMP      ?Subroutine6 & 0xFFFF
   2730          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V1,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine66_0
   \   000002                ; // Fall through to label ??Subroutine66_0
   2731          
   2732          /*********************************************************************
   2733           * @fn          bdb_processZDOMgs
   2734           *
   2735           * @brief       Process ZDO messages used as part of BDB commissioning methods
   2736           *
   2737           * @param       zdoIncomingMsg_t - ZDO message
   2738           *
   2739           * @return      
   2740           */
   2741          static void bdb_processZDOMgs(zdoIncomingMsg_t *pMsg)
   2742          {
   2743            switch ( pMsg->clusterID )
   2744            {
   2745          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)      
   2746              case IEEE_addr_rsp:
   2747                 bdb_ProcessIEEEAddrRsp(pMsg);
   2748              break;
   2749              case Simple_Desc_rsp:
   2750                bdb_ProcessSimpleDesc(pMsg);
   2751              break;
   2752          #endif
   2753          
   2754          #if (ZG_BUILD_JOINING_TYPE)    
   2755              case Node_Desc_rsp:
   2756                bdb_ProcessNodeDescRsp(pMsg);
   2757              break;
   2758          #endif
   2759              
   2760              default:
   2761              break;
   2762            }
   2763          }
   2764          
   2765          
   2766          /*********************************************************************
   2767           * @fn      bdb_ProcessNodeDescRsp
   2768           *
   2769           * @brief   Process Node Descriptor response to validate the stack version of the
   2770           *
   2771           * @param   zdoIncomingMsg_t *pMsg
   2772           *
   2773           * @return  none
   2774           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2775          void bdb_ProcessNodeDescRsp(zdoIncomingMsg_t *pMsg)
   \                     bdb_ProcessNodeDescRsp:
   2776          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 35
   \   000005   74DD         MOV       A,#-0x23
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2777            //Avoid processing unintended messages
   2778            if(requestNewTrustCenterLinkKey && 
   2779              (bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE))
   \   00000E   90....       MOV       DPTR,#requestNewTrustCenterLinkKey
   \   000011   E0           MOVX      A,@DPTR
   \   000012   7003         JNZ       $+5
   \   000014   02....       LJMP      ??bdb_ProcessNodeDescRsp_0 & 0xFFFF
   \   000017   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   6401         XRL       A,#0x1
   \   00001D   6003         JZ        $+5
   \   00001F   02....       LJMP      ??bdb_ProcessNodeDescRsp_0 & 0xFFFF
   2780            {
   2781              if(!APSME_IsDistributedSecurity())
   \   000022                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000022   12....       LCALL     `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   000025   E9           MOV       A,R1
   \   000026   707B         JNZ       ??bdb_ProcessNodeDescRsp_0
   2782              {
   2783                //Is this from the coordinator?
   2784                if(pMsg->srcAddr.addr.shortAddr == 0x0000)
   \   000028   8E82         MOV       DPL,R6
   \   00002A   8F83         MOV       DPH,R7
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000031   7070         JNZ       ??bdb_ProcessNodeDescRsp_0
   2785                {
   2786                  ZDO_NodeDescRsp_t NDRsp;
   2787                  uint8 StackComplianceRev;
   2788          
   2789                  //Stop timer to avoid unintended resets
   2790                  osal_stop_timerEx( bdb_TaskID, BDB_PROCESS_TIMEOUT);
   \   000033                ; Setup parameters for call to function osal_stop_timerEx
   \   000033   7A00         MOV       R2,#0x0
   \   000035   7B10         MOV       R3,#0x10
   \   000037   12....       LCALL     ??Subroutine63_0 & 0xFFFF
   2791                  
   2792                  ZDO_ParseNodeDescRsp(pMsg, &NDRsp);
   \                     ??CrossCallReturnLabel_130:
   \   00003A                ; Setup parameters for call to function ZDO_ParseNodeDescRsp
   \   00003A   7413         MOV       A,#0x13
   \   00003C   12....       LCALL     ?XSTACK_DISP102_8
   \   00003F   EE           MOV       A,R6
   \   000040   FA           MOV       R2,A
   \   000041   EF           MOV       A,R7
   \   000042   FB           MOV       R3,A
   \   000043   12....       LCALL     `??ZDO_ParseNodeDescRsp::?relay`; Banked call to: ZDO_ParseNodeDescRsp
   2793                  
   2794                  StackComplianceRev = NDRsp.nodeDesc.ServerMask >> STACK_COMPLIANCE_CURRENT_REV_POS;
   2795                  
   2796                  if( StackComplianceRev >= STACK_COMPL_REV_21 )
   \   000046   741E         MOV       A,#0x1e
   \   000048   12....       LCALL     ?XSTACK_DISP0_8
   \   00004B   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00004E   7409         MOV       A,#0x9
   \   000050   78..         MOV       R0,#?V0
   \   000052   12....       LCALL     ?US_SHR
   \   000055   C3           CLR       C
   \   000056   E5..         MOV       A,?V0
   \   000058   9415         SUBB      A,#0x15
   \   00005A   95E0         SUBB      A,0xE0 /* A   */
   \   00005C   C3           CLR       C
   \   00005D   65D0         XRL       A,PSW
   \   00005F   33           RLC       A
   \   000060   4009         JC        ??bdb_ProcessNodeDescRsp_1
   2797                  {
   2798                    bdb_tcLinkKeyExchangeAttempt(TRUE,BDB_REQ_TC_LINK_KEY);
   \   000062                ; Setup parameters for call to function bdb_tcLinkKeyExchangeAttempt
   \   000062   7A02         MOV       R2,#0x2
   \   000064   7901         MOV       R1,#0x1
   \   000066   12....       LCALL     `??bdb_tcLinkKeyExchangeAttempt::?relay`; Banked call to: bdb_tcLinkKeyExchangeAttempt
   \   000069   8038         SJMP      ??bdb_ProcessNodeDescRsp_0
   2799                  }
   2800                  else
   2801                  {
   2802                    APSME_TCLKDevEntry_t TCLKDevEntry;
   2803                    
   2804                    //Save the KeyAttribute for joining device that it has joined non-R21 nwk
   2805                    TCLKDevEntry.keyAttributes = ZG_NON_R21_NWK_JOINED;
   \                     ??bdb_ProcessNodeDescRsp_1:
   \   00006B   7410         MOV       A,#0x10
   \   00006D   12....       LCALL     ?XSTACK_DISP0_8
   \   000070   74FD         MOV       A,#-0x3
   \   000072   F0           MOVX      @DPTR,A
   2806                    osal_nv_write(ZCD_NV_TCLK_TABLE_START,osal_offsetof(APSME_TCLKDevEntry_t,keyAttributes),sizeof(uint8),&TCLKDevEntry.keyAttributes);
   \   000073                ; Setup parameters for call to function osal_nv_write
   \   000073   8582..       MOV       ?V0,DPL
   \   000076   8583..       MOV       ?V1,DPH
   \   000079   78..         MOV       R0,#?V0
   \   00007B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007E   75..01       MOV       ?V0,#0x1
   \   000081   75..00       MOV       ?V1,#0x0
   \   000084   78..         MOV       R0,#?V0
   \   000086   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000089   7C10         MOV       R4,#0x10
   \   00008B   7D00         MOV       R5,#0x0
   \   00008D   7A11         MOV       R2,#0x11
   \   00008F   7B01         MOV       R3,#0x1
   \   000091   12....       LCALL     ??Subroutine62_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000094   12....       LCALL     ?DEALLOC_XSTACK8
   2807                    
   2808                    bdb_setNodeJoinLinkKeyType(BDB_DEFAULT_GLOBAL_TRUST_CENTER_LINK_KEY);
   \   000097                ; Setup parameters for call to function bdb_setNodeJoinLinkKeyType
   \   000097   7900         MOV       R1,#0x0
   \   000099   12....       LCALL     `??bdb_setNodeJoinLinkKeyType::?relay`; Banked call to: bdb_setNodeJoinLinkKeyType
   2809                    bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE, TRUE);
   \   00009C                ; Setup parameters for call to function bdb_reportCommissioningState
   \   00009C   7A01         MOV       R2,#0x1
   \   00009E   7901         MOV       R1,#0x1
   \   0000A0   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2810                  }
   2811                }
   2812              }
   2813            }
   2814          }
   \                     ??bdb_ProcessNodeDescRsp_0:
   \   0000A3   7423         MOV       A,#0x23
   \   0000A5   02....       LJMP      ?Subroutine1 & 0xFFFF
   2815          
   2816          
   2817          /*********************************************************************
   2818           * @fn          bdb_touchlinkSendFNReset
   2819           *
   2820           * @brief       Starts the Factory New Procedure for Initiator
   2821           *
   2822           * @param       isOnANetwork - TRUE if the devices is not FN, FALSE otherwise
   2823           *
   2824           * @return      none
   2825           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2826          void bdb_touchlinkSendFNReset( void )
   \                     bdb_touchlinkSendFNReset:
   2827          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2828          #ifdef BDB_TL_INITIATOR
   2829            touchLinkInitiator_ResetToFNProcedure( );
   2830          #endif
   2831          }
   \   000000   02....       LJMP      ?BRET
   2832          
   2833          
   2834          /*********************************************************************
   2835           * @fn          bdb_setNodeIsOnANetwork
   2836           *
   2837           * @brief       Sets and saves in Nv bdbNodeIsOnANetwork attribute
   2838           *
   2839           * @param       isOnANetwork - TRUE if the devices is not FN, FALSE otherwise
   2840           *
   2841           * @return      none
   2842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2843          void bdb_setNodeIsOnANetwork(bool isOnANetwork)
   \                     bdb_setNodeIsOnANetwork:
   2844          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   2845            if((bdbAttributes.bdbNodeIsOnANetwork != isOnANetwork) || (!bdb_initialization))
   \   000007   90....       MOV       DPTR,#bdbAttributes + 14
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   6E           XRL       A,R6
   \   00000C   7006         JNZ       ??bdb_setNodeIsOnANetwork_0
   \   00000E   90....       MOV       DPTR,#bdb_initialization
   \   000011   E0           MOVX      A,@DPTR
   \   000012   7029         JNZ       ??bdb_setNodeIsOnANetwork_1
   2846            {
   2847              //We lose our network
   2848              if(!isOnANetwork)
   \                     ??bdb_setNodeIsOnANetwork_0:
   \   000014   E9           MOV       A,R1
   \   000015   7005         JNZ       ??bdb_setNodeIsOnANetwork_2
   2849              {
   2850                bdbAttributes.bdbCommissioningMode = 0;
   \   000017   90....       MOV       DPTR,#bdbAttributes + 11
   \   00001A   E4           CLR       A
   \   00001B   F0           MOVX      @DPTR,A
   2851              }
   2852              
   2853              bdbAttributes.bdbNodeIsOnANetwork = isOnANetwork;
   \                     ??bdb_setNodeIsOnANetwork_2:
   \   00001C   E9           MOV       A,R1
   \   00001D   90....       MOV       DPTR,#bdbAttributes + 14
   \   000020   F0           MOVX      @DPTR,A
   2854              
   2855              osal_nv_write(ZCD_NV_BDBNODEISONANETWORK,0,sizeof(bdbAttributes.bdbNodeIsOnANetwork),&bdbAttributes.bdbNodeIsOnANetwork);
   \   000021                ; Setup parameters for call to function osal_nv_write
   \   000021   75....       MOV       ?V0,#(bdbAttributes + 14) & 0xff
   \   000024   75....       MOV       ?V1,#((bdbAttributes + 14) >> 8) & 0xff
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   75..01       MOV       ?V0,#0x1
   \   00002F   75..00       MOV       ?V1,#0x0
   \   000032   78..         MOV       R0,#?V0
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000037   12....       LCALL     ?Subroutine36 & 0xFFFF
   2856            }
   \                     ??CrossCallReturnLabel_121:
   \   00003A   12....       LCALL     ?DEALLOC_XSTACK8
   2857          }
   \                     ??bdb_setNodeIsOnANetwork_1:
   \   00003D   02....       LJMP      ??Subroutine45_0 & 0xFFFF
   2858          
   2859          /*********************************************************************
   2860           * @fn          bdb_setCommissioningGroupID
   2861           *
   2862           * @brief       Sets the commissioning groupd ID
   2863           *
   2864           * @param       groupID
   2865           *
   2866           * @return      none
   2867           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004                REQUIRE ??Subroutine52_0
   \   000004                ; // Fall through to label ??Subroutine52_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2868          void bdb_setCommissioningGroupID(uint16 groupID)
   \                     bdb_setCommissioningGroupID:
   2869          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2870            bdbAttributes.bdbCommissioningGroupID = groupID;
   \   000004   90....       MOV       DPTR,#bdbAttributes + 8
   \   000007   02....       LJMP      ?Subroutine4 & 0xFFFF
   2871          }
   2872          
   2873          /*********************************************************************
   2874           * @fn      bdb_CreateRespondentList
   2875           *
   2876           * @brief   Create respondent list for finding and binding if empty
   2877           *
   2878           * @param   pHead - pointer to a pointer of the list head
   2879           *
   2880           * @return  none
   2881           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2882          void bdb_CreateRespondentList( bdbFindingBindingRespondent_t **pHead )
   \                     bdb_CreateRespondentList:
   2883          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2884          
   2885            // Create the list if empty
   2886            if ( *pHead == NULL )
   \   000009   8A82         MOV       DPL,R2
   \   00000B   F583         MOV       DPH,A
   \   00000D   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000010   7008         JNZ       ??CrossCallReturnLabel_43
   2887            {
   2888              *pHead = ( bdbFindingBindingRespondent_t* )osal_mem_alloc( sizeof( bdbFindingBindingRespondent_t ) );
   \   000012                ; Setup parameters for call to function osal_mem_alloc
   \   000012   12....       LCALL     ?Subroutine11 & 0xFFFF
   2889              
   2890              if ( *pHead != NULL )
   \                     ??CrossCallReturnLabel_131:
   \   000015   6003         JZ        ??CrossCallReturnLabel_43
   2891              {
   2892                (*pHead)->pNext = NULL;
   \   000017   12....       LCALL     ?Subroutine38 & 0xFFFF
   2893              }
   2894            }
   2895            return;
   \                     ??CrossCallReturnLabel_43:
   \   00001A   02....       LJMP      ??Subroutine45_0 & 0xFFFF
   2896          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   7A11         MOV       R2,#0x11
   \   000002   7B00         MOV       R3,#0x0
   \   000004   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000007   8B..         MOV       ?V1,R3
   \   000009   A9..         MOV       R1,?V1
   \   00000B                REQUIRE ??Subroutine64_0
   \   00000B                ; // Fall through to label ??Subroutine64_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   EA           MOV       A,R2
   \   000001   240F         ADD       A,#0xf
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   39           ADDC      A,R1
   \   000007   F583         MOV       DPH,A
   \   000009   E4           CLR       A
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   A3           INC       DPTR
   \   00000C   F0           MOVX      @DPTR,A
   \   00000D   22           RET
   2897          
   2898          /*********************************************************************
   2899           * @fn      bdb_AddRespondentNode
   2900           *
   2901           * @brief   Add node to respondent list for finding and binding
   2902           *
   2903           * @param   pHead - pointer to a pointer of the list head
   2904           *
   2905           * @return  pointer to new node
   2906           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2907          bdbFindingBindingRespondent_t* bdb_AddRespondentNode( bdbFindingBindingRespondent_t **pHead, zclIdentifyQueryRsp_t *pCmd )
   \                     bdb_AddRespondentNode:
   2908          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2909            bdbFindingBindingRespondent_t **pCurr;
   2910            bdbFindingBindingRespondent_t *temp;
   2911            
   2912              // Create respondent list if empty
   2913            if ( *pHead == NULL )
   \   000009   8A82         MOV       DPL,R2
   \   00000B   F583         MOV       DPH,A
   \   00000D   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000010   7006         JNZ       ??bdb_AddRespondentNode_0
   2914            {
   2915              bdb_CreateRespondentList( pHead );
   \   000012                ; Setup parameters for call to function bdb_CreateRespondentList
   \   000012   12....       LCALL     `??bdb_CreateRespondentList::?relay`; Banked call to: bdb_CreateRespondentList
   2916              return *pHead;
   \   000015   02....       LJMP      ??CrossCallReturnLabel_44 & 0xFFFF
   2917            }
   2918            else
   2919            {
   2920              // if pCmd is equal to NULL, don't look for duplucates
   2921              if( pCmd != NULL )
   \                     ??bdb_AddRespondentNode_0:
   \   000018   EC           MOV       A,R4
   \   000019   4D           ORL       A,R5
   \   00001A   606D         JZ        ??bdb_AddRespondentNode_1
   2922              {
   2923                //Find if any duplicate in the list
   2924                temp = *pHead;
   \   00001C   E8           MOV       A,R0
   \   00001D   FA           MOV       R2,A
   \   00001E   E9           MOV       A,R1
   \   00001F   FB           MOV       R3,A
   \   000020   8C82         MOV       DPL,R4
   \   000022   8D83         MOV       DPH,R5
   \   000024   E0           MOVX      A,@DPTR
   \   000025   FC           MOV       R4,A
   \   000026   A3           INC       DPTR
   \   000027   E0           MOVX      A,@DPTR
   \   000028   FD           MOV       R5,A
   2925                
   2926                while(temp != NULL)
   2927                {
   2928                  if((temp->data.endPoint == pCmd->srcAddr->endPoint) && (temp->data.panId == pCmd->srcAddr->panId))
   \                     ??bdb_AddRespondentNode_2:
   \   000029   8A82         MOV       DPL,R2
   \   00002B   8B83         MOV       DPH,R3
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   E0           MOVX      A,@DPTR
   \   000037   FE           MOV       R6,A
   \   000038   8C82         MOV       DPL,R4
   \   00003A   8D83         MOV       DPH,R5
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   6E           XRL       A,R6
   \   000047   7034         JNZ       ??bdb_AddRespondentNode_3
   \   000049   8A82         MOV       DPL,R2
   \   00004B   8B83         MOV       DPH,R3
   \   00004D   A3           INC       DPTR
   \   00004E   A3           INC       DPTR
   \   00004F   A3           INC       DPTR
   \   000050   A3           INC       DPTR
   \   000051   A3           INC       DPTR
   \   000052   A3           INC       DPTR
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   A3           INC       DPTR
   \   00005E   A3           INC       DPTR
   \   00005F   A3           INC       DPTR
   \   000060   A3           INC       DPTR
   \   000061   A3           INC       DPTR
   \   000062   A3           INC       DPTR
   \   000063   A3           INC       DPTR
   \   000064   E0           MOVX      A,@DPTR
   \   000065   6E           XRL       A,R6
   \   000066   7003         JNZ       ??bdb_AddRespondentNode_4
   \   000068   A3           INC       DPTR
   \   000069   E0           MOVX      A,@DPTR
   \   00006A   6F           XRL       A,R7
   \                     ??bdb_AddRespondentNode_4:
   \   00006B   7010         JNZ       ??bdb_AddRespondentNode_3
   2929                  {
   2930                    //Duplicate
   2931                    if(temp->data.addr.shortAddr == pCmd->srcAddr->addr.shortAddr)
   \   00006D   8A82         MOV       DPL,R2
   \   00006F   8B83         MOV       DPH,R3
   \   000071   12....       LCALL     ?Subroutine32 & 0xFFFF
   2932                    {
   2933                      return NULL;
   2934                    }
   2935                  }
   \                     ??CrossCallReturnLabel_31:
   \   000074   E0           MOVX      A,@DPTR
   \   000075   6E           XRL       A,R6
   \   000076   7003         JNZ       ??bdb_AddRespondentNode_5
   \   000078   A3           INC       DPTR
   \   000079   E0           MOVX      A,@DPTR
   \   00007A   6F           XRL       A,R7
   \                     ??bdb_AddRespondentNode_5:
   \   00007B   6021         JZ        ??bdb_AddRespondentNode_6
   2936                  temp = temp->pNext;
   \                     ??bdb_AddRespondentNode_3:
   \   00007D   EA           MOV       A,R2
   \   00007E   240F         ADD       A,#0xf
   \   000080   F582         MOV       DPL,A
   \   000082   E4           CLR       A
   \   000083   3B           ADDC      A,R3
   \   000084   12....       LCALL     ?Subroutine21 & 0xFFFF
   2937                }
   2938              }
   \                     ??CrossCallReturnLabel_138:
   \   000087   70A0         JNZ       ??bdb_AddRespondentNode_2
   2939              
   2940              pCurr = &((*pHead)->pNext);
   2941              
   2942              while ( *pCurr != NULL )
   2943              {
   2944                pCurr = &((*pCurr)->pNext);
   \                     ??bdb_AddRespondentNode_1:
   \   000089   E8           MOV       A,R0
   \   00008A   240F         ADD       A,#0xf
   \   00008C   FE           MOV       R6,A
   \   00008D   E4           CLR       A
   \   00008E   39           ADDC      A,R1
   \   00008F   FF           MOV       R7,A
   2945              }
   \   000090   8E82         MOV       DPL,R6
   \   000092   8F83         MOV       DPH,R7
   \   000094   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000097   70F0         JNZ       ??bdb_AddRespondentNode_1
   2946          
   2947              *pCurr = ( bdbFindingBindingRespondent_t* )osal_mem_alloc( sizeof( bdbFindingBindingRespondent_t ) );
   \   000099                ; Setup parameters for call to function osal_mem_alloc
   \   000099   12....       LCALL     ?Subroutine11 & 0xFFFF
   2948              
   2949              if(*pCurr == NULL)
   \                     ??CrossCallReturnLabel_132:
   \   00009C   7006         JNZ       ??bdb_AddRespondentNode_7
   2950              {
   2951                //No memory
   2952                return NULL;
   \                     ??bdb_AddRespondentNode_6:
   \   00009E   7A00         MOV       R2,#0x0
   \   0000A0   7B00         MOV       R3,#0x0
   \   0000A2   800A         SJMP      ??CrossCallReturnLabel_26
   2953              }
   2954              
   2955              (*pCurr)->pNext = NULL;
   \                     ??bdb_AddRespondentNode_7:
   \   0000A4   12....       LCALL     ?Subroutine38 & 0xFFFF
   2956            }
   2957            
   2958            return *pCurr;
   \                     ??CrossCallReturnLabel_44:
   \   0000A7   8E82         MOV       DPL,R6
   \   0000A9   8F83         MOV       DPH,R7
   \   0000AB   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0000AE   02....       LJMP      ??Subroutine45_0 & 0xFFFF
   2959          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL     ??Subroutine65_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000003   8C82         MOV       DPL,R4
   \   000005   8D83         MOV       DPH,R5
   \   000007   22           RET
   2960          
   2961          /*********************************************************************
   2962           * @fn      bdb_zclRespondentListClean
   2963           *
   2964           * @brief   This function free reserved memory for respondent list
   2965           *
   2966           * @param   pHead - begin of the respondent list
   2967           *
   2968           * @return  status
   2969           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2970          void bdb_zclRespondentListClean( bdbFindingBindingRespondent_t **pHead )
   \                     bdb_zclRespondentListClean:
   2971          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   2972            bdbFindingBindingRespondent_t **pCurr;
   2973            bdbFindingBindingRespondent_t **pNext;
   2974            
   2975            if ( *pHead == NULL )
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   12....       LCALL     ??Subroutine58_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000010   6031         JZ        ??bdb_zclRespondentListClean_0
   2976            {
   2977              return;
   2978            }
   2979            
   2980            pCurr = pHead;
   \   000012   AE..         MOV       R6,?V0
   \   000014   AF..         MOV       R7,?V1
   \   000016   8018         SJMP      ??bdb_zclRespondentListClean_1
   2981            
   2982            while( *pCurr != NULL )
   2983            {
   2984              pNext = &((*pCurr)->pNext);
   \                     ??bdb_zclRespondentListClean_2:
   \   000018   EA           MOV       A,R2
   \   000019   240F         ADD       A,#0xf
   \   00001B   F5..         MOV       ?V2,A
   \   00001D   E4           CLR       A
   \   00001E   3B           ADDC      A,R3
   \   00001F   F5..         MOV       ?V3,A
   2985              osal_mem_free( *pCurr );
   \   000021                ; Setup parameters for call to function osal_mem_free
   \   000021   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2986              *pCurr = ( bdbFindingBindingRespondent_t* )NULL;
   \   000024   8E82         MOV       DPL,R6
   \   000026   8F83         MOV       DPH,R7
   \   000028   E4           CLR       A
   \   000029   F0           MOVX      @DPTR,A
   \   00002A   A3           INC       DPTR
   \   00002B   F0           MOVX      @DPTR,A
   2987              pCurr = pNext;
   \   00002C   AE..         MOV       R6,?V2
   \   00002E   AF..         MOV       R7,?V3
   2988            }
   \                     ??bdb_zclRespondentListClean_1:
   \   000030   8E82         MOV       DPL,R6
   \   000032   8F83         MOV       DPH,R7
   \   000034   12....       LCALL     ??Subroutine66_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000037   70DF         JNZ       ??bdb_zclRespondentListClean_2
   2989            *pHead = NULL;
   \   000039   85..82       MOV       DPL,?V0
   \   00003C   85..83       MOV       DPH,?V1
   \   00003F   E4           CLR       A
   \   000040   F0           MOVX      @DPTR,A
   \   000041   A3           INC       DPTR
   \   000042   F0           MOVX      @DPTR,A
   2990          }
   \                     ??bdb_zclRespondentListClean_0:
   \   000043   02....       LJMP      ??Subroutine57_0 & 0xFFFF
   2991          
   2992           /*********************************************************************
   2993           * PRIVATE FUNCTIONS
   2994           *********************************************************************/
   2995          
   2996          /*********************************************************************
   2997           * @fn      bdb_ProcessOSALMsg
   2998           *
   2999           * @brief   Process the incoming task message.
   3000           *
   3001           * @param   msgPtr - message to process
   3002           *
   3003           * @return  none
   3004           */
   3005          void bdb_ProcessOSALMsg( bdbInMsg_t *msgPtr )
   3006          {
   3007            
   3008            switch(msgPtr->hdr.event)
   3009            {
   3010          #if (ZG_BUILD_JOINING_TYPE)
   3011              case BDB_COMMISSIONING_STATE_JOINING:
   3012                if(ZG_DEVICE_JOINING_TYPE)
   3013                {
   3014                  switch(msgPtr->buf[0])
   3015                  {
   3016                    case BDB_JOIN_EVENT_NWK_DISCOVERY:
   3017                      if(msgPtr->hdr.status == BDB_MSG_EVENT_SUCCESS)
   3018                      {
   3019                        bdb_filterNwkDisc();
   3020                        bdb_tryNwkAssoc();
   3021                      }
   3022                      else
   3023                      {
   3024                        bdb_nwkDiscoveryAttempt(FALSE);
   3025                      }
   3026                    break;
   3027                    
   3028                    case BDB_JOIN_EVENT_ASSOCIATION:
   3029                      if(msgPtr->hdr.status == BDB_MSG_EVENT_SUCCESS)
   3030                      {
   3031                        bdbCommissioningProcedureState.bdbJoinState = BDB_JOIN_STATE_WAITING_NWK_KEY;
   3032                        //Nwk key timeout get right timing
   3033                        osal_start_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT, BDB_DEFAULT_DEVICE_UNAUTH_TIMEOUT);
   3034                      }
   3035                      else
   3036                      {
   3037                        if ( (NLME_GetShortAddr() != INVALID_NODE_ADDR) ||
   3038                             (_NIB.nwkDevAddress != INVALID_NODE_ADDR) )
   3039                        {
   3040                          uint16 addr = INVALID_NODE_ADDR;
   3041                          // Invalidate nwk addr so end device does not use in its data reqs.
   3042                          _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   3043                          ZMacSetReq( ZMacShortAddress, (uint8 *)&addr );
   3044                        }
   3045          
   3046                        //Clear the neighbor Table and network discovery tables.
   3047                        nwkNeighborInitTable();
   3048                        NLME_NwkDiscTerm();
   3049                        _NIB.nwkState = NWK_INIT;
   3050                        
   3051                        bdb_tryNwkAssoc();
   3052                      }
   3053                    break;
   3054                  }
   3055                }
   3056              break;
   3057              
   3058              case BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE:
   3059                if(ZG_DEVICE_JOINING_TYPE)
   3060                {
   3061                  if(msgPtr->hdr.status != BDB_MSG_EVENT_SUCCESS)
   3062                  {
   3063                    bdbAttributes.bdbTCLinkKeyExchangeAttempts++;
   3064                    if(bdbAttributes.bdbTCLinkKeyExchangeAttempts > bdbAttributes.bdbTCLinkKeyExchangeAttemptsMax)
   3065                    {
   3066                      //TCLK process fail due to many attempts fails
   3067                      bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE, FALSE);
   3068                      return;
   3069                    }
   3070                  }
   3071                  switch(bdbCommissioningProcedureState.bdbTCExchangeState)
   3072                  {
   3073                    case BDB_REQ_TC_STACK_VERSION:
   3074                      bdb_requestTCStackVersion();
   3075                    break;
   3076                    case BDB_REQ_TC_LINK_KEY:
   3077                      bdb_requestTCLinkKey();
   3078                    break;
   3079                    case BDB_REQ_VERIFY_TC_LINK_KEY:
   3080                      bdb_requestVerifyTCLinkKey();
   3081                    break;
   3082                  }
   3083                }
   3084             break;
   3085          #endif
   3086             }
   3087          }
   3088          
   3089          
   3090          /*********************************************************************
   3091           * @fn      bdb_processTimeout
   3092           *
   3093           * @brief   Handles timeout of the bdb process
   3094           *
   3095           * @param   msgPtr - message to process
   3096           *
   3097           * @return  none
   3098           */
   3099          void bdb_processTimeout(void)
   3100          {
   3101          #if (ZG_BUILD_JOINING_TYPE)
   3102            if(ZG_DEVICE_JOINING_TYPE)
   3103            {
   3104              switch(bdbCommissioningProcedureState.bdbCommissioningState)
   3105              {
   3106                case BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE:
   3107                  
   3108                  bdb_tcLinkKeyExchangeAttempt(FALSE,bdbCommissioningProcedureState.bdbTCExchangeState);
   3109                break;
   3110                case BDB_COMMISSIONING_STATE_JOINING:
   3111                  if(bdbCommissioningProcedureState.bdbJoinState == BDB_JOIN_STATE_WAITING_NWK_KEY)
   3112                  {
   3113                    //If nwk key fails, then try association again
   3114                    bdbCommissioningProcedureState.bdbJoinState = BDB_JOIN_STATE_ASSOC;
   3115                    bdb_nwkAssocAttemt(FALSE);
   3116                  }
   3117                break;
   3118              }
   3119            }
   3120          #endif
   3121            
   3122          }
   3123          
   3124          
   3125          /*********************************************************************
   3126           * @fn      bdb_SendMsg
   3127           *
   3128           * @brief   Send messages to bdb processing with the expected format
   3129           *
   3130           * @param   msgPtr - message to process
   3131           *
   3132           * @return  none
   3133           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3134          void bdb_SendMsg(uint8 taskID, uint8 toCommissioningState,uint8 status, uint8 len, uint8 *buf)
   \                     bdb_SendMsg:
   3135          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   85..82       MOV       DPL,?XSP + 0
   \   00000E   85..83       MOV       DPH,?XSP + 1
   \   000011   F0           MOVX      @DPTR,A
   \   000012   8A..         MOV       ?V7,R2
   \   000014   8B..         MOV       ?V6,R3
   \   000016   8C..         MOV       ?V3,R4
   3136            bdbInMsg_t *msgPtr = NULL;
   3137          
   3138            if ( (len > 0) && (buf != NULL) )
   \   000018   EC           MOV       A,R4
   \   000019   6056         JZ        ??bdb_SendMsg_0
   \   00001B   7411         MOV       A,#0x11
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000023   E5..         MOV       A,?V0
   \   000025   45..         ORL       A,?V1
   \   000027   6048         JZ        ??bdb_SendMsg_0
   3139            {
   3140              uint8 tmpLength;
   3141              tmpLength = len;
   3142              tmpLength += sizeof(osal_event_hdr_t);
   3143              
   3144              msgPtr = (bdbInMsg_t *)osal_msg_allocate( tmpLength );
   \   000029                ; Setup parameters for call to function osal_msg_allocate
   \   000029   7402         MOV       A,#0x2
   \   00002B   2C           ADD       A,R4
   \   00002C   FA           MOV       R2,A
   \   00002D   7B00         MOV       R3,#0x0
   \   00002F   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   000032   8A..         MOV       ?V4,R2
   \   000034   8B..         MOV       ?V5,R3
   \   000036   AE..         MOV       R6,?V4
   \   000038   AF..         MOV       R7,?V5
   3145              
   3146              if ( msgPtr )
   \   00003A   EA           MOV       A,R2
   \   00003B   4F           ORL       A,R7
   \   00003C   6033         JZ        ??bdb_SendMsg_0
   3147              {
   3148                osal_memcpy( msgPtr->buf, buf, len );
   \   00003E                ; Setup parameters for call to function osal_memcpy
   \   00003E   75..00       MOV       ?V2,#0x0
   \   000041   78..         MOV       R0,#?V0
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000046   AC..         MOV       R4,?V3
   \   000048   7D00         MOV       R5,#0x0
   \   00004A   EA           MOV       A,R2
   \   00004B   2402         ADD       A,#0x2
   \   00004D   FA           MOV       R2,A
   \   00004E   E4           CLR       A
   \   00004F   3F           ADDC      A,R7
   \   000050   FB           MOV       R3,A
   \   000051   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000054   12....       LCALL     ?DEALLOC_XSTACK8
   3149              
   3150                msgPtr->hdr.event = toCommissioningState;
   \   000057   8E82         MOV       DPL,R6
   \   000059   8F83         MOV       DPH,R7
   \   00005B   E5..         MOV       A,?V7
   \   00005D   F0           MOVX      @DPTR,A
   3151                msgPtr->hdr.status = status;
   \   00005E   A3           INC       DPTR
   \   00005F   E5..         MOV       A,?V6
   \   000061   F0           MOVX      @DPTR,A
   3152                osal_msg_send( taskID, (uint8 *)msgPtr );
   \   000062                ; Setup parameters for call to function osal_msg_send
   \   000062   EE           MOV       A,R6
   \   000063   FA           MOV       R2,A
   \   000064   EF           MOV       A,R7
   \   000065   FB           MOV       R3,A
   \   000066   85..82       MOV       DPL,?XSP + 0
   \   000069   85..83       MOV       DPH,?XSP + 1
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   F9           MOV       R1,A
   \   00006E   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   3153              }
   3154            }
   3155          }
   \                     ??bdb_SendMsg_0:
   \   000071   7401         MOV       A,#0x1
   \   000073                REQUIRE ?Subroutine6
   \   000073                ; // Fall through to label ?Subroutine6
   3156          
   3157          
   3158          /*********************************************************************
   3159           * @fn      bdb_RegisterCommissioningStatusCB
   3160           *
   3161           * @brief   Register a callback in which the status of the procedures done in
   3162           *          BDB commissioning process will be reported
   3163           *
   3164           * @param   bdbGCB_CommissioningStatus - application callback
   3165           *
   3166           * @return  none
   3167           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3168          void bdb_RegisterCommissioningStatusCB(bdbGCB_CommissioningStatus_t bdbGCB_CommissioningStatus)
   \                     bdb_RegisterCommissioningStatusCB:
   3169          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3170            pfnCommissioningStatusCB = bdbGCB_CommissioningStatus;
   \   000004   90....       MOV       DPTR,#pfnCommissioningStatusCB
   \   000007   02....       LJMP      ?Subroutine4 & 0xFFFF
   3171          }
   3172          
   3173          /*********************************************************************
   3174           * @fn      bdb_ClearNetworkParams
   3175           *
   3176           * @brief   Restore nwk parameters to invalid if the device is not on a network
   3177           *
   3178           * @param   void
   3179           *
   3180           * @return  void
   3181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3182          void bdb_ClearNetworkParams(void)
   \                     bdb_ClearNetworkParams:
   3183          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3184          #if (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE)
   3185            if ( bdbAttributes.bdbNodeIsOnANetwork == FALSE )
   3186            {
   3187              //Clear the event
   3188              _NIB.nwkPanId = INVALID_NODE_ADDR;
   3189              _NIB.nwkLogicalChannel = 0;
   3190              _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   3191              touchLink_SetMacNwkParams( _NIB.nwkDevAddress, _NIB.nwkPanId, _NIB.nwkLogicalChannel );
   3192            }
   3193          #endif
   3194          }
   \   000000   02....       LJMP      ?BRET
   3195          
   3196          /*********************************************************************
   3197           * @fn      bdb_getZCLFrameCounter
   3198           *
   3199           * @brief   Get the next ZCL Frame Counter for packet sequence number
   3200           *
   3201           * @param   none
   3202           *
   3203           * @return  next ZCL frame counter
   3204           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3205          uint8 bdb_getZCLFrameCounter(void)
   \                     bdb_getZCLFrameCounter:
   3206          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3207            bdb_ZclTransactionSequenceNumber++;
   \   000004   90....       MOV       DPTR,#bdb_ZclTransactionSequenceNumber
   \   000007   E0           MOVX      A,@DPTR
   \   000008   04           INC       A
   \   000009   F0           MOVX      @DPTR,A
   3208            return bdb_ZclTransactionSequenceNumber;
   \   00000A   02....       LJMP      ??Subroutine55_0 & 0xFFFF
   3209          
   3210          }
   3211          
   3212          
   3213          #if (ZG_BUILD_JOINING_TYPE)
   3214          /*********************************************************************
   3215           * @fn      bdb_RegisterCBKETCLinkKeyExchangeCB
   3216           *
   3217           * @brief   Register a callback in which the TC link key exchange procedure will 
   3218           *          be performed by application.
   3219           *          Upon fail or success bdb must be notified, see bdb_CBKETCLinkKeyExchangeAttempt
   3220           *
   3221           * @param   bdbGCB_TCLinkKeyExchangeMethod - application callback
   3222           *
   3223           * @return  none
   3224           */
   3225          void bdb_RegisterCBKETCLinkKeyExchangeCB(bdbGCB_CBKETCLinkKeyExchange_t bdbGCB_CBKETCLinkKeyExchange)
   3226          {
   3227            if(bdbGCB_CBKETCLinkKeyExchange)
   3228            {
   3229              pfnCBKETCLinkKeyExchange = bdbGCB_CBKETCLinkKeyExchange;
   3230              bdbAttributes.bdbTCLinkKeyExchangeMethod = BDB_TC_LINK_KEY_EXCHANGE_CBKE;
   3231            }
   3232            else
   3233            {
   3234              pfnCBKETCLinkKeyExchange = NULL;
   3235              bdbAttributes.bdbTCLinkKeyExchangeMethod = BDB_TC_LINK_KEY_EXCHANGE_APS_KEY;
   3236            }
   3237          }
   3238          
   3239          /*********************************************************************
   3240           * @fn      bdb_RegisterForFilterNwkDescCB
   3241           *
   3242           * @brief   Register a callback in which the application gets the list of network
   3243           *          descriptors got from active scan.
   3244           *          Use bdb_nwkDescFree to release the network descriptors that are not 
   3245           *          of interest and leave those which are to be attempted.
   3246           *
   3247           * @param   bdbGCB_FilterNwkDesc - application callback
   3248           *
   3249           * @return  none
   3250           */
   3251          void bdb_RegisterForFilterNwkDescCB(bdbGCB_FilterNwkDesc_t bdbGCB_FilterNwkDesc)
   3252          {
   3253            if(bdbGCB_FilterNwkDesc)
   3254            {
   3255              pfnFilterNwkDesc = bdbGCB_FilterNwkDesc;
   3256            }
   3257          }
   3258          
   3259          
   3260          /*********************************************************************
   3261           * @fn          bdb_CBKETCLinkKeyExchangeAttempt
   3262           *
   3263           * @brief       Tell BDB module the result of the TC link key exchange, to try
   3264           *              the default process or to keep going with the joining process.
   3265           *
   3266           * @param       didSuccess - TRUE if the process was succes, False otherwise
   3267           *
   3268           * @return      unprocessed events
   3269           */
   3270          void bdb_CBKETCLinkKeyExchangeAttempt(bool didSuccess)
   3271          {
   3272            if(didSuccess)
   3273            {
   3274              bdb_setNodeJoinLinkKeyType(BDB_DEFAULT_GLOBAL_TRUST_CENTER_LINK_KEY);
   3275              bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE, TRUE);
   3276            }
   3277            else
   3278            {
   3279              bdbAttributes.bdbTCLinkKeyExchangeMethod = BDB_TC_LINK_KEY_EXCHANGE_APS_KEY;
   3280              //We are going back one state to try it again
   3281              bdbCommissioningProcedureState.bdbTCExchangeState -= BDB_TC_EXCHANGE_NEXT_STATE;
   3282              bdb_tcLinkKeyExchangeAttempt(TRUE,BDB_REQ_TC_STACK_VERSION);
   3283            }
   3284          
   3285          }
   3286          #endif
   3287          
   3288          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
   3289          
   3290          /*********************************************************************
   3291           * @fn      gp_ChangeChannelReq
   3292           *
   3293           * @brief   Callback function to notify the BDB about a GP commissioning 
   3294           * request that will change the current channel for at most 
   3295           * gpBirectionalCommissioningChangeChannelTimeout ms
   3296           *
   3297           * @param   channel - Channel in which the commissioning will take place
   3298           *
   3299           * @return  TRUE to allow change channel, FALSE to do not allow
   3300           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3301          static uint8 gp_ChangeChannelReq(void)
   \                     gp_ChangeChannelReq:
   3302          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3303            uint8 allowChangeChannel = TRUE;
   \   000004   7901         MOV       R1,#0x1
   3304            
   3305            //Do not allow changes of channel if any process is in place
   3306            if(bdbAttributes.bdbCommissioningMode)
   \   000006   90....       MOV       DPTR,#bdbAttributes + 11
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   6002         JZ        ??gp_ChangeChannelReq_0
   3307            {
   3308              allowChangeChannel = FALSE;
   \   00000C   7900         MOV       R1,#0x0
   3309            }
   3310            
   3311            //Check application state to decide if allow change channel or not
   3312            
   3313            return allowChangeChannel;
   \                     ??gp_ChangeChannelReq_0:
   \   00000E   02....       LJMP      ??Subroutine53_0 & 0xFFFF
   3314          }
   3315          
   3316          
   3317          /*********************************************************************
   3318           * @fn          gp_CBInit
   3319           *
   3320           * @brief       Register the callbacks for GP endpoint
   3321           *
   3322           * @param       none
   3323           *
   3324           * @return      none
   3325           */
   3326          void gp_CBInit(void)
   3327          {
   3328            GP_DataCnfGCB = GP_DataCnf;
   3329            GP_endpointInitGCB = gp_endpointInit;  
   3330            GP_expireDuplicateFilteringGCB = gp_expireDuplicateFiltering;
   3331            GP_stopCommissioningModeGCB = gp_stopCommissioningMode;
   3332            GP_returnOperationalChannelGCB = gp_returnOperationalChannel;
   3333            GP_DataIndGCB = GP_DataInd;
   3334            GP_SecReqGCB = GP_SecReq;   
   3335            GP_CheckAnnouncedDeviceGCB = gp_CheckAnnouncedDevice;
   3336              
   3337            GP_aliasConflictAnnce = &aliasConflictAnnce;
   3338            
   3339            GP_endpointInitGCB();
   3340          }
   3341          
   3342          #endif
   3343          
   3344          /*********************************************************************
   3345          *********************************************************************/
   3346          
   3347          
   3348          /******************************************************************************
   3349           * @fn          bdb_GenerateInstallCodeCRC
   3350           *
   3351           * @brief       Creates a CRC for the install code passed.
   3352           *
   3353           * @param       installCode - install code from which CRC will be generated
   3354           *
   3355           * @return      CRC
   3356           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3357          uint16 bdb_GenerateInstallCodeCRC(uint8 *installCode)
   \                     bdb_GenerateInstallCodeCRC:
   3358          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV       A,#-0x2
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3359            uint16 CRC;
   3360            
   3361            bdb_calculateCCITT_CRC(installCode, INSTALL_CODE_LEN, &CRC);
   \   000009                ; Setup parameters for call to function bdb_calculateCCITT_CRC
   \   000009   90....       MOV       DPTR,#__Constant_10
   \   00000C   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00000F   7404         MOV       A,#0x4
   \   000011   12....       LCALL     ?XSTACK_DISP102_8
   \   000014   12....       LCALL     `??bdb_calculateCCITT_CRC::?relay`; Banked call to: bdb_calculateCCITT_CRC
   \   000017   7404         MOV       A,#0x4
   \   000019   12....       LCALL     ?DEALLOC_XSTACK8
   3362          
   3363            return CRC;
   \   00001C   85..82       MOV       DPL,?XSP + 0
   \   00001F   85..83       MOV       DPH,?XSP + 1
   \   000022   12....       LCALL     ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000025   7402         MOV       A,#0x2
   \   000027   02....       LJMP      ?Subroutine7 & 0xFFFF
   3364          }
   3365          
   3366          /******************************************************************************
   3367           * @fn          bdb_calculateCCITT_CRC
   3368           *
   3369           * @brief       Creates a CRC for the install code passed.
   3370           *
   3371           * @param       Mb - install code from which CRC will be generated
   3372           * @param       msglen - install code length
   3373           * @param       crc - 
   3374           *
   3375           * @return      none
   3376           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3377          void bdb_calculateCCITT_CRC (uint8 *Mb, uint32 msglen, uint16 *crc)
   \                     bdb_calculateCCITT_CRC:
   3378          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   3379            uint16 crcinit_direct; 
   3380            uint16 crcinit_nondirect;
   3381            bdb_crcInit(crc, &crcinit_direct, &crcinit_nondirect);
   \   000012                ; Setup parameters for call to function bdb_crcInit
   \   000012   A8..         MOV       R0,?XSP + 0
   \   000014   A9..         MOV       R1,?XSP + 1
   \   000016   88..         MOV       ?V2,R0
   \   000018   89..         MOV       ?V3,R1
   \   00001A   78..         MOV       R0,#?V2
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   7404         MOV       A,#0x4
   \   000021   12....       LCALL     ?XSTACK_DISP102_8
   \   000024   EE           MOV       A,R6
   \   000025   FA           MOV       R2,A
   \   000026   EF           MOV       A,R7
   \   000027   FB           MOV       R3,A
   \   000028   12....       LCALL     `??bdb_crcInit::?relay`; Banked call to: bdb_crcInit
   \   00002B   7402         MOV       A,#0x2
   \   00002D   12....       LCALL     ?DEALLOC_XSTACK8
   3382            *crc = bdb_crcBitByBitFast(Mb, msglen, crcinit_direct, crcinit_nondirect);
   \   000030                ; Setup parameters for call to function bdb_crcBitByBitFast
   \   000030   85..82       MOV       DPL,?XSP + 0
   \   000033   85..83       MOV       DPH,?XSP + 1
   \   000036   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000039   7412         MOV       A,#0x12
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000041   7408         MOV       A,#0x8
   \   000043   12....       LCALL     ?XSTACK_DISP0_8
   \   000046   E0           MOVX      A,@DPTR
   \   000047   FC           MOV       R4,A
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   FD           MOV       R5,A
   \   00004B   AA..         MOV       R2,?V0
   \   00004D   AB..         MOV       R3,?V1
   \   00004F   12....       LCALL     `??bdb_crcBitByBitFast::?relay`; Banked call to: bdb_crcBitByBitFast
   \   000052   7406         MOV       A,#0x6
   \   000054   12....       LCALL     ?DEALLOC_XSTACK8
   \   000057   8E82         MOV       DPL,R6
   \   000059   8F83         MOV       DPH,R7
   \   00005B   12....       LCALL     ??Subroutine67_0 & 0xFFFF
   3383          }
   \                     ??CrossCallReturnLabel_146:
   \   00005E   02....       LJMP      ?Subroutine2 & 0xFFFF
   3384          
   3385          
   3386          /******************************************************************************
   3387           * @fn          bdb_crcInit
   3388           *
   3389           * @brief       Initialize CRC calculation
   3390           *
   3391           * @param       crc - 
   3392           * @param       crcinit_direct -
   3393           * @param       crcinit_nondirect - 
   3394           *
   3395           * @return      none
   3396           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3397          void bdb_crcInit(uint16 *crc, uint16 *crcinit_direct, uint16 *crcinit_nondirect)
   \                     bdb_crcInit:
   3398          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3399          
   3400            uint16 i;
   3401            uint16 bit;
   3402          
   3403            *crcinit_direct = CRC_INIT;
   \   000005   8C82         MOV       DPL,R4
   \   000007   8D83         MOV       DPH,R5
   \   000009   74FF         MOV       A,#-0x1
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   A3           INC       DPTR
   \   00000D   F0           MOVX      @DPTR,A
   3404            *crc = CRC_INIT;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   F0           MOVX      @DPTR,A
   \   000013   A3           INC       DPTR
   \   000014   F0           MOVX      @DPTR,A
   3405            for (i=0; i<CRC_ORDER; i++) 
   \   000015   7E10         MOV       R6,#0x10
   3406            {
   3407              bit = *crc & 1;
   \                     ??bdb_crcInit_0:
   \   000017   8A82         MOV       DPL,R2
   \   000019   8B83         MOV       DPH,R3
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F8           MOV       R0,A
   3408              if (bit) *crc^= CRC_POLYNOM;
   \   00001D   A2E0         MOV       C,0xE0 /* A   */.0
   \   00001F   5008         JNC       ??bdb_crcInit_1
   \   000021   6421         XRL       A,#0x21
   \   000023   F0           MOVX      @DPTR,A
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   6410         XRL       A,#0x10
   \   000028   F0           MOVX      @DPTR,A
   3409              *crc >>= 1;
   \                     ??bdb_crcInit_1:
   \   000029   8A82         MOV       DPL,R2
   \   00002B   8B83         MOV       DPH,R3
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   FC           MOV       R4,A
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   C3           CLR       C
   \   000032   13           RRC       A
   \   000033   FD           MOV       R5,A
   \   000034   EC           MOV       A,R4
   \   000035   13           RRC       A
   \   000036   8A82         MOV       DPL,R2
   \   000038   8B83         MOV       DPH,R3
   \   00003A   F0           MOVX      @DPTR,A
   \   00003B   A3           INC       DPTR
   \   00003C   ED           MOV       A,R5
   \   00003D   F0           MOVX      @DPTR,A
   3410              if (bit) *crc|= CRC_HIGHBIT;
   \   00003E   E8           MOV       A,R0
   \   00003F   A2E0         MOV       C,0xE0 /* A   */.0
   \   000041   5009         JNC       ??bdb_crcInit_2
   \   000043   8A82         MOV       DPL,R2
   \   000045   8B83         MOV       DPH,R3
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   4480         ORL       A,#0x80
   \   00004B   F0           MOVX      @DPTR,A
   3411            }	
   \                     ??bdb_crcInit_2:
   \   00004C   1E           DEC       R6
   \   00004D   EE           MOV       A,R6
   \   00004E   70C7         JNZ       ??bdb_crcInit_0
   3412            *crcinit_nondirect = *crc;
   \   000050   8A82         MOV       DPL,R2
   \   000052   8B83         MOV       DPH,R3
   \   000054   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000057   F9           MOV       R1,A
   \   000058   7409         MOV       A,#0x9
   \   00005A   12....       LCALL     ?XSTACK_DISP0_8
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   FA           MOV       R2,A
   \   00005F   A3           INC       DPTR
   \   000060   E0           MOVX      A,@DPTR
   \   000061   F583         MOV       DPH,A
   \   000063   8A82         MOV       DPL,R2
   \   000065   E8           MOV       A,R0
   \   000066   F0           MOVX      @DPTR,A
   \   000067   A3           INC       DPTR
   \   000068   E9           MOV       A,R1
   \   000069   F0           MOVX      @DPTR,A
   3413          
   3414          }
   \   00006A   02....       LJMP      ?Subroutine0 & 0xFFFF
   3415          
   3416          
   3417          /******************************************************************************
   3418           * @fn          bdb_crcReflect
   3419           *
   3420           * @brief       
   3421           *
   3422           * @param       crc - 
   3423           * @param       bitnum -
   3424           *
   3425           * @return      none
   3426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3427          uint16 bdb_crcReflect (uint16 crc, uint16 bitnum)
   \                     bdb_crcReflect:
   3428          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   3429          
   3430            // reflects the lower 'bitnum' bits of 'crc'
   3431          
   3432            uint16 i, j=1, crcout=0;
   \   000009   7A01         MOV       R2,#0x1
   \   00000B   7B00         MOV       R3,#0x0
   \   00000D   8B..         MOV       ?V2,R3
   \   00000F   8B..         MOV       ?V3,R3
   3433          
   3434            for (i=(uint16)1<<(bitnum-1); i; i>>=1) {
   \   000011   8A..         MOV       ?V0,R2
   \   000013   8B..         MOV       ?V1,R3
   \   000015   EC           MOV       A,R4
   \   000016   14           DEC       A
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?S_SHL
   \   00001C   A8..         MOV       R0,?V0
   \   00001E   A9..         MOV       R1,?V1
   \   000020   8022         SJMP      ??bdb_crcReflect_0
   3435              if (crc & i) crcout|=j;
   \                     ??bdb_crcReflect_1:
   \   000022   EE           MOV       A,R6
   \   000023   58           ANL       A,R0
   \   000024   FC           MOV       R4,A
   \   000025   EF           MOV       A,R7
   \   000026   59           ANL       A,R1
   \   000027   FD           MOV       R5,A
   \   000028   EC           MOV       A,R4
   \   000029   4D           ORL       A,R5
   \   00002A   600A         JZ        ??bdb_crcReflect_2
   \   00002C   EA           MOV       A,R2
   \   00002D   45..         ORL       A,?V2
   \   00002F   F5..         MOV       ?V2,A
   \   000031   EB           MOV       A,R3
   \   000032   45..         ORL       A,?V3
   \   000034   F5..         MOV       ?V3,A
   3436              j<<= 1;
   \                     ??bdb_crcReflect_2:
   \   000036   EA           MOV       A,R2
   \   000037   25E0         ADD       A,0xE0 /* A   */
   \   000039   FA           MOV       R2,A
   \   00003A   EB           MOV       A,R3
   \   00003B   33           RLC       A
   \   00003C   FB           MOV       R3,A
   3437            }
   \   00003D   E9           MOV       A,R1
   \   00003E   C3           CLR       C
   \   00003F   13           RRC       A
   \   000040   F9           MOV       R1,A
   \   000041   E8           MOV       A,R0
   \   000042   13           RRC       A
   \   000043   F8           MOV       R0,A
   \                     ??bdb_crcReflect_0:
   \   000044   E8           MOV       A,R0
   \   000045   49           ORL       A,R1
   \   000046   70DA         JNZ       ??bdb_crcReflect_1
   3438            return (crcout);
   \   000048   AA..         MOV       R2,?V2
   \   00004A   AB..         MOV       R3,?V3
   \   00004C   02....       LJMP      ??Subroutine57_0 & 0xFFFF
   3439          }
   3440          
   3441          
   3442          /******************************************************************************
   3443           * @fn          bdb_crcBitByBitFast
   3444           *
   3445           * @brief       
   3446           *
   3447           * @param       p - 
   3448           * @param       len -
   3449           * @param       crcinit_direct - 
   3450           * @param       crcinit_nondirect -
   3451           *
   3452           * @return      crc
   3453           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3454          uint16 bdb_crcBitByBitFast(uint8 * p, uint32 len, uint16 crcinit_direct, uint16 crcinit_nondirect) 
   \                     bdb_crcBitByBitFast:
   3455          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine12 & 0xFFFF
   3456            // fast bit by bit algorithm without augmented zero bytes.
   3457            // does not use lookup table, suited for polynom orders between 1...32.
   3458          
   3459            uint16 i, j, c, bit;
   3460            uint16 crc = crcinit_direct;
   \                     ??CrossCallReturnLabel_149:
   \   00000D   EC           MOV       A,R4
   \   00000E   FE           MOV       R6,A
   \   00000F   ED           MOV       A,R5
   \   000010   FF           MOV       R7,A
   3461          
   3462            for (i=0; i<len; i++) {
   \   000011   7402         MOV       A,#0x2
   \   000013   12....       LCALL     ?XSTACK_DISP0_8
   \   000016   E4           CLR       A
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   F0           MOVX      @DPTR,A
   \   00001A   7414         MOV       A,#0x14
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   78..         MOV       R0,#?V0
   \   000021   12....       LCALL     ?L_MOV_X
   \   000024   8065         SJMP      ??bdb_crcBitByBitFast_0
   3463          
   3464              c = (uint16)*p++;
   \                     ??bdb_crcBitByBitFast_1:
   \   000026   85..82       MOV       DPL,?XSP + 0
   \   000029   85..83       MOV       DPH,?XSP + 1
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   F8           MOV       R0,A
   \   00002E   A3           INC       DPTR
   \   00002F   12....       LCALL     ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000032   E0           MOVX      A,@DPTR
   \   000033   FA           MOV       R2,A
   \   000034   7B00         MOV       R3,#0x0
   \   000036   85..82       MOV       DPL,?XSP + 0
   \   000039   85..83       MOV       DPH,?XSP + 1
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   2401         ADD       A,#0x1
   \   00003F   08           INC       R0
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   3400         ADDC      A,#0x0
   \   000044   F9           MOV       R1,A
   \   000045   85..82       MOV       DPL,?XSP + 0
   \   000048   85..83       MOV       DPH,?XSP + 1
   \   00004B   E8           MOV       A,R0
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A3           INC       DPTR
   \   00004E   E9           MOV       A,R1
   \   00004F   F0           MOVX      @DPTR,A
   3465              c = bdb_crcReflect(c, 8);
   \   000050                ; Setup parameters for call to function bdb_crcReflect
   \   000050   7C08         MOV       R4,#0x8
   \   000052   7D00         MOV       R5,#0x0
   \   000054   12....       LCALL     `??bdb_crcReflect::?relay`; Banked call to: bdb_crcReflect
   3466          
   3467              for (j=0x80; j; j>>=1) {
   \   000057   7880         MOV       R0,#-0x80
   3468          
   3469                bit = crc & CRC_HIGHBIT;
   \                     ??bdb_crcBitByBitFast_2:
   \   000059   EF           MOV       A,R7
   \   00005A   5480         ANL       A,#0x80
   \   00005C   FD           MOV       R5,A
   3470                crc<<= 1;
   \   00005D   EE           MOV       A,R6
   \   00005E   25E0         ADD       A,0xE0 /* A   */
   \   000060   FE           MOV       R6,A
   \   000061   EF           MOV       A,R7
   \   000062   33           RLC       A
   \   000063   FF           MOV       R7,A
   3471                if (c & j) bit^= CRC_HIGHBIT;
   \   000064   EA           MOV       A,R2
   \   000065   58           ANL       A,R0
   \   000066   6004         JZ        ??bdb_crcBitByBitFast_3
   \   000068   7480         MOV       A,#-0x80
   \   00006A   6D           XRL       A,R5
   \   00006B   FD           MOV       R5,A
   3472                if (bit) crc^= CRC_POLYNOM;
   \                     ??bdb_crcBitByBitFast_3:
   \   00006C   ED           MOV       A,R5
   \   00006D   6008         JZ        ??bdb_crcBitByBitFast_4
   \   00006F   7421         MOV       A,#0x21
   \   000071   6E           XRL       A,R6
   \   000072   FE           MOV       R6,A
   \   000073   7410         MOV       A,#0x10
   \   000075   6F           XRL       A,R7
   \   000076   FF           MOV       R7,A
   3473              }
   \                     ??bdb_crcBitByBitFast_4:
   \   000077   C3           CLR       C
   \   000078   E8           MOV       A,R0
   \   000079   13           RRC       A
   \   00007A   F8           MOV       R0,A
   \   00007B   70DC         JNZ       ??bdb_crcBitByBitFast_2
   3474            }	
   \   00007D   7402         MOV       A,#0x2
   \   00007F   12....       LCALL     ?XSTACK_DISP0_8
   \   000082   E0           MOVX      A,@DPTR
   \   000083   2401         ADD       A,#0x1
   \   000085   F0           MOVX      @DPTR,A
   \   000086   A3           INC       DPTR
   \   000087   E0           MOVX      A,@DPTR
   \   000088   3400         ADDC      A,#0x0
   \   00008A   F0           MOVX      @DPTR,A
   \                     ??bdb_crcBitByBitFast_0:
   \   00008B   7402         MOV       A,#0x2
   \   00008D   12....       LCALL     ?XSTACK_DISP0_8
   \   000090   E0           MOVX      A,@DPTR
   \   000091   F5..         MOV       ?V4,A
   \   000093   A3           INC       DPTR
   \   000094   E0           MOVX      A,@DPTR
   \   000095   F5..         MOV       ?V5,A
   \   000097   E4           CLR       A
   \   000098   F5..         MOV       ?V6,A
   \   00009A   F5..         MOV       ?V7,A
   \   00009C   78..         MOV       R0,#?V0
   \   00009E   79..         MOV       R1,#?V4
   \   0000A0   12....       LCALL     ?UL_GT
   \   0000A3   4081         JC        ??bdb_crcBitByBitFast_1
   3475          
   3476            crc=bdb_crcReflect(crc, CRC_ORDER);
   3477            crc^= CRC_XOR;
   3478          
   3479            return(crc);
   \   0000A5                ; Setup parameters for call to function bdb_crcReflect
   \   0000A5   7C10         MOV       R4,#0x10
   \   0000A7   7D00         MOV       R5,#0x0
   \   0000A9   EE           MOV       A,R6
   \   0000AA   FA           MOV       R2,A
   \   0000AB   EF           MOV       A,R7
   \   0000AC   FB           MOV       R3,A
   \   0000AD   12....       LCALL     `??bdb_crcReflect::?relay`; Banked call to: bdb_crcReflect
   \   0000B0   EA           MOV       A,R2
   \   0000B1   F4           CPL       A
   \   0000B2   FA           MOV       R2,A
   \   0000B3   EB           MOV       A,R3
   \   0000B4   F4           CPL       A
   \   0000B5   FB           MOV       R3,A
   \   0000B6   7404         MOV       A,#0x4
   \   0000B8   02....       LJMP      ?Subroutine6 & 0xFFFF
   3480          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for bdbAttributes>`:
   \   000000   00F0FF07     DD 134213632
   \   000004   00080000     DD 2048
   \   000008   FFFF         DW 65535
   \   00000A   00           DB 0
   \   00000B   00           DB 0
   \   00000C   07           DB 7
   \   00000D   04           DB 4
   \   00000E   00           DB 0
   \   00000F   00           DB 0
   \   000010   0F           DB 15
   \   000011   01           DB 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for vDoPrimaryScan>`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zgBdbInstallCodeCRC>`:
   \   000000   83           DB 131
   \   000001   FE           DB 254
   \   000002   D3           DB 211
   \   000003   40           DB 64
   \   000004   7A           DB 122
   \   000005   93           DB 147
   \   000006   97           DB 151
   \   000007   23           DB 35
   \   000008   A5           DB 165
   \   000009   C6           DB 198
   \   00000A   39           DB 57
   \   00000B   B2           DB 178
   \   00000C   69           DB 105
   \   00000D   16           DB 22
   \   00000E   D5           DB 213
   \   00000F   05           DB 5
   \   000010   C3           DB 195
   \   000011   B5           DB 181

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e8:
   \   000000   E8030000     DD 1000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_32:
   \   000000   32000000     DD 50

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_c8:
   \   000000   C8000000     DD 200

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3a98:
   \   000000   983A0000     DD 15000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_10:
   \   000000   10000000     DD 16

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_RegisterSimpleDescriptor::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_RegisterSimpleDescriptor

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_ZclIdentifyCmdInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_ZclIdentifyCmdInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_addInstallCode::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_addInstallCode

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_RegisterTCLinkKeyExchangeProcessCB::?rela`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_RegisterTCLinkKeyExchangeProcessCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setTCRequireKeyExchange::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setTCRequireKeyExchange

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_TCAddJoiningDevice::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_TCAddJoiningDevice

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_TCProcessJoiningList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_TCProcessJoiningList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_TCjoiningDeviceComplete::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_TCjoiningDeviceComplete

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_TCJoiningDeviceFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_TCJoiningDeviceFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setJoinUsesInstallCodeKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setJoinUsesInstallCodeKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_StartCommissioning::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_StartCommissioning

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_NotifyCommissioningModeStart::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_NotifyCommissioningModeStart

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setFN::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setFN

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_resetLocalAction::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_resetLocalAction

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_parentLost::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_parentLost

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_NetworkRestoredResumeState::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_NetworkRestoredResumeState

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_reportCommissioningState::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_reportCommissioningState

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_nwkFormationAttempt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_nwkFormationAttempt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_isDeviceNonFactoryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_isDeviceNonFactoryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_doTrustCenterRequireKeyExchange::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_doTrustCenterRequireKeyExchange

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_rejoinNwk::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_rejoinNwk

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setChannelAttribute::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setChannelAttribute

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setChannel::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setChannel

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_nwkJoiningFormation::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_nwkJoiningFormation

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_nwkSteeringDeviceOnNwk::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_nwkSteeringDeviceOnNwk

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_startResumeCommissioningProcess::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_startResumeCommissioningProcess

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_event_loop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_ProcessNodeDescRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_ProcessNodeDescRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_touchlinkSendFNReset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_touchlinkSendFNReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setNodeIsOnANetwork::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setNodeIsOnANetwork

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setCommissioningGroupID::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setCommissioningGroupID

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_CreateRespondentList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_CreateRespondentList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_AddRespondentNode::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_AddRespondentNode

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_zclRespondentListClean::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_zclRespondentListClean

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_SendMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_SendMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_RegisterCommissioningStatusCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_RegisterCommissioningStatusCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_ClearNetworkParams::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_ClearNetworkParams

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_getZCLFrameCounter::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_getZCLFrameCounter

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??gp_ChangeChannelReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gp_ChangeChannelReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_GenerateInstallCodeCRC::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_GenerateInstallCodeCRC

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_calculateCCITT_CRC::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_calculateCCITT_CRC

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_crcInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_crcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_crcReflect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_crcReflect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_crcBitByBitFast::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_crcBitByBitFast
   3481          
   3482          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     10   bdb_AddRespondentNode
        0     10   -> bdb_CreateRespondentList
        0     10   -> osal_mem_alloc
      0      0   bdb_ClearNetworkParams
      0     20   bdb_CreateRespondentList
        0     10   -> osal_mem_alloc
      2     36   bdb_GenerateInstallCodeCRC
        2      6   -> bdb_calculateCCITT_CRC
      0      9   bdb_Init
        0      9   -> ZDO_RegisterForZDOMsg
        0      9   -> gp_RegisterGPChangeChannelReqForBDBCB
        0      9   -> gp_endpointInit
      0      0   bdb_NetworkRestoredResumeState
      1     36   bdb_NotifyCommissioningModeStart
        0     15   -> bdb_SendMsg
      0     49   bdb_ProcessNodeDescRsp
        0     45   -> APSME_IsDistributedSecurity
        0     45   -> ZDO_ParseNodeDescRsp
        0     45   -> bdb_reportCommissioningState
        0     45   -> bdb_setNodeJoinLinkKeyType
        0     45   -> bdb_tcLinkKeyExchangeAttempt
        0     49   -> osal_nv_write
        0     45   -> osal_stop_timerEx
      2      0   bdb_RegisterCommissioningStatusCB
      1     10   bdb_RegisterSimpleDescriptor
        0     10   -> afRegister
        0     10   -> osal_mem_alloc
      2      0   bdb_RegisterTCLinkKeyExchangeProcessCB
      1     80   bdb_SendMsg
        0     20   -> osal_memcpy
        0     17   -> osal_msg_allocate
        0     17   -> osal_msg_send
      0     36   bdb_StartCommissioning
        0     32   -> APSME_IsDistributedSecurity
        0     32   -> ZDOInitDeviceEx
        0     32   -> bdb_nwkSteeringDeviceOnNwk
        0     32   -> bdb_reportCommissioningState
        0     32   -> bdb_setNodeIsOnANetwork
        0     32   -> osal_get_timeoutEx
        0     32   -> osal_isbufset
        0     32   -> osal_memset
        0     36   -> osal_nv_read
        0     36   -> osal_nv_write
        0     32   -> osal_set_event
        0     32   -> zgWriteStartupOptions
      1     30   bdb_TCAddJoiningDevice
        0     28   -> bdb_SendMsg
        0     26   -> osal_mem_alloc
        0     29   -> osal_memcmp
        0     29   -> osal_memcpy
        0     30   -> osal_start_reload_timer
      0     75   bdb_TCJoiningDeviceFree
        0     14   -> osal_mem_free
        0     17   -> osal_memcmp
      0     86   bdb_TCProcessJoiningList
        0     60   -> APSME_SearchTCLinkKeyEntry
        0     58   -> AddrMgrEntryLookupExt
        0     60   -> ZDSecMgrAPSRemove
        0     58   -> ZDSecMgrAddrClear
        0     60   -> bdb_SendMsg
        0     58   -> bdb_TCJoiningDeviceFree
        0     61   -> osal_memcpy
        0     58   -> osal_memset
        0     62   -> osal_nv_write
        0     58   -> osal_stop_timerEx
      0     29   bdb_TCjoiningDeviceComplete
        0     28   -> bdb_SendMsg
        0     26   -> bdb_TCJoiningDeviceFree
        0     29   -> osal_memcmp
        0     29   -> osal_memcpy
        0     26   -> osal_stop_timerEx
      0     24   bdb_ZclIdentifyCmdInd
        0     24   -> osal_start_timerEx
        0     20   -> osal_stop_timerEx
        0     22   -> zclFindAttrRec
      0     34   bdb_addInstallCode
        0     30   -> APSME_AddTCLinkKey
        0     30   -> bdb_GenerateInstallCodeCRC
        0     30   -> osal_build_uint16
        0     34   -> sspMMOHash
      0     28   bdb_calculateCCITT_CRC
        0     22   -> bdb_crcBitByBitFast
        0     18   -> bdb_crcInit
      0     42   bdb_crcBitByBitFast
        0     20   -> bdb_crcReflect
      0     27   bdb_crcInit
      0     32   bdb_crcReflect
      2      0   bdb_doTrustCenterRequireKeyExchange
      1     28   bdb_event_loop
        0     24   -> bdb_ProcessIEEEAddrRsp
        0     24   -> bdb_ProcessRespondentList
        0     24   -> bdb_ProcessSimpleDesc
        0     24   -> bdb_SendIdentifyQuery
        0     24   -> bdb_TCProcessJoiningList
        0     24   -> bdb_exitFindingBindingWStatus
        0     24   -> bdb_getRespondentRetry
        0     24   -> bdb_nwkSteeringDeviceOnNwk
        0     24   -> bdb_reportCommissioningState
        0     24   -> bdb_setEpDescListToActiveEndpoint
        0     24   -> bdb_startResumeCommissioningProcess
        0     24   -> osal_get_timeoutEx
        0     24   -> osal_msg_deallocate
        0     24   -> osal_msg_receive
        0     28   -> osal_start_timerEx
        0     24   -> osal_stop_timerEx
        0     26   -> zclFindAttrRec
      2      0   bdb_getZCLFrameCounter
      2      0   bdb_isDeviceNonFactoryNew
      0      9   bdb_nwkFormationAttempt
        0      9   -> bdb_nwkJoiningFormation
        0      9   -> bdb_reportCommissioningState
      0     33   bdb_nwkJoiningFormation
        0     12   -> ZDOInitDeviceEx
        0     12   -> bdb_reportCommissioningState
        0     12   -> bdb_setChannel
      2     41   bdb_nwkSteeringDeviceOnNwk
        2      9   -> ZDP_MgmtPermitJoinReq
      0      0   bdb_parentLost
      0     10   bdb_rejoinNwk
        0     10   -> NLME_ReJoinRequest
        0     10   -> NLME_ReJoinRequestUnsecure
        0     10   -> ZDApp_ChangeState
        0     10   -> ZDApp_RestoreNwkKey
        0     10   -> ZMacSetReq
      1     63   bdb_reportCommissioningState
        0     14   -> NLME_ResetRequest
        0     14   -> ZDApp_ChangeState
        0     14   -> ZDApp_RestoreNwkSecMaterial
        0     14   -> ZMacSetReq
        0     16   -> bdb_SendMsg
        0     14   -> bdb_getRespondentRetry
        0     14   -> bdb_setFN
        0     14   -> bdb_zclRespondentListClean
        0     14   -> nwk_setStateIdle
        0     14   -> osal_get_timeoutEx
        0     18   -> osal_start_timerEx
        0     14   -> osal_stop_timerEx
        0     14   -> zgWriteStartupOptions
      2      0   bdb_resetLocalAction
        2      0   -> ZDApp_ResetTimerStart
        2      0   -> bdb_setFN
      0     28   bdb_setChannel
        0     16   -> osal_nv_write
      0     12   bdb_setChannelAttribute
      2      0   bdb_setCommissioningGroupID
      2     14   bdb_setFN
        2      0   -> bdb_setNodeIsOnANetwork
        2      0   -> zgWriteStartupOptions
      2      0   bdb_setJoinUsesInstallCodeKey
      0     46   bdb_setNodeIsOnANetwork
        0     14   -> osal_nv_write
      2      0   bdb_setTCRequireKeyExchange
      0     49   bdb_startResumeCommissioningProcess
        0     21   -> bdb_NotifyCommissioningModeStart
        0     21   -> bdb_SendIdentifyQuery
        0     23   -> bdb_SendMsg
        0     21   -> bdb_exitFindingBindingWStatus
        0     21   -> bdb_nwkJoiningFormation
        0     21   -> bdb_nwkSteeringDeviceOnNwk
        0     21   -> bdb_reportCommissioningState
        0     21   -> bdb_setEpDescListToActiveEndpoint
        0     21   -> osal_memset
        0     25   -> osal_start_timerEx
        0     23   -> zclFindAttrRec
      0      0   bdb_touchlinkSendFNReset
      0     26   bdb_zclRespondentListClean
        0     12   -> osal_mem_free
      2      0   gp_ChangeChannelReq


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      18  ?<Initializer for bdbAttributes>
       1  ?<Initializer for vDoPrimaryScan>
      18  ?<Initializer for zgBdbInstallCodeCRC>
       5  ??Subroutine45_0
       6  ??Subroutine46_0
       2  ??Subroutine47_0
       6  ??Subroutine48_0
       8  ??Subroutine49_0
      11  ??Subroutine50_0
       8  ??Subroutine51_0
       1  ??Subroutine52_0
       7  ??Subroutine53_0
      13  ??Subroutine54_0
       4  ??Subroutine55_0
       3  ??Subroutine56_0
       5  ??Subroutine57_0
       8  ??Subroutine58_0
       6  ??Subroutine59_0
       2  ??Subroutine60_0
      11  ??Subroutine61_0
       6  ??Subroutine62_0
       9  ??Subroutine63_0
      12  ??Subroutine64_0
       6  ??Subroutine65_0
       8  ??Subroutine66_0
       6  ??Subroutine67_0
       5  ?Subroutine0
       3  ?Subroutine1
       1  ?Subroutine10
      11  ?Subroutine11
       6  ?Subroutine12
       2  ?Subroutine13
      10  ?Subroutine14
      10  ?Subroutine15
       3  ?Subroutine16
       2  ?Subroutine17
       6  ?Subroutine18
       8  ?Subroutine19
       2  ?Subroutine2
      13  ?Subroutine20
       2  ?Subroutine21
       4  ?Subroutine22
       4  ?Subroutine23
      19  ?Subroutine24
      15  ?Subroutine25
       4  ?Subroutine26
       3  ?Subroutine27
       8  ?Subroutine28
      14  ?Subroutine29
       5  ?Subroutine3
       6  ?Subroutine30
      10  ?Subroutine31
       8  ?Subroutine32
       5  ?Subroutine33
      11  ?Subroutine34
       4  ?Subroutine35
       8  ?Subroutine36
       8  ?Subroutine37
      14  ?Subroutine38
      10  ?Subroutine39
       4  ?Subroutine4
       3  ?Subroutine40
       8  ?Subroutine41
       6  ?Subroutine42
       6  ?Subroutine43
       9  ?Subroutine44
      10  ?Subroutine5
       8  ?Subroutine6
       6  ?Subroutine7
       1  ?Subroutine8
      12  ?Subroutine9
       4  __Constant_10
       4  __Constant_32
       4  __Constant_3a98
       4  __Constant_3e8
       4  __Constant_c8
      18  bdbAttributes
       4  bdbCommissioningProcedureState
     177  bdb_AddRespondentNode
       6  bdb_AddRespondentNode::?relay
       3  bdb_ClearNetworkParams
       6  bdb_ClearNetworkParams::?relay
      29  bdb_CreateRespondentList
       6  bdb_CreateRespondentList::?relay
       2  bdb_CurrEpDescriptorList
       1  bdb_FBStateSuccessLatch
       1  bdb_FB_InitiatorCurrentCyclesNumber
      42  bdb_GenerateInstallCodeCRC
       6  bdb_GenerateInstallCodeCRC::?relay
       2  bdb_HeadEpDescriptorList
     151  bdb_Init
       6  bdb_Init::?relay
       3  bdb_NetworkRestoredResumeState
       6  bdb_NetworkRestoredResumeState::?relay
      38  bdb_NotifyCommissioningModeStart
       6  bdb_NotifyCommissioningModeStart::?relay
     168  bdb_ProcessNodeDescRsp
       6  bdb_ProcessNodeDescRsp::?relay
      10  bdb_RegisterCommissioningStatusCB
       6  bdb_RegisterCommissioningStatusCB::?relay
      57  bdb_RegisterSimpleDescriptor
       6  bdb_RegisterSimpleDescriptor::?relay
      17  bdb_RegisterTCLinkKeyExchangeProcessCB
       6  bdb_RegisterTCLinkKeyExchangeProcessCB::?relay
     115  bdb_SendMsg
       6  bdb_SendMsg::?relay
     420  bdb_StartCommissioning
       6  bdb_StartCommissioning::?relay
     334  bdb_TCAddJoiningDevice
       6  bdb_TCAddJoiningDevice::?relay
     144  bdb_TCJoiningDeviceFree
       6  bdb_TCJoiningDeviceFree::?relay
     412  bdb_TCProcessJoiningList
       6  bdb_TCProcessJoiningList::?relay
     183  bdb_TCjoiningDeviceComplete
       6  bdb_TCjoiningDeviceComplete::?relay
       1  bdb_TaskID
     135  bdb_ZclIdentifyCmdInd
       6  bdb_ZclIdentifyCmdInd::?relay
       1  bdb_ZclTransactionSequenceNumber
     125  bdb_addInstallCode
       6  bdb_addInstallCode::?relay
      97  bdb_calculateCCITT_CRC
       6  bdb_calculateCCITT_CRC::?relay
     187  bdb_crcBitByBitFast
       6  bdb_crcBitByBitFast::?relay
     109  bdb_crcInit
       6  bdb_crcInit::?relay
      79  bdb_crcReflect
       6  bdb_crcReflect::?relay
       9  bdb_doTrustCenterRequireKeyExchange
       6  bdb_doTrustCenterRequireKeyExchange::?relay
     575  bdb_event_loop
       6  bdb_event_loop::?relay
      13  bdb_getZCLFrameCounter
       6  bdb_getZCLFrameCounter::?relay
       1  bdb_initialization
       7  bdb_isDeviceNonFactoryNew
       6  bdb_isDeviceNonFactoryNew::?relay
       2  bdb_joiningDeviceList
      51  bdb_nwkFormationAttempt
       6  bdb_nwkFormationAttempt::?relay
     110  bdb_nwkJoiningFormation
       6  bdb_nwkJoiningFormation::?relay
      45  bdb_nwkSteeringDeviceOnNwk
       6  bdb_nwkSteeringDeviceOnNwk::?relay
       3  bdb_parentLost
       6  bdb_parentLost::?relay
     127  bdb_rejoinNwk
       6  bdb_rejoinNwk::?relay
     529  bdb_reportCommissioningState
       6  bdb_reportCommissioningState::?relay
      16  bdb_resetLocalAction
       6  bdb_resetLocalAction::?relay
      64  bdb_setChannel
       6  bdb_setChannel::?relay
      31  bdb_setChannelAttribute
       6  bdb_setChannelAttribute::?relay
      10  bdb_setCommissioningGroupID
       6  bdb_setCommissioningGroupID::?relay
      18  bdb_setFN
       6  bdb_setFN::?relay
      23  bdb_setJoinUsesInstallCodeKey
       6  bdb_setJoinUsesInstallCodeKey::?relay
      64  bdb_setNodeIsOnANetwork
       6  bdb_setNodeIsOnANetwork::?relay
      11  bdb_setTCRequireKeyExchange
       6  bdb_setTCRequireKeyExchange::?relay
     449  bdb_startResumeCommissioningProcess
       6  bdb_startResumeCommissioningProcess::?relay
       3  bdb_touchlinkSendFNReset
       6  bdb_touchlinkSendFNReset::?relay
      70  bdb_zclRespondentListClean
       6  bdb_zclRespondentListClean::?relay
      17  gp_ChangeChannelReq
       6  gp_ChangeChannelReq::?relay
       2  pRespondentCurr
       2  pRespondentHead
       2  pRespondentNext
       2  pfnCommissioningStatusCB
       2  pfnTCLinkKeyExchangeProcessCB
       1  touchLinkTargetEnabled
       1  vDoPrimaryScan
      18  zgBdbInstallCodeCRC

 
 5 750 bytes in segment BANKED_CODE
   270 bytes in segment BANK_RELAYS
    37 bytes in segment XDATA_I
    37 bytes in segment XDATA_ID
    20 bytes in segment XDATA_ROM_C
    26 bytes in segment XDATA_Z
 
   307 bytes of CODE     memory
     0 bytes of CONST    memory (+ 20 bytes shared)
 5 750 bytes of HUGECODE memory
    63 bytes of XDATA    memory

Errors: none
Warnings: none
